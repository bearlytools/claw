// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

// Package maps
package maps

import (
    "context"
    "io"
    "bytes"
    "fmt"

    "github.com/bearlytools/claw/clawc/languages/go/mapping"
    "github.com/bearlytools/claw/languages/go/reflect"
    "github.com/bearlytools/claw/languages/go/reflect/runtime"
    "github.com/bearlytools/claw/clawc/languages/go/segment"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
)

// Ensure imports are used.
var (
    _ context.Context
    _ = io.EOF
    _ = bytes.MinRead
    _ = fmt.Errorf
    _ mapping.Map
    _ reflect.StructDescr
    _ = runtime.RegisterPackage
    _ segment.Struct
    _ = field.FTBool
)

// SyntaxVersion is the major version of the Claw language that is being rendered.
const SyntaxVersion = 0

var _package = "maps"
var _packagePath = "github.com/bearlytools/claw/testing/maps/claw"




type ComplexMaps struct {
   s *segment.Struct
}

// NewComplexMaps creates a new pooled instance of ComplexMaps.
// Call Release() when done to return it to the pool for reuse.
func NewComplexMaps(ctx context.Context) ComplexMaps {
    s := segment.NewPooled(ctx, XXXMappingComplexMaps)
    s.SetIsSetEnabled(true)
    return ComplexMaps{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ComplexMaps) Release(ctx context.Context) {
    segment.Release(ctx, x.s)
}

// XXXNewComplexMapsFrom creates a new ComplexMaps from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewComplexMapsFrom(s *segment.Struct) ComplexMaps {
    return ComplexMaps{s: s}
}

// Marshal marshal's the Struct to []byte.
func (x ComplexMaps) Marshal() ([]byte, error) {
    return x.s.MarshalBytes()
}

// MarshalWriter marshals to an io.Writer.
func (x ComplexMaps) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.Marshal(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ComplexMaps) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ComplexMaps) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}


// SettingsMap returns the underlying map for iteration and modification.
// The map values are *segment.Struct - use XXXNewSettingFrom() to wrap them.
func (x ComplexMaps) SettingsMap() *segment.Maps[string, *segment.Struct] {
    // Check if we already have this map cached
    if m := segment.GetMapStruct[string](x.s, 0, field.FTString, XXXMappingSetting); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[string, *segment.Struct](x.s, 0, field.FTString, field.FTStruct, XXXMappingSetting)
}

// SettingsGet returns the value for the given key, or nil if not found.
func (x ComplexMaps) SettingsGet(key string) (Setting, bool) {
    s, ok := x.SettingsMap().Get(key)
    if !ok || s == nil {
        return Setting{}, false
    }
    return XXXNewSettingFrom(s), true
}

// SettingsSet sets a key-value pair in the map.
func (x ComplexMaps) SettingsSet(key string, value Setting) ComplexMaps {
    x.SettingsMap().Set(key, value.XXXGetStruct())
    return x
}

// SettingsDelete removes a key from the map.
func (x ComplexMaps) SettingsDelete(key string) ComplexMaps {
    x.SettingsMap().Delete(key)
    return x
}

// SettingsHas returns true if the key exists in the map.
func (x ComplexMaps) SettingsHas(key string) bool {
    return x.SettingsMap().Has(key)
}

// SettingsLen returns the number of entries in the map.
func (x ComplexMaps) SettingsLen() int {
    return x.SettingsMap().Len()
}
func (x ComplexMaps) IsSetSettings() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ComplexMaps) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ComplexMaps) XXXGetStruct() *segment.Struct {
    return x.s
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ComplexMaps) SetRecording(enabled bool) ComplexMaps {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ComplexMaps) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ComplexMaps) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ComplexMaps) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ComplexMapsRaw is a plain Go struct representation of ComplexMaps.
// Zero values are not set (sparse encoding).
type ComplexMapsRaw struct {
    Settings map[string]*SettingRaw
}

// NewComplexMapsFromRaw creates a new ComplexMaps from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewComplexMapsFromRaw(ctx context.Context, raw ComplexMapsRaw) ComplexMaps {
    x := NewComplexMaps(ctx)
    if raw.Settings != nil {
        m := x.SettingsMap()
        for k, v := range raw.Settings {
            if v != nil {
                m.Set(k, NewSettingFromRaw(ctx, *v).XXXGetStruct())
            }
        }
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ComplexMaps) ToRaw() ComplexMapsRaw {
    raw := ComplexMapsRaw{}
    // For maps, check if there's a cached dirty map or field data
    // Don't use HasField alone as the map may not have been synced yet
    if m := x.SettingsMap(); m.Len() > 0 {
        raw.Settings = make(map[string]*SettingRaw)
        for k, v := range m.All() {
            item := Setting{s: v}
            itemRaw := item.ToRaw()
            raw.Settings[k] = &itemRaw
        }
    }
    return raw
}

 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ComplexMaps) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(0)
}

type Config struct {
   s *segment.Struct
}

// NewConfig creates a new pooled instance of Config.
// Call Release() when done to return it to the pool for reuse.
func NewConfig(ctx context.Context) Config {
    s := segment.NewPooled(ctx, XXXMappingConfig)
    s.SetIsSetEnabled(true)
    return Config{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Config) Release(ctx context.Context) {
    segment.Release(ctx, x.s)
}

// XXXNewConfigFrom creates a new Config from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewConfigFrom(s *segment.Struct) Config {
    return Config{s: s}
}

// Marshal marshal's the Struct to []byte.
func (x Config) Marshal() ([]byte, error) {
    return x.s.MarshalBytes()
}

// MarshalWriter marshals to an io.Writer.
func (x Config) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.Marshal(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Config) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Config) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}


// LabelsMap returns the underlying map for iteration and modification.
func (x Config) LabelsMap() *segment.Maps[string, string] {
    // Check if we already have this map cached
    if m := segment.GetMapScalar[string, string](x.s, 0, field.FTString, field.FTString); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[string, string](x.s, 0, field.FTString, field.FTString, nil)
}

// LabelsGet returns the value for the given key, or false if not found.
func (x Config) LabelsGet(key string) (string, bool) {
    return x.LabelsMap().Get(key)
}

// LabelsSet sets a key-value pair in the map.
func (x Config) LabelsSet(key string, value string) Config {
    x.LabelsMap().Set(key, value)
    return x
}

// LabelsDelete removes a key from the map.
func (x Config) LabelsDelete(key string) Config {
    x.LabelsMap().Delete(key)
    return x
}

// LabelsHas returns true if the key exists in the map.
func (x Config) LabelsHas(key string) bool {
    return x.LabelsMap().Has(key)
}

// LabelsLen returns the number of entries in the map.
func (x Config) LabelsLen() int {
    return x.LabelsMap().Len()
}
func (x Config) IsSetLabels() bool{
    return x.s.HasField(0)
}


// PortsMap returns the underlying map for iteration and modification.
func (x Config) PortsMap() *segment.Maps[string, int32] {
    // Check if we already have this map cached
    if m := segment.GetMapScalar[string, int32](x.s, 1, field.FTString, field.FTInt32); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[string, int32](x.s, 1, field.FTString, field.FTInt32, nil)
}

// PortsGet returns the value for the given key, or false if not found.
func (x Config) PortsGet(key string) (int32, bool) {
    return x.PortsMap().Get(key)
}

// PortsSet sets a key-value pair in the map.
func (x Config) PortsSet(key string, value int32) Config {
    x.PortsMap().Set(key, value)
    return x
}

// PortsDelete removes a key from the map.
func (x Config) PortsDelete(key string) Config {
    x.PortsMap().Delete(key)
    return x
}

// PortsHas returns true if the key exists in the map.
func (x Config) PortsHas(key string) bool {
    return x.PortsMap().Has(key)
}

// PortsLen returns the number of entries in the map.
func (x Config) PortsLen() int {
    return x.PortsMap().Len()
}
func (x Config) IsSetPorts() bool{
    return x.s.HasField(1)
}


// EnabledMap returns the underlying map for iteration and modification.
func (x Config) EnabledMap() *segment.Maps[string, bool] {
    // Check if we already have this map cached
    if m := segment.GetMapScalar[string, bool](x.s, 2, field.FTString, field.FTBool); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[string, bool](x.s, 2, field.FTString, field.FTBool, nil)
}

// EnabledGet returns the value for the given key, or false if not found.
func (x Config) EnabledGet(key string) (bool, bool) {
    return x.EnabledMap().Get(key)
}

// EnabledSet sets a key-value pair in the map.
func (x Config) EnabledSet(key string, value bool) Config {
    x.EnabledMap().Set(key, value)
    return x
}

// EnabledDelete removes a key from the map.
func (x Config) EnabledDelete(key string) Config {
    x.EnabledMap().Delete(key)
    return x
}

// EnabledHas returns true if the key exists in the map.
func (x Config) EnabledHas(key string) bool {
    return x.EnabledMap().Has(key)
}

// EnabledLen returns the number of entries in the map.
func (x Config) EnabledLen() int {
    return x.EnabledMap().Len()
}
func (x Config) IsSetEnabled() bool{
    return x.s.HasField(2)
}


// CountsMap returns the underlying map for iteration and modification.
func (x Config) CountsMap() *segment.Maps[int32, int64] {
    // Check if we already have this map cached
    if m := segment.GetMapScalar[int32, int64](x.s, 3, field.FTInt32, field.FTInt64); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[int32, int64](x.s, 3, field.FTInt32, field.FTInt64, nil)
}

// CountsGet returns the value for the given key, or false if not found.
func (x Config) CountsGet(key int32) (int64, bool) {
    return x.CountsMap().Get(key)
}

// CountsSet sets a key-value pair in the map.
func (x Config) CountsSet(key int32, value int64) Config {
    x.CountsMap().Set(key, value)
    return x
}

// CountsDelete removes a key from the map.
func (x Config) CountsDelete(key int32) Config {
    x.CountsMap().Delete(key)
    return x
}

// CountsHas returns true if the key exists in the map.
func (x Config) CountsHas(key int32) bool {
    return x.CountsMap().Has(key)
}

// CountsLen returns the number of entries in the map.
func (x Config) CountsLen() int {
    return x.CountsMap().Len()
}
func (x Config) IsSetCounts() bool{
    return x.s.HasField(3)
}


// RatiosMap returns the underlying map for iteration and modification.
func (x Config) RatiosMap() *segment.Maps[float64, string] {
    // Check if we already have this map cached
    if m := segment.GetMapScalar[float64, string](x.s, 4, field.FTFloat64, field.FTString); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[float64, string](x.s, 4, field.FTFloat64, field.FTString, nil)
}

// RatiosGet returns the value for the given key, or false if not found.
func (x Config) RatiosGet(key float64) (string, bool) {
    return x.RatiosMap().Get(key)
}

// RatiosSet sets a key-value pair in the map.
func (x Config) RatiosSet(key float64, value string) Config {
    x.RatiosMap().Set(key, value)
    return x
}

// RatiosDelete removes a key from the map.
func (x Config) RatiosDelete(key float64) Config {
    x.RatiosMap().Delete(key)
    return x
}

// RatiosHas returns true if the key exists in the map.
func (x Config) RatiosHas(key float64) bool {
    return x.RatiosMap().Has(key)
}

// RatiosLen returns the number of entries in the map.
func (x Config) RatiosLen() int {
    return x.RatiosMap().Len()
}
func (x Config) IsSetRatios() bool{
    return x.s.HasField(4)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Config) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Config) XXXGetStruct() *segment.Struct {
    return x.s
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Config) SetRecording(enabled bool) Config {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Config) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Config) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Config) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ConfigRaw is a plain Go struct representation of Config.
// Zero values are not set (sparse encoding).
type ConfigRaw struct {
    Labels map[string]string
    Ports map[string]int32
    Enabled map[string]bool
    Counts map[int32]int64
    Ratios map[float64]string
}

// NewConfigFromRaw creates a new Config from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewConfigFromRaw(ctx context.Context, raw ConfigRaw) Config {
    x := NewConfig(ctx)
    if raw.Labels != nil {
        m := x.LabelsMap()
        for k, v := range raw.Labels {
            m.Set(k, v)
        }
    }
    if raw.Ports != nil {
        m := x.PortsMap()
        for k, v := range raw.Ports {
            m.Set(k, v)
        }
    }
    if raw.Enabled != nil {
        m := x.EnabledMap()
        for k, v := range raw.Enabled {
            m.Set(k, v)
        }
    }
    if raw.Counts != nil {
        m := x.CountsMap()
        for k, v := range raw.Counts {
            m.Set(k, v)
        }
    }
    if raw.Ratios != nil {
        m := x.RatiosMap()
        for k, v := range raw.Ratios {
            m.Set(k, v)
        }
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Config) ToRaw() ConfigRaw {
    raw := ConfigRaw{}
    // For maps, check if there's a cached dirty map or field data
    // Don't use HasField alone as the map may not have been synced yet
    if m := x.LabelsMap(); m.Len() > 0 {
        raw.Labels = make(map[string]string)
        for k, v := range m.All() {
            raw.Labels[k] = v
        }
    }
    // For maps, check if there's a cached dirty map or field data
    // Don't use HasField alone as the map may not have been synced yet
    if m := x.PortsMap(); m.Len() > 0 {
        raw.Ports = make(map[string]int32)
        for k, v := range m.All() {
            raw.Ports[k] = v
        }
    }
    // For maps, check if there's a cached dirty map or field data
    // Don't use HasField alone as the map may not have been synced yet
    if m := x.EnabledMap(); m.Len() > 0 {
        raw.Enabled = make(map[string]bool)
        for k, v := range m.All() {
            raw.Enabled[k] = v
        }
    }
    // For maps, check if there's a cached dirty map or field data
    // Don't use HasField alone as the map may not have been synced yet
    if m := x.CountsMap(); m.Len() > 0 {
        raw.Counts = make(map[int32]int64)
        for k, v := range m.All() {
            raw.Counts[k] = v
        }
    }
    // For maps, check if there's a cached dirty map or field data
    // Don't use HasField alone as the map may not have been synced yet
    if m := x.RatiosMap(); m.Len() > 0 {
        raw.Ratios = make(map[float64]string)
        for k, v := range m.All() {
            raw.Ratios[k] = v
        }
    }
    return raw
}

 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Config) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(1)
}

type Setting struct {
   s *segment.Struct
}

// NewSetting creates a new pooled instance of Setting.
// Call Release() when done to return it to the pool for reuse.
func NewSetting(ctx context.Context) Setting {
    s := segment.NewPooled(ctx, XXXMappingSetting)
    s.SetIsSetEnabled(true)
    return Setting{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Setting) Release(ctx context.Context) {
    segment.Release(ctx, x.s)
}

// XXXNewSettingFrom creates a new Setting from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSettingFrom(s *segment.Struct) Setting {
    return Setting{s: s}
}

// Marshal marshal's the Struct to []byte.
func (x Setting) Marshal() ([]byte, error) {
    return x.s.MarshalBytes()
}

// MarshalWriter marshals to an io.Writer.
func (x Setting) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.Marshal(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Setting) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Setting) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Setting) Name() string {
    return segment.GetString(x.s, 0)
}

func (x Setting) SetName(value string) Setting {
    segment.SetString(x.s, 0, value)
    return x
}
func (x Setting) IsSetName() bool{
    return x.s.HasField(0)
}

func (x Setting) Value() string {
    return segment.GetString(x.s, 1)
}

func (x Setting) SetValue(value string) Setting {
    segment.SetString(x.s, 1, value)
    return x
}
func (x Setting) IsSetValue() bool{
    return x.s.HasField(1)
}

func (x Setting) Priority() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x Setting) SetPriority(value int32) Setting {
    segment.SetInt32(x.s, 2, value)
    return x
}
func (x Setting) IsSetPriority() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Setting) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Setting) XXXGetStruct() *segment.Struct {
    return x.s
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Setting) SetRecording(enabled bool) Setting {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Setting) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Setting) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Setting) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SettingRaw is a plain Go struct representation of Setting.
// Zero values are not set (sparse encoding).
type SettingRaw struct {
    Name string
    Value string
    Priority int32
}

// NewSettingFromRaw creates a new Setting from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSettingFromRaw(ctx context.Context, raw SettingRaw) Setting {
    x := NewSetting(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Value != "" {
        x.SetValue(raw.Value)
    }
    if raw.Priority != 0 {
        x.SetPriority(raw.Priority)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Setting) ToRaw() SettingRaw {
    raw := SettingRaw{}
    raw.Name = x.Name()
    raw.Value = x.Value()
    raw.Priority = x.Priority()
    return raw
}

 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Setting) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(2)
} 

// Everything below this line is internal details.
// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingComplexMaps = &mapping.Map{
    Name: "ComplexMaps",
    Pkg: "maps",
    Path: "github.com/bearlytools/claw/testing/maps/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Settings",
            Type: field.FTMap,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 0,
            IsEnum: false,
            IsMap: true,
            KeyType: field.FTString,
            ValueType: field.FTStruct,
            ValueMapping: XXXMappingSetting,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingConfig = &mapping.Map{
    Name: "Config",
    Pkg: "maps",
    Path: "github.com/bearlytools/claw/testing/maps/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Labels",
            Type: field.FTMap,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 0,
            IsEnum: false,
            IsMap: true,
            KeyType: field.FTString,
            ValueType: field.FTString,
        },
        {
            Name: "Ports",
            Type: field.FTMap,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 1,
            IsEnum: false,
            IsMap: true,
            KeyType: field.FTString,
            ValueType: field.FTInt32,
        },
        {
            Name: "Enabled",
            Type: field.FTMap,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 2,
            IsEnum: false,
            IsMap: true,
            KeyType: field.FTString,
            ValueType: field.FTBool,
        },
        {
            Name: "Counts",
            Type: field.FTMap,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 3,
            IsEnum: false,
            IsMap: true,
            KeyType: field.FTInt32,
            ValueType: field.FTInt64,
        },
        {
            Name: "Ratios",
            Type: field.FTMap,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 4,
            IsEnum: false,
            IsMap: true,
            KeyType: field.FTFloat64,
            ValueType: field.FTString,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSetting = &mapping.Map{
    Name: "Setting",
    Pkg: "maps",
    Path: "github.com/bearlytools/claw/testing/maps/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 0,
            IsEnum: false,
        },
        {
            Name: "Value",
            Type: field.FTString,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 1,
            IsEnum: false,
        },
        {
            Name: "Priority",
            Type: field.FTInt32,
            Package: "maps",
            FullPath: "github.com/bearlytools/claw/testing/maps/claw",
            FieldNum: 2,
            IsEnum: false,
        },
    },
}


// init initializes all mapping function pointer tables for O(1) dispatch.
func init() {
    XXXMappingComplexMaps.Init()
    XXXMappingConfig.Init()
    XXXMappingSetting.Init()
}

 


var XXXStructDescrComplexMaps = &reflect.XXXStructDescrImpl{
    Name:      "ComplexMaps",
    Pkg:       XXXMappingComplexMaps.Pkg,
    Path:      XXXMappingComplexMaps.Path,
    Mapping:   XXXMappingComplexMaps,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingComplexMaps.Fields[0],  
        },  
    },
}

var XXXStructDescrConfig = &reflect.XXXStructDescrImpl{
    Name:      "Config",
    Pkg:       XXXMappingConfig.Pkg,
    Path:      XXXMappingConfig.Path,
    Mapping:   XXXMappingConfig,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfig.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfig.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfig.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfig.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfig.Fields[4],  
        },  
    },
}

var XXXStructDescrSetting = &reflect.XXXStructDescrImpl{
    Name:      "Setting",
    Pkg:       XXXMappingSetting.Pkg,
    Path:      XXXMappingSetting.Path,
    Mapping:   XXXMappingSetting,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSetting.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSetting.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSetting.Fields[2],  
        },  
    },
}

var XXXStructDescrs = map[string]*reflect.XXXStructDescrImpl{
    "ComplexMaps":  XXXStructDescrComplexMaps,
    "Config":  XXXStructDescrConfig,
    "Setting":  XXXStructDescrSetting,
}

// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
var XXXPackageDescr reflect.PackageDescr = &reflect.XXXPackageDescrImpl{
    Name: "maps",
    Path: "github.com/bearlytools/claw/testing/maps/claw",
    StructsDescrs: reflect.XXXStructDescrsImpl{
        Descrs: []reflect.StructDescr{
            XXXStructDescrComplexMaps,
            XXXStructDescrConfig,
            XXXStructDescrSetting,
        },
    },
}

// PackageDescr returns a PackageDescr for this package.
func PackageDescr() reflect.PackageDescr {
    return XXXPackageDescr
}

// Registers our package description with the runtime.
func init() {
    runtime.RegisterPackage(XXXPackageDescr)
}
