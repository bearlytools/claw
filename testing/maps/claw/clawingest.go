// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

package maps

import (
    "context"
    "fmt"
    "iter"

    "github.com/bearlytools/claw/clawc/languages/go/clawiter"
    "github.com/bearlytools/claw/clawc/languages/go/field"
)

// Ensure imports are used.
var _ context.Context
var _ = fmt.Errorf
var _ = field.FTBool


// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *ComplexMaps) IngestWithOptions(ctx context.Context, tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *ComplexMaps) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in ComplexMaps")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Settings":
            if tok.IsNil {
                continue
            }
            mapStartTok, ok := ts.Next()
            if !ok || mapStartTok.Kind != clawiter.TokenMapStart {
                return fmt.Errorf("expected TokenMapStart for Settings")
            }
            m := x.SettingsMap()
            for {
                entryTok, ok := ts.Next()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Settings map")
                }
                if entryTok.Kind == clawiter.TokenMapEnd {
                    break
                }
                if entryTok.Kind != clawiter.TokenMapEntry {
                    return fmt.Errorf("expected TokenMapEntry for Settings, got %v", entryTok.Kind)
                }
                // Get the key
                key := entryTok.KeyString()
                // Get the value
                // Struct value - ingest from following struct tokens
                value := NewSetting(ctx)
                if err := value.XXXIngestFrom(ctx, ts, opts); err != nil {
                    return fmt.Errorf("ingesting Settings[%v]: %w", key, err)
                }
                m.Set(key, value.XXXGetStruct())
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Config) IngestWithOptions(ctx context.Context, tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Config) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Config")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Labels":
            if tok.IsNil {
                continue
            }
            mapStartTok, ok := ts.Next()
            if !ok || mapStartTok.Kind != clawiter.TokenMapStart {
                return fmt.Errorf("expected TokenMapStart for Labels")
            }
            m := x.LabelsMap()
            for {
                entryTok, ok := ts.Next()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Labels map")
                }
                if entryTok.Kind == clawiter.TokenMapEnd {
                    break
                }
                if entryTok.Kind != clawiter.TokenMapEntry {
                    return fmt.Errorf("expected TokenMapEntry for Labels, got %v", entryTok.Kind)
                }
                // Get the key
                key := entryTok.KeyString()
                // Get the value
                m.Set(key, entryTok.String())
            }
        case "Ports":
            if tok.IsNil {
                continue
            }
            mapStartTok, ok := ts.Next()
            if !ok || mapStartTok.Kind != clawiter.TokenMapStart {
                return fmt.Errorf("expected TokenMapStart for Ports")
            }
            m := x.PortsMap()
            for {
                entryTok, ok := ts.Next()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Ports map")
                }
                if entryTok.Kind == clawiter.TokenMapEnd {
                    break
                }
                if entryTok.Kind != clawiter.TokenMapEntry {
                    return fmt.Errorf("expected TokenMapEntry for Ports, got %v", entryTok.Kind)
                }
                // Get the key
                key := entryTok.KeyString()
                // Get the value
                m.Set(key, entryTok.Int32())
            }
        case "Enabled":
            if tok.IsNil {
                continue
            }
            mapStartTok, ok := ts.Next()
            if !ok || mapStartTok.Kind != clawiter.TokenMapStart {
                return fmt.Errorf("expected TokenMapStart for Enabled")
            }
            m := x.EnabledMap()
            for {
                entryTok, ok := ts.Next()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Enabled map")
                }
                if entryTok.Kind == clawiter.TokenMapEnd {
                    break
                }
                if entryTok.Kind != clawiter.TokenMapEntry {
                    return fmt.Errorf("expected TokenMapEntry for Enabled, got %v", entryTok.Kind)
                }
                // Get the key
                key := entryTok.KeyString()
                // Get the value
                m.Set(key, entryTok.Bool())
            }
        case "Counts":
            if tok.IsNil {
                continue
            }
            mapStartTok, ok := ts.Next()
            if !ok || mapStartTok.Kind != clawiter.TokenMapStart {
                return fmt.Errorf("expected TokenMapStart for Counts")
            }
            m := x.CountsMap()
            for {
                entryTok, ok := ts.Next()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Counts map")
                }
                if entryTok.Kind == clawiter.TokenMapEnd {
                    break
                }
                if entryTok.Kind != clawiter.TokenMapEntry {
                    return fmt.Errorf("expected TokenMapEntry for Counts, got %v", entryTok.Kind)
                }
                // Get the key
                key := entryTok.KeyInt32()
                // Get the value
                m.Set(key, entryTok.Int64())
            }
        case "Ratios":
            if tok.IsNil {
                continue
            }
            mapStartTok, ok := ts.Next()
            if !ok || mapStartTok.Kind != clawiter.TokenMapStart {
                return fmt.Errorf("expected TokenMapStart for Ratios")
            }
            m := x.RatiosMap()
            for {
                entryTok, ok := ts.Next()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Ratios map")
                }
                if entryTok.Kind == clawiter.TokenMapEnd {
                    break
                }
                if entryTok.Kind != clawiter.TokenMapEntry {
                    return fmt.Errorf("expected TokenMapEntry for Ratios, got %v", entryTok.Kind)
                }
                // Get the key
                key := entryTok.KeyFloat64()
                // Get the value
                m.Set(key, entryTok.String())
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Setting) IngestWithOptions(ctx context.Context, tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Setting) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Setting")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Name":
            x.SetName(tok.String())
        case "Value":
            x.SetValue(tok.String())
        case "Priority":
            x.SetPriority(tok.Int32())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

