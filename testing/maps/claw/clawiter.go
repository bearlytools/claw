// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

package maps

import (
    "context"
    "iter"
    "math"

    "github.com/bearlytools/claw/clawc/languages/go/clawiter"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
)

// Ensure imports are used.
var _ = math.Float32bits
var _ context.Context


// Walk returns an iterator that emits tokens for serialization.
// This walks all fields including nested structs and lists.
func (x ComplexMaps) Walk(ctx context.Context) iter.Seq[clawiter.Token] {
    return func(yield func(clawiter.Token) bool) {
        if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "ComplexMaps"}) {
            return
        }
        // Field 0: Settings
        {
            m := x.SettingsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Settings", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTStruct, IsNil: true, StructName: "Setting"}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Settings", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTStruct, StructName: "Setting"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Settings", KeyType: field.FTString, ValueType: field.FTStruct, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    // Map with struct values
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Settings", KeyType: field.FTString, ValueType: field.FTStruct, StructName: "Setting"}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    // Struct value - will be followed by struct walk
                    if !yield(tok) {
                        return
                    }
                    if v != nil {
                        wrapped := XXXNewSettingFrom(v)
                        for structTok := range wrapped.Walk(ctx) {
                            if !yield(structTok) {
                                return
                            }
                        }
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Settings"}) {
                    return
                }
            }
        }

        if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "ComplexMaps"}) {
            return
        }
    }
}

// Walk returns an iterator that emits tokens for serialization.
// This walks all fields including nested structs and lists.
func (x Config) Walk(ctx context.Context) iter.Seq[clawiter.Token] {
    return func(yield func(clawiter.Token) bool) {
        if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Config"}) {
            return
        }
        // Field 0: Labels
        {
            m := x.LabelsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Labels", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTString, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Labels", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTString}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Labels", KeyType: field.FTString, ValueType: field.FTString, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Labels", KeyType: field.FTString, ValueType: field.FTString}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    tok.Bytes = []byte(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Labels"}) {
                    return
                }
            }
        }
        // Field 1: Ports
        {
            m := x.PortsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ports", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTInt32, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ports", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTInt32}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Ports", KeyType: field.FTString, ValueType: field.FTInt32, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Ports", KeyType: field.FTString, ValueType: field.FTInt32}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    tok.SetInt32(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Ports"}) {
                    return
                }
            }
        }
        // Field 2: Enabled
        {
            m := x.EnabledMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Enabled", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTBool, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Enabled", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTBool}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Enabled", KeyType: field.FTString, ValueType: field.FTBool, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Enabled", KeyType: field.FTString, ValueType: field.FTBool}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    tok.SetBool(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Enabled"}) {
                    return
                }
            }
        }
        // Field 3: Counts
        {
            m := x.CountsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Counts", Type: field.FTMap, KeyType: field.FTInt32, ValueType: field.FTInt64, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Counts", Type: field.FTMap, KeyType: field.FTInt32, ValueType: field.FTInt64}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Counts", KeyType: field.FTInt32, ValueType: field.FTInt64, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Counts", KeyType: field.FTInt32, ValueType: field.FTInt64}
                    // Set the key
                    tok.SetKeyInt32(k)
                    // Set the value
                    tok.SetInt64(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Counts"}) {
                    return
                }
            }
        }
        // Field 4: Ratios
        {
            m := x.RatiosMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ratios", Type: field.FTMap, KeyType: field.FTFloat64, ValueType: field.FTString, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ratios", Type: field.FTMap, KeyType: field.FTFloat64, ValueType: field.FTString}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Ratios", KeyType: field.FTFloat64, ValueType: field.FTString, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Ratios", KeyType: field.FTFloat64, ValueType: field.FTString}
                    // Set the key
                    tok.SetKeyFloat64(k)
                    // Set the value
                    tok.Bytes = []byte(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Ratios"}) {
                    return
                }
            }
        }

        if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Config"}) {
            return
        }
    }
}

// Walk returns an iterator that emits tokens for serialization.
// This walks all fields including nested structs and lists.
func (x Setting) Walk(ctx context.Context) iter.Seq[clawiter.Token] {
    return func(yield func(clawiter.Token) bool) {
        if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Setting"}) {
            return
        }
        // Field 0: Name
        {
            s := x.Name()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Name", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Value
        {
            s := x.Value()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Value", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 2: Priority
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Priority", Type: field.FTInt32}
            tok.SetInt32(x.Priority())
            if !yield(tok) {
                return
            }
        }

        if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Setting"}) {
            return
        }
    }
}

