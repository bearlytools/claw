// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

package maps

import (
    "context"
    "math"

    "github.com/bearlytools/claw/clawc/languages/go/clawiter"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
)

// Ensure imports are used.
var _ = math.Float32bits
var _ context.Context


// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x AnyMaps) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "AnyMaps"}) {
        return
    }
        // Field 0: Data
        {
            m := x.DataMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Data", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTAny, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Data", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTAny}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Data", KeyType: field.FTString, ValueType: field.FTAny, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Data", KeyType: field.FTString, ValueType: field.FTAny}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    // Any value - yield token with type hash and raw data
                    if v != nil {
                        tok.TypeHash = v.TypeHash[:]
                        tok.Bytes = v.Data
                    }
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Data"}) {
                    return
                }
            }
        }
        // Field 1: Items
        {
            m := x.ItemsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Items", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTListAny, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Items", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTListAny}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Items", KeyType: field.FTString, ValueType: field.FTListAny, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Items", KeyType: field.FTString, ValueType: field.FTListAny}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    // List of Any values
                    if !yield(tok) {
                        return
                    }
                    if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "", Type: field.FTListAny, Len: len(v)}) {
                        return
                    }
                    for _, anyVal := range v {
                        anyTok := clawiter.Token{
                            Kind: clawiter.TokenField,
                            Name: "",
                            Type: field.FTAny,
                            TypeHash: anyVal.TypeHash[:],
                            Bytes: anyVal.Data,
                        }
                        if !yield(anyTok) {
                            return
                        }
                    }
                    if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: ""}) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Items"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "AnyMaps"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x ComplexMaps) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "ComplexMaps"}) {
        return
    }
        // Field 0: Settings
        {
            m := x.SettingsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Settings", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTStruct, IsNil: true, StructName: "Setting"}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Settings", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTStruct, StructName: "Setting"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Settings", KeyType: field.FTString, ValueType: field.FTStruct, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    // Map with struct values
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Settings", KeyType: field.FTString, ValueType: field.FTStruct, StructName: "Setting"}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    // Struct value - will be followed by struct walk
                    if !yield(tok) {
                        return
                    }
                    if v != nil {
                        wrapped := XXXNewSettingFrom(v)
                        wrapped.Walk(ctx, yield, opts...)
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Settings"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "ComplexMaps"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Config) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Config"}) {
        return
    }
        // Field 0: Labels
        {
            m := x.LabelsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Labels", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTString, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Labels", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTString}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Labels", KeyType: field.FTString, ValueType: field.FTString, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Labels", KeyType: field.FTString, ValueType: field.FTString}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    tok.Bytes = []byte(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Labels"}) {
                    return
                }
            }
        }
        // Field 1: Ports
        {
            m := x.PortsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ports", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTInt32, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ports", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTInt32}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Ports", KeyType: field.FTString, ValueType: field.FTInt32, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Ports", KeyType: field.FTString, ValueType: field.FTInt32}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    tok.SetInt32(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Ports"}) {
                    return
                }
            }
        }
        // Field 2: Enabled
        {
            m := x.EnabledMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Enabled", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTBool, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Enabled", Type: field.FTMap, KeyType: field.FTString, ValueType: field.FTBool}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Enabled", KeyType: field.FTString, ValueType: field.FTBool, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Enabled", KeyType: field.FTString, ValueType: field.FTBool}
                    // Set the key
                    tok.KeyBytes = []byte(k)
                    // Set the value
                    tok.SetBool(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Enabled"}) {
                    return
                }
            }
        }
        // Field 3: Counts
        {
            m := x.CountsMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Counts", Type: field.FTMap, KeyType: field.FTInt32, ValueType: field.FTInt64, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Counts", Type: field.FTMap, KeyType: field.FTInt32, ValueType: field.FTInt64}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Counts", KeyType: field.FTInt32, ValueType: field.FTInt64, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Counts", KeyType: field.FTInt32, ValueType: field.FTInt64}
                    // Set the key
                    tok.SetKeyInt32(k)
                    // Set the value
                    tok.SetInt64(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Counts"}) {
                    return
                }
            }
        }
        // Field 4: Ratios
        {
            m := x.RatiosMap()
            if m.Len() == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ratios", Type: field.FTMap, KeyType: field.FTFloat64, ValueType: field.FTString, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ratios", Type: field.FTMap, KeyType: field.FTFloat64, ValueType: field.FTString}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapStart, Name: "Ratios", KeyType: field.FTFloat64, ValueType: field.FTString, Len: m.Len()}) {
                    return
                }
                for k, v := range m.All() {
                    tok := clawiter.Token{Kind: clawiter.TokenMapEntry, Name: "Ratios", KeyType: field.FTFloat64, ValueType: field.FTString}
                    // Set the key
                    tok.SetKeyFloat64(k)
                    // Set the value
                    tok.Bytes = []byte(v)
                    if !yield(tok) {
                        return
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenMapEnd, Name: "Ratios"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Config"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Inner) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Inner"}) {
        return
    }
        // Field 0: ID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ID", Type: field.FTInt64}
            tok.SetInt64(x.ID())
            if !yield(tok) {
                return
            }
        }
        // Field 1: Name
        {
            s := x.Name()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Name", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Inner"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Setting) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Setting"}) {
        return
    }
        // Field 0: Name
        {
            s := x.Name()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Name", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Value
        {
            s := x.Value()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Value", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 2: Priority
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Priority", Type: field.FTInt32}
            tok.SetInt32(x.Priority())
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Setting"}) {
        return
    }
}

