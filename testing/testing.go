// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

// Package hello 
package hello

import (
    "github.com/bearlytools/claw/languages/go/mapping"
    "github.com/bearlytools/claw/languages/go/reflect"
    "github.com/bearlytools/claw/languages/go/structs"
    "github.com/bearlytools/claw/languages/go/types/list"
    "github.com/bearlytools/claw/internal/conversions"
    "github.com/bearlytools/claw/languages/go/field"
)

// Forces "list" to be imported, even if nothing is using it.
var _ = list.Bools{}

// SyntaxVersion is the major version of the Claw language that is being rendered.
const SyntaxVersion = 0


type Maker uint8

// String implements fmt.Stringer.
func (x Maker) String() string {
    return MakerByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises 
// like all XXX fields.
func (x Maker) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(0)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises 
// like all XXX fields.
func (x Maker) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(0).ByValue(int(x))
}


const (
    Unknown Maker = 0
    Toyota Maker = 1
    Ford Maker = 2
    Tesla Maker = 3
)

var MakerByName = map[string]Maker{
    "Ford": 2,
    "Tesla": 3,
    "Toyota": 1,
    "Unknown": 0,
}

var MakerByValue = map[uint8 ]string{
    0: "Unknown",
    1: "Toyota",
    2: "Ford",
    3: "Tesla",
} 

type Car struct {
   s *structs.Struct
}

// NewCar creates a new instance of Car.
func NewCar() Car {
    s := structs.New(0, mappingCar)
    return Car{
        s: s,
    }
}

func (x Car) Name() string {
    ptr := structs.MustGetBytes(x.s, 0)
    return conversions.ByteSlice2String(*ptr)
}

func (x Car) SetName(value string) {
    b := conversions.UnsafeGetBytes(value)
    structs.MustSetBytes(x.s, 0, b, true)
}
func (x Car) IsSetName() bool{
    return x.s.IsSet(0)
}  

func (x Car) Maker() Maker {
    return Maker(structs.MustGetNumber[uint8](x.s, 1))
}

func (x Car) SetMaker(value Maker) {
    structs.MustSetNumber(x.s, 1, uint8(value))
}
func (x Car) IsSetMaker() bool{
    return x.s.IsSet(1)
} 


func (x Car) Year() uint16 {
    return structs.MustGetNumber[uint16](x.s, 2)
}

func (x Car) SetYear(value uint16) {
    structs.MustSetNumber(x.s, 2, value)
}
func (x Car) IsSetYear() bool{
    return x.s.IsSet(2)
} 

func (x Car) Serial() uint64 {
    return structs.MustGetNumber[uint64](x.s, 3)
}

func (x Car) SetSerial(value uint64) {
    structs.MustSetNumber(x.s, 3, value)
}
func (x Car) IsSetSerial() bool{
    return x.s.IsSet(3)
} 

func (x Car) Image() []byte {
    ptr := structs.MustGetBytes(x.s, 4)
    return *ptr
}

func (x Car) SafeGetImage() []byte {
    ptr := structs.MustGetBytes(x.s, 4)
    b := make([]byte, len(*ptr))
    copy(b, *ptr)
    return b
}

func (x Car) SetImage(value []byte) {
    structs.MustSetBytes(x.s, 4, value, false)
}
func (x Car) IsSetImage() bool{
    return x.s.IsSet(4)
} 

func (x Car) PreviousVersions() []Car {
    l := structs.MustGetListStruct(x.s, 5)
    vals := make([]Car, l.Len())
    for i, val := range vals {
        val.s = l.Get(i)
        vals[i] = val
    }
    return vals
}

func (x Car) AppendPreviousVersions(values ...Car) {
    vals := make([]*structs.Struct, len(values))
    for i, val := range values {
        vals[i] = val.s
    }
    structs.MustAppendListStruct(x.s, 5, vals...)
}
func (x Car) IsSetPreviousVersions() bool{
    return x.s.IsSet(5)
}  

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
func (x Car) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs()[0]
}

// ClawStruct returns a reflection type representing the Struct.
func (x Car) ClawStruct() reflect.Struct{
   return reflect.XXXNewStruct(x.s)
} 

// Everything below this line is internal details.
var mappingCar = &mapping.Map{
    Name: "Car",
    Pkg: "hello",
    Path: "",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            IsEnum: false,
            FieldNum: 0,
        },
        {
            Name: "Maker",
            Type: field.FTUint8,
            IsEnum: true,
            FieldNum: 1,
        },
        {
            Name: "Year",
            Type: field.FTUint16,
            IsEnum: false,
            FieldNum: 2,
        },
        {
            Name: "Serial",
            Type: field.FTUint64,
            IsEnum: false,
            FieldNum: 3,
        },
        {
            Name: "Image",
            Type: field.FTBytes,
            IsEnum: false,
            FieldNum: 4,
        },
        {
            Name: "PreviousVersions",
            Type: field.FTListStructs,
            IsEnum: false,
            FieldNum: 5,
            SelfReferential: true,
        },
    },
}

var XXXEnumGroups reflect.EnumGroups = reflect.XXXEnumGroupsImpl{
    List:   []reflect.EnumGroup{
        reflect.XXXEnumGroupImpl{
            GroupName: "Maker",
            GroupLen: 4,
            EnumSize: 8,
            Descrs: []reflect.EnumValueDescr{
                reflect.XXXEnumValueDescrImpl{
                    EnumName: "Unknown",
                    EnumNumber: 0,
                },
                reflect.XXXEnumValueDescrImpl{
                    EnumName: "Toyota",
                    EnumNumber: 1,
                },
                reflect.XXXEnumValueDescrImpl{
                    EnumName: "Ford",
                    EnumNumber: 2,
                },
                reflect.XXXEnumValueDescrImpl{
                    EnumName: "Tesla",
                    EnumNumber: 3,
                },
            },
        },  
    },
    Lookup: map[string]reflect.EnumGroup{},
}

func init() {
    x := XXXEnumGroups.(reflect.XXXEnumGroupsImpl)
    for _, g := range x.List {
        x.Lookup[g.Name()] = g
    }
}  

var XXXPackageDescr reflect.PackageDescr = reflect.XXXPackageDescrImpl{
    Name: "hello",
    Path: "", 
    EnumGroupsDescrs: XXXEnumGroups, 
    StructsDescrs: []reflect.StructDescr{
        reflect.XXXStructDescrImpl{
            Name: "Car",
            Pkg: "hello",
            Path: "",
            FieldList: []reflect.FieldDescr{
                reflect.XXXFieldDescrImpl{
                    FD: mappingCar.ByName("Name"),
                },
                reflect.XXXFieldDescrImpl{
                    FD: mappingCar.ByName("Maker"),
                    EG: XXXEnumGroups.ByName("Maker"),
                },
                reflect.XXXFieldDescrImpl{
                    FD: mappingCar.ByName("Year"),
                },
                reflect.XXXFieldDescrImpl{
                    FD: mappingCar.ByName("Serial"),
                },
                reflect.XXXFieldDescrImpl{
                    FD: mappingCar.ByName("Image"),
                },
                reflect.XXXFieldDescrImpl{
                    FD: mappingCar.ByName("PreviousVersions"),
                },
            },
        },  
    },  
}