// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

// Package vehicles
package vehicles

import (
    "context"
    "io"
    "bytes"
    "fmt"

    "github.com/bearlytools/claw/clawc/languages/go/mapping"
    "github.com/bearlytools/claw/languages/go/reflect"
    "github.com/bearlytools/claw/languages/go/reflect/runtime"
    "github.com/bearlytools/claw/clawc/languages/go/segment"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
    "github.com/bearlytools/claw/claw_vendor/github.com/bearlytools/test_claw_imports/cars/claw"
    "github.com/bearlytools/claw/claw_vendor/github.com/bearlytools/test_claw_imports/trucks"
    "github.com/bearlytools/claw/testing/imports/vehicles/claw/manufacturers"
)

// Ensure imports are used.
var (
    _ context.Context
    _ = io.EOF
    _ = bytes.MinRead
    _ = fmt.Errorf
    _ mapping.Map
    _ reflect.StructDescr
    _ = runtime.RegisterPackage
    _ segment.Struct
    _ = field.FTBool
)

// SyntaxVersion is the major version of the Claw language that is being rendered.
const SyntaxVersion = 0

var _package = "vehicles"
var _packagePath = "github.com/bearlytools/claw/testing/imports/vehicles/claw"


// Type is the Type of Vehicle.
type Type uint8

// String implements fmt.Stringer.
func (x Type) String() string {
    return TypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x Type) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(0)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x Type) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(0).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum Type.
const (
    Unknown Type = 0
    Car Type = 1
    Truck Type = 2
)

// TypeByName converts a string representing the enumerator into a Type.
var TypeByName = map[string]Type{
    "Car": 1,
    "Truck": 2,
    "Unknown": 0,
}

// TypeByValue converts a uint8 representing a Type into its string name.
var TypeByValue = map[uint8]string{
    0: "Unknown",
    1: "Car",
    2: "Truck",
}


// Vehicle describes a vehicle.
type Vehicle struct {
   s *segment.Struct
}

// NewVehicle creates a new pooled instance of Vehicle.
// Call Release() when done to return it to the pool for reuse.
func NewVehicle(ctx context.Context) Vehicle {
    s := segment.NewPooled(ctx, XXXMappingVehicle)
    return Vehicle{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Vehicle) Release(ctx context.Context) {
    segment.Release(ctx, x.s)
}

// XXXNewVehicleFrom creates a new Vehicle from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewVehicleFrom(s *segment.Struct) Vehicle {
    return Vehicle{s: s}
}

// Marshal marshal's the Struct to []byte.
func (x Vehicle) Marshal() ([]byte, error) {
    return x.s.MarshalBytes()
}

// MarshalWriter marshals to an io.Writer.
func (x Vehicle) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.Marshal(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Vehicle) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Vehicle) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Vehicle) Type() Type {
    return Type(segment.GetUint8(x.s, 0))
}

func (x Vehicle) SetType(value Type) Vehicle {
    segment.SetUint8(x.s, 0, uint8(value))
    return x
}

func (x Vehicle) Car() cars.Car {
    s := segment.GetNestedStruct(x.s, 1, cars.XXXMappingCar)
    return cars.XXXNewCarFrom(s)
}

func (x Vehicle) SetCar(value cars.Car) Vehicle {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}

// TruckList returns the underlying Structs list for iteration.
// Use NewTruck() to create items and Append to add them.
func (x Vehicle) TruckList() *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(x.s, 2, trucks.XXXMappingTruck); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(x.s, 2, trucks.XXXMappingTruck)
    return structs
}

// TruckLen returns the number of items in the list.
func (x Vehicle) TruckLen() int {
    return x.TruckList().Len()
}

// TruckGet returns the item at the given index.
func (x Vehicle) TruckGet(index int) trucks.Truck {
    s := x.TruckList().Get(index)
    return trucks.XXXNewTruckFrom(s)
}

// TruckAppend appends items to the list.
func (x Vehicle) TruckAppend(values ...trucks.Truck) {
    list := x.TruckList()
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// AppendTruck is an alias for TruckAppend for backwards compatibility.
func (x Vehicle) AppendTruck(values ...trucks.Truck) {
    x.TruckAppend(values...)
}

// TruckAppendRaw appends items to the list using Raw struct representations.
func (x Vehicle) TruckAppendRaw(ctx context.Context, values ...*trucks.TruckRaw) {
    list := x.TruckList()
    for _, raw := range values {
        if raw != nil {
            list.Append(trucks.NewTruckFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}

// Enum list - returns a number list that can be cast to the enum type
func (x Vehicle) Types() *segment.Numbers[Type] {
    // Try to get cached or parse from segment
    if nums := segment.GetListNumbers[Type](x.s, 3); nums != nil {
        return nums
    }
    // Create new empty list if no data exists
    nums := segment.NewNumbers[Type](x.s, 3)
    return nums
}

// SetTypes replaces all values in the numeric list.
func (x Vehicle) SetTypes(v ...Type) Vehicle {
    nums := x.Types()
    nums.SetAll(v)
    return x
}

func (x Vehicle) Bools() *segment.Bools {
    // Try to get cached or parse from segment
    if bools := segment.GetListBools(x.s, 4); bools != nil {
        return bools
    }
    // Create new empty list if no data exists
    bools := segment.NewBools(x.s, 4)
    return bools
}

// SetBools replaces all values in the bool list.
func (x Vehicle) SetBools(v ...bool) Vehicle {
    bools := x.Bools()
    bools.SetAll(v)
    return x
}



// ClawStruct returns a reflection type representing the Struct.
func (x Vehicle) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Vehicle) XXXGetStruct() *segment.Struct {
    return x.s
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Vehicle) SetRecording(enabled bool) Vehicle {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Vehicle) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Vehicle) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Vehicle) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// VehicleRaw is a plain Go struct representation of Vehicle.
// Zero values are not set (sparse encoding).
type VehicleRaw struct {
    Type Type
    Car *cars.CarRaw
    Truck []*trucks.TruckRaw
    Types []Type
    Bools []bool
}

// NewVehicleFromRaw creates a new Vehicle from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewVehicleFromRaw(ctx context.Context, raw VehicleRaw) Vehicle {
    x := NewVehicle(ctx)
    if raw.Type != 0 {
        x.SetType(raw.Type)
    }
    if raw.Car != nil {
        x.SetCar(cars.NewCarFromRaw(ctx, *raw.Car))
    }
    if raw.Truck != nil {
        list := x.TruckList()
        items := make([]*segment.Struct, 0, len(raw.Truck))
        for _, r := range raw.Truck {
            if r != nil {
                items = append(items, trucks.NewTruckFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Types != nil {
        x.SetTypes(raw.Types...)
    }
    if raw.Bools != nil {
        x.SetBools(raw.Bools...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Vehicle) ToRaw() VehicleRaw {
    raw := VehicleRaw{}
    raw.Type = x.Type()
    if x.s.HasField(1) {
        nestedRaw := x.Car().ToRaw()
        raw.Car = &nestedRaw
    }
    if l := x.s.GetList(2); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Truck = make([]*trucks.TruckRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := trucks.XXXNewTruckFrom(list.Get(i))
            itemRaw := item.ToRaw()
            raw.Truck[i] = &itemRaw
        }
    } else if x.s.HasField(2) {
        list := x.TruckList()
        raw.Truck = make([]*trucks.TruckRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := trucks.XXXNewTruckFrom(list.Get(i))
            itemRaw := item.ToRaw()
            raw.Truck[i] = &itemRaw
        }
    }
    if l := x.s.GetList(3); l != nil && l.(*segment.Numbers[Type]).Len() > 0 {
        raw.Types = l.(*segment.Numbers[Type]).Slice()
    } else if x.s.HasField(3) {
        raw.Types = x.Types().Slice()
    }
    if l := x.s.GetList(4); l != nil && l.(*segment.Bools).Len() > 0 {
        raw.Bools = l.(*segment.Bools).Slice()
    } else if x.s.HasField(4) {
        raw.Bools = x.Bools().Slice()
    }
    return raw
}

 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Vehicle) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(0)
} 

// Everything below this line is internal details.
// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingVehicle = &mapping.Map{
    Name: "Vehicle",
    Pkg: "vehicles",
    Path: "github.com/bearlytools/claw/testing/imports/vehicles/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Type",
            Type: field.FTUint8,
            Package: "vehicles",
            FullPath: "github.com/bearlytools/claw/testing/imports/vehicles/claw",
            FieldNum: 0,
            IsEnum: true,
            EnumGroup: "Type",
        },
        {
            Name: "Car",
            Type: field.FTStruct,
            Package: "cars",
            FullPath: "github.com/bearlytools/test_claw_imports/cars/claw",
            FieldNum: 1,
            IsEnum: false,
            StructName: "cars.Car",
            
            Mapping: cars.XXXMappingCar,
        },
        {
            Name: "Truck",
            Type: field.FTListStructs,
            Package: "trucks",
            FullPath: "github.com/bearlytools/test_claw_imports/trucks",
            FieldNum: 2,
            IsEnum: false,
            StructName: "trucks.Truck",
            
            Mapping: trucks.XXXMappingTruck,
        },
        {
            Name: "Types",
            Type: field.FTListUint8,
            Package: "vehicles",
            FullPath: "github.com/bearlytools/claw/testing/imports/vehicles/claw",
            FieldNum: 3,
            IsEnum: true,
            EnumGroup: "Type",
        },
        {
            Name: "Bools",
            Type: field.FTListBools,
            Package: "vehicles",
            FullPath: "github.com/bearlytools/claw/testing/imports/vehicles/claw",
            FieldNum: 4,
            IsEnum: false,
        },
    },
}


// init initializes all mapping function pointer tables for O(1) dispatch.
func init() {
    XXXMappingVehicle.Init()
}




var XXXEnumGroupType = reflect.XXXEnumGroupImpl{
    GroupName: "Type",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "Unknown",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "Car",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "Truck",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXEnumGroups reflect.EnumGroups = reflect.XXXEnumGroupsImpl{
    List:   []reflect.EnumGroup{
        XXXEnumGroupType,
    },
    Lookup: map[string]reflect.EnumGroup{
        "Type": XXXEnumGroupType,
    },
}
 


var XXXStructDescrVehicle = &reflect.XXXStructDescrImpl{
    Name:      "Vehicle",
    Pkg:       XXXMappingVehicle.Pkg,
    Path:      XXXMappingVehicle.Path,
    Mapping:   XXXMappingVehicle,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVehicle.Fields[0],
            EG: XXXEnumGroupType, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD: XXXMappingVehicle.Fields[1],
            SD: cars.XXXStructDescrCar,
        },
         
        
        reflect.XXXFieldDescrImpl{
            FD: XXXMappingVehicle.Fields[2],
            SD: trucks.XXXStructDescrTruck,
        },
         
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVehicle.Fields[3],
            EG: XXXEnumGroupType, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVehicle.Fields[4],  
        },  
    },
}

var XXXStructDescrs = map[string]*reflect.XXXStructDescrImpl{
    "Vehicle":  XXXStructDescrVehicle,
}

// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
var XXXPackageDescr reflect.PackageDescr = &reflect.XXXPackageDescrImpl{
    Name: "vehicles",
    Path: "github.com/bearlytools/claw/testing/imports/vehicles/claw",
    ImportDescrs: []reflect.PackageDescr {
        cars.XXXPackageDescr,
        manufacturers.XXXPackageDescr,
        trucks.XXXPackageDescr,
    },
    EnumGroupsDescrs: XXXEnumGroups,
    StructsDescrs: reflect.XXXStructDescrsImpl{
        Descrs: []reflect.StructDescr{
            XXXStructDescrVehicle,
        },
    },
}

// PackageDescr returns a PackageDescr for this package.
func PackageDescr() reflect.PackageDescr {
    return XXXPackageDescr
}

// Registers our package description with the runtime.
func init() {
    runtime.RegisterPackage(XXXPackageDescr)
}
