// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

package any

import (
    "context"
    "math"

    "github.com/bearlytools/claw/clawc/languages/go/clawiter"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
)

// Ensure imports are used.
var _ = math.Float32bits
var _ context.Context


// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Container) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Container"}) {
        return
    }
        // Field 0: Name
        {
            s := x.Name()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Name", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Data
        {
            data, typeHash, ok := x.DataRaw()
            if !ok {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Data", Type: field.FTAny, IsNil: true}) {
                    return
                }
            } else {
                tok := clawiter.Token{
                    Kind: clawiter.TokenField,
                    Name: "Data",
                    Type: field.FTAny,
                    Bytes: data,
                    TypeHash: typeHash[:],
                }
                if !yield(tok) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Container"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Inner) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Inner"}) {
        return
    }
        // Field 0: ID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ID", Type: field.FTInt64}
            tok.SetInt64(x.ID())
            if !yield(tok) {
                return
            }
        }
        // Field 1: Value
        {
            s := x.Value()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Value", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Inner"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x ListContainer) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "ListContainer"}) {
        return
    }
        // Field 0: Name
        {
            s := x.Name()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Name", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Items
        {
            listLen := x.ItemsLen()
            if listLen == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Items", Type: field.FTListAny, IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Items", Type: field.FTListAny}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "Items", Type: field.FTListAny, Len: listLen}) {
                    return
                }
                for i := 0; i < listLen; i++ {
                    data, typeHash, ok := x.ItemsGetRaw(i)
                    if ok {
                        tok := clawiter.Token{
                            Kind: clawiter.TokenField,
                            Name: "",
                            Type: field.FTAny,
                            Bytes: data,
                            TypeHash: typeHash[:],
                        }
                        if !yield(tok) {
                            return
                        }
                    }
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: "Items"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "ListContainer"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Outer) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Outer"}) {
        return
    }
        // Field 0: Label
        {
            s := x.Label()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Label", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Count
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Count", Type: field.FTInt32}
            tok.SetInt32(x.Count())
            if !yield(tok) {
                return
            }
        }
        // Field 2: Nested
        {
            nested := x.Nested()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Nested", Type: field.FTStruct, StructName: "Inner", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Outer"}) {
        return
    }
}

