// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

package reflection

import (
    "context"
    "math"

    "github.com/bearlytools/claw/clawc/languages/go/clawiter"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
    "github.com/bearlytools/claw/rpc/internal/msgs"
)

// Ensure imports are used.
var _ = math.Float32bits
var _ context.Context


// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x GetMethodInfoRequest) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "GetMethodInfoRequest"}) {
        return
    }
        // Field 0: Package
        {
            s := x.Package()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Package", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Service
        {
            s := x.Service()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Service", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 2: Method
        {
            s := x.Method()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Method", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "GetMethodInfoRequest"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x GetMethodInfoResponse) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "GetMethodInfoResponse"}) {
        return
    }
        // Field 0: Method
        {
            nested := x.Method()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Method", Type: field.FTStruct, StructName: "MethodInfo", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 1: Found
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Found", Type: field.FTBool}
            tok.SetBool(x.Found())
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "GetMethodInfoResponse"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x GetServiceInfoRequest) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "GetServiceInfoRequest"}) {
        return
    }
        // Field 0: Package
        {
            s := x.Package()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Package", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Service
        {
            s := x.Service()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Service", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "GetServiceInfoRequest"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x GetServiceInfoResponse) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "GetServiceInfoResponse"}) {
        return
    }
        // Field 0: Service
        {
            nested := x.Service()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Service", Type: field.FTStruct, StructName: "ServiceInfo", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 1: Found
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Found", Type: field.FTBool}
            tok.SetBool(x.Found())
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "GetServiceInfoResponse"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x ListServicesRequest) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "ListServicesRequest"}) {
        return
    }
        // Field 0: Reserved
        {
            v := x.Reserved()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Reserved", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "ListServicesRequest"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x ListServicesResponse) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "ListServicesResponse"}) {
        return
    }
        // Field 0: Packages
        {
            list := x.PackagesList(ctx)
            listLen := list.Len()
            if listLen == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Packages", Type: field.FTListStructs, StructName: "PackageInfo", IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Packages", Type: field.FTListStructs, StructName: "PackageInfo"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "Packages", Type: field.FTListStructs, Len: listLen}) {
                    return
                }
                for i := 0; i < listLen; i++ {
                    item := x.PackagesGet(ctx, i)
                    item.Walk(ctx, yield, opts...)
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: "Packages"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "ListServicesResponse"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x MethodInfo) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "MethodInfo"}) {
        return
    }
        // Field 0: Name
        {
            s := x.Name()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Name", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Type
        {
            v := x.Type()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Type", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            tok.IsEnum = true
            tok.EnumGroup = "RPCType"
            tok.EnumName = msgs.RPCTypeByValue[uint8(v)]
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "MethodInfo"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x PackageInfo) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "PackageInfo"}) {
        return
    }
        // Field 0: Name
        {
            s := x.Name()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Name", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Services
        {
            list := x.ServicesList(ctx)
            listLen := list.Len()
            if listLen == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Services", Type: field.FTListStructs, StructName: "ServiceInfo", IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Services", Type: field.FTListStructs, StructName: "ServiceInfo"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "Services", Type: field.FTListStructs, Len: listLen}) {
                    return
                }
                for i := 0; i < listLen; i++ {
                    item := x.ServicesGet(ctx, i)
                    item.Walk(ctx, yield, opts...)
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: "Services"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "PackageInfo"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x ServiceInfo) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "ServiceInfo"}) {
        return
    }
        // Field 0: Name
        {
            s := x.Name()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Name", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Methods
        {
            list := x.MethodsList(ctx)
            listLen := list.Len()
            if listLen == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Methods", Type: field.FTListStructs, StructName: "MethodInfo", IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Methods", Type: field.FTListStructs, StructName: "MethodInfo"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "Methods", Type: field.FTListStructs, Len: listLen}) {
                    return
                }
                for i := 0; i < listLen; i++ {
                    item := x.MethodsGet(ctx, i)
                    item.Walk(ctx, yield, opts...)
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: "Methods"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "ServiceInfo"}) {
        return
    }
}

