// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

package reflection

import (
    "context"
    "fmt"

    "github.com/bearlytools/claw/clawc/languages/go/clawiter"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    "github.com/bearlytools/claw/clawc/languages/go/segment"
    "github.com/bearlytools/claw/rpc/internal/msgs"
)

// Ensure imports are used.
var _ context.Context
var _ = fmt.Errorf
var _ = field.FTBool
var _ segment.AnyRawItem


// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *GetMethodInfoRequest) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *GetMethodInfoRequest) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in GetMethodInfoRequest")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Package":
            x.SetPackage(tok.String())
        case "Service":
            x.SetService(tok.String())
        case "Method":
            x.SetMethod(tok.String())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *GetMethodInfoResponse) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *GetMethodInfoResponse) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in GetMethodInfoResponse")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Method":
            if tok.IsNil {
                continue
            }
            nested := NewMethodInfo(ctx)
            if err := nested.XXXIngestFrom(ctx, ts, opts); err != nil {
                return fmt.Errorf("ingesting Method: %w", err)
            }
            x.SetMethod(nested)
        case "Found":
            x.SetFound(tok.Bool())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *GetServiceInfoRequest) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *GetServiceInfoRequest) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in GetServiceInfoRequest")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Package":
            x.SetPackage(tok.String())
        case "Service":
            x.SetService(tok.String())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *GetServiceInfoResponse) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *GetServiceInfoResponse) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in GetServiceInfoResponse")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Service":
            if tok.IsNil {
                continue
            }
            nested := NewServiceInfo(ctx)
            if err := nested.XXXIngestFrom(ctx, ts, opts); err != nil {
                return fmt.Errorf("ingesting Service: %w", err)
            }
            x.SetService(nested)
        case "Found":
            x.SetFound(tok.Bool())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *ListServicesRequest) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *ListServicesRequest) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in ListServicesRequest")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Reserved":
            x.SetReserved(tok.Uint8())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *ListServicesResponse) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *ListServicesResponse) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in ListServicesResponse")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Packages":
            if tok.IsNil {
                continue
            }
            listTok, ok := ts.Next()
            if !ok || listTok.Kind != clawiter.TokenListStart {
                return fmt.Errorf("expected TokenListStart for Packages")
            }
            for {
                peekTok, ok := ts.Peek()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Packages list")
                }
                if peekTok.Kind == clawiter.TokenListEnd {
                    ts.Next() // consume the ListEnd
                    break
                }
                item := NewPackageInfo(ctx)
                if err := item.XXXIngestFrom(ctx, ts, opts); err != nil {
                    return fmt.Errorf("ingesting Packages[]: %w", err)
                }
                x.PackagesAppend(ctx, item)
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *MethodInfo) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *MethodInfo) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in MethodInfo")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Name":
            x.SetName(tok.String())
        case "Type":
            if len(tok.Bytes) > 0 {
                x.SetType(msgs.RPCTypeByName[tok.String()])
            } else {
                x.SetType(msgs.RPCType(tok.Uint8()))
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *PackageInfo) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *PackageInfo) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in PackageInfo")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Name":
            x.SetName(tok.String())
        case "Services":
            if tok.IsNil {
                continue
            }
            listTok, ok := ts.Next()
            if !ok || listTok.Kind != clawiter.TokenListStart {
                return fmt.Errorf("expected TokenListStart for Services")
            }
            for {
                peekTok, ok := ts.Peek()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Services list")
                }
                if peekTok.Kind == clawiter.TokenListEnd {
                    ts.Next() // consume the ListEnd
                    break
                }
                item := NewServiceInfo(ctx)
                if err := item.XXXIngestFrom(ctx, ts, opts); err != nil {
                    return fmt.Errorf("ingesting Services[]: %w", err)
                }
                x.ServicesAppend(ctx, item)
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// Ingest populates the struct from a Walker with options.
// This is the inverse of Walk().
func (x *ServiceInfo) Ingest(ctx context.Context, walk clawiter.Walker, opts ...clawiter.IngestOption) error {
    // Apply options
    var o clawiter.IngestOptions
    for _, opt := range opts {
        var err error
        o, err = opt(o)
        if err != nil {
            return err
        }
    }

    // Convert Walker to iter.Seq for TokenStream
    seq := func(yield func(clawiter.Token) bool) {
        walk(yield)
    }
    ts := clawiter.NewTokenStream(seq)
    defer ts.Close()
    return x.XXXIngestFrom(ctx, ts, o)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *ServiceInfo) XXXIngestFrom(ctx context.Context, ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in ServiceInfo")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Name":
            x.SetName(tok.String())
        case "Methods":
            if tok.IsNil {
                continue
            }
            listTok, ok := ts.Next()
            if !ok || listTok.Kind != clawiter.TokenListStart {
                return fmt.Errorf("expected TokenListStart for Methods")
            }
            for {
                peekTok, ok := ts.Peek()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Methods list")
                }
                if peekTok.Kind == clawiter.TokenListEnd {
                    ts.Next() // consume the ListEnd
                    break
                }
                item := NewMethodInfo(ctx)
                if err := item.XXXIngestFrom(ctx, ts, opts); err != nil {
                    return fmt.Errorf("ingesting Methods[]: %w", err)
                }
                x.MethodsAppend(ctx, item)
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

