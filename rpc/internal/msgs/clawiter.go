// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

package msgs

import (
    "context"
    "math"

    "github.com/bearlytools/claw/clawc/languages/go/clawiter"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
)

// Ensure imports are used.
var _ = math.Float32bits
var _ context.Context


// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Cancel) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Cancel"}) {
        return
    }
        // Field 0: SessionID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "SessionID", Type: field.FTUint32}
            tok.SetUint32(x.SessionID())
            if !yield(tok) {
                return
            }
        }
        // Field 1: ReqID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ReqID", Type: field.FTUint32}
            tok.SetUint32(x.ReqID())
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Cancel"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Close) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Close"}) {
        return
    }
        // Field 0: SessionID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "SessionID", Type: field.FTUint32}
            tok.SetUint32(x.SessionID())
            if !yield(tok) {
                return
            }
        }
        // Field 1: ErrCode
        {
            v := x.ErrCode()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ErrCode", Type: field.FTUint16}
            tok.SetUint16(uint16(v))
            tok.IsEnum = true
            tok.EnumGroup = "ErrCode"
            tok.EnumName = ErrCodeByValue[uint16(v)]
            if !yield(tok) {
                return
            }
        }
        // Field 2: Error
        {
            s := x.Error()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Error", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 3: Metadata
        {
            list := x.MetadataList(ctx)
            listLen := list.Len()
            if listLen == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Metadata", Type: field.FTListStructs, StructName: "Metadata", IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Metadata", Type: field.FTListStructs, StructName: "Metadata"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "Metadata", Type: field.FTListStructs, Len: listLen}) {
                    return
                }
                for i := 0; i < listLen; i++ {
                    item := x.MetadataGet(ctx, i)
                    item.Walk(ctx, yield, opts...)
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: "Metadata"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Close"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Descr) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Descr"}) {
        return
    }
        // Field 0: Package
        {
            s := x.Package()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Package", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Service
        {
            s := x.Service()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Service", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 2: Call
        {
            s := x.Call()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Call", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 3: Type
        {
            v := x.Type()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Type", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            tok.IsEnum = true
            tok.EnumGroup = "RPCType"
            tok.EnumName = RPCTypeByValue[uint8(v)]
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Descr"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x GoAway) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "GoAway"}) {
        return
    }
        // Field 0: LastSessionID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "LastSessionID", Type: field.FTUint32}
            tok.SetUint32(x.LastSessionID())
            if !yield(tok) {
                return
            }
        }
        // Field 1: ErrCode
        {
            v := x.ErrCode()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ErrCode", Type: field.FTUint16}
            tok.SetUint16(uint16(v))
            tok.IsEnum = true
            tok.EnumGroup = "ErrCode"
            tok.EnumName = ErrCodeByValue[uint16(v)]
            if !yield(tok) {
                return
            }
        }
        // Field 2: DebugData
        {
            s := x.DebugData()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "DebugData", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "GoAway"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Metadata) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Metadata"}) {
        return
    }
        // Field 0: Key
        {
            s := x.Key()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Key", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 1: Value
        if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Value", Type: field.FTBytes, Bytes: x.Value()}) {
            return
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Metadata"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Msg) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Msg"}) {
        return
    }
        // Field 0: Type
        {
            v := x.Type()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Type", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            tok.IsEnum = true
            tok.EnumGroup = "MsgType"
            tok.EnumName = MsgTypeByValue[uint8(v)]
            if !yield(tok) {
                return
            }
        }
        // Field 1: Open
        {
            nested := x.Open()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Open", Type: field.FTStruct, StructName: "Open", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 2: OpenAck
        {
            nested := x.OpenAck()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "OpenAck", Type: field.FTStruct, StructName: "OpenAck", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 3: Close
        {
            nested := x.Close()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Close", Type: field.FTStruct, StructName: "Close", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 4: Payload
        {
            nested := x.Payload()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Payload", Type: field.FTStruct, StructName: "Payload", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 5: Cancel
        {
            nested := x.Cancel()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Cancel", Type: field.FTStruct, StructName: "Cancel", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 6: Ping
        {
            nested := x.Ping()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Ping", Type: field.FTStruct, StructName: "Ping", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 7: Pong
        {
            nested := x.Pong()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Pong", Type: field.FTStruct, StructName: "Pong", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 8: GoAway
        {
            nested := x.GoAway()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "GoAway", Type: field.FTStruct, StructName: "GoAway", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Msg"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Open) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Open"}) {
        return
    }
        // Field 0: OpenID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "OpenID", Type: field.FTUint32}
            tok.SetUint32(x.OpenID())
            if !yield(tok) {
                return
            }
        }
        // Field 1: Descr
        {
            nested := x.Descr()
            isNil := nested.XXXGetStruct() == nil
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Descr", Type: field.FTStruct, StructName: "Descr", IsNil: isNil}) {
                return
            }
            if !isNil {
                nested.Walk(ctx, yield, opts...)
            }
        }
        // Field 2: ProtocolMajor
        {
            v := x.ProtocolMajor()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ProtocolMajor", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            if !yield(tok) {
                return
            }
        }
        // Field 3: ProtocolMinor
        {
            v := x.ProtocolMinor()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ProtocolMinor", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            if !yield(tok) {
                return
            }
        }
        // Field 4: DeadlineMS
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "DeadlineMS", Type: field.FTUint64}
            tok.SetUint64(x.DeadlineMS())
            if !yield(tok) {
                return
            }
        }
        // Field 5: MaxPayloadSize
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "MaxPayloadSize", Type: field.FTUint32}
            tok.SetUint32(x.MaxPayloadSize())
            if !yield(tok) {
                return
            }
        }
        // Field 6: TraceID
        if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "TraceID", Type: field.FTBytes, Bytes: x.TraceID()}) {
            return
        }
        // Field 7: SpanID
        if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "SpanID", Type: field.FTBytes, Bytes: x.SpanID()}) {
            return
        }
        // Field 8: Metadata
        {
            list := x.MetadataList(ctx)
            listLen := list.Len()
            if listLen == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Metadata", Type: field.FTListStructs, StructName: "Metadata", IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Metadata", Type: field.FTListStructs, StructName: "Metadata"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "Metadata", Type: field.FTListStructs, Len: listLen}) {
                    return
                }
                for i := 0; i < listLen; i++ {
                    item := x.MetadataGet(ctx, i)
                    item.Walk(ctx, yield, opts...)
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: "Metadata"}) {
                    return
                }
            }
        }
        // Field 9: Packing
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Packing", Type: field.FTBool}
            tok.SetBool(x.Packing())
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Open"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x OpenAck) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "OpenAck"}) {
        return
    }
        // Field 0: OpenID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "OpenID", Type: field.FTUint32}
            tok.SetUint32(x.OpenID())
            if !yield(tok) {
                return
            }
        }
        // Field 1: SessionID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "SessionID", Type: field.FTUint32}
            tok.SetUint32(x.SessionID())
            if !yield(tok) {
                return
            }
        }
        // Field 2: ProtocolMajor
        {
            v := x.ProtocolMajor()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ProtocolMajor", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            if !yield(tok) {
                return
            }
        }
        // Field 3: ProtocolMinor
        {
            v := x.ProtocolMinor()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ProtocolMinor", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            if !yield(tok) {
                return
            }
        }
        // Field 4: MaxPayloadSize
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "MaxPayloadSize", Type: field.FTUint32}
            tok.SetUint32(x.MaxPayloadSize())
            if !yield(tok) {
                return
            }
        }
        // Field 5: ErrCode
        {
            v := x.ErrCode()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ErrCode", Type: field.FTUint16}
            tok.SetUint16(uint16(v))
            tok.IsEnum = true
            tok.EnumGroup = "ErrCode"
            tok.EnumName = ErrCodeByValue[uint16(v)]
            if !yield(tok) {
                return
            }
        }
        // Field 6: Error
        {
            s := x.Error()
            if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Error", Type: field.FTString, Bytes: []byte(s)}) {
                return
            }
        }
        // Field 7: Metadata
        {
            list := x.MetadataList(ctx)
            listLen := list.Len()
            if listLen == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Metadata", Type: field.FTListStructs, StructName: "Metadata", IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Metadata", Type: field.FTListStructs, StructName: "Metadata"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "Metadata", Type: field.FTListStructs, Len: listLen}) {
                    return
                }
                for i := 0; i < listLen; i++ {
                    item := x.MetadataGet(ctx, i)
                    item.Walk(ctx, yield, opts...)
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: "Metadata"}) {
                    return
                }
            }
        }
        // Field 8: Packing
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Packing", Type: field.FTBool}
            tok.SetBool(x.Packing())
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "OpenAck"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Payload) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Payload"}) {
        return
    }
        // Field 0: SessionID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "SessionID", Type: field.FTUint32}
            tok.SetUint32(x.SessionID())
            if !yield(tok) {
                return
            }
        }
        // Field 1: ReqID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ReqID", Type: field.FTUint32}
            tok.SetUint32(x.ReqID())
            if !yield(tok) {
                return
            }
        }
        // Field 2: Payload
        if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Payload", Type: field.FTBytes, Bytes: x.Payload()}) {
            return
        }
        // Field 3: EndStream
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "EndStream", Type: field.FTBool}
            tok.SetBool(x.EndStream())
            if !yield(tok) {
                return
            }
        }
        // Field 4: Compression
        {
            v := x.Compression()
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "Compression", Type: field.FTUint8}
            tok.SetUint8(uint8(v))
            tok.IsEnum = true
            tok.EnumGroup = "Compression"
            tok.EnumName = CompressionByValue[uint8(v)]
            if !yield(tok) {
                return
            }
        }
        // Field 5: Metadata
        {
            list := x.MetadataList(ctx)
            listLen := list.Len()
            if listLen == 0 {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Metadata", Type: field.FTListStructs, StructName: "Metadata", IsNil: true}) {
                    return
                }
            } else {
                if !yield(clawiter.Token{Kind: clawiter.TokenField, Name: "Metadata", Type: field.FTListStructs, StructName: "Metadata"}) {
                    return
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListStart, Name: "Metadata", Type: field.FTListStructs, Len: listLen}) {
                    return
                }
                for i := 0; i < listLen; i++ {
                    item := x.MetadataGet(ctx, i)
                    item.Walk(ctx, yield, opts...)
                }
                if !yield(clawiter.Token{Kind: clawiter.TokenListEnd, Name: "Metadata"}) {
                    return
                }
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Payload"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Ping) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Ping"}) {
        return
    }
        // Field 0: ID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ID", Type: field.FTUint32}
            tok.SetUint32(x.ID())
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Ping"}) {
        return
    }
}

// Walk calls yield for each token during serialization. If yield returns false, Walk stops and returns.
// This walks all fields including nested structs and lists.
func (x Pong) Walk(ctx context.Context, yield clawiter.YieldToken, opts ...clawiter.WalkOption) {
    if !yield(clawiter.Token{Kind: clawiter.TokenStructStart, Name: "Pong"}) {
        return
    }
        // Field 0: ID
        {
            tok := clawiter.Token{Kind: clawiter.TokenField, Name: "ID", Type: field.FTUint32}
            tok.SetUint32(x.ID())
            if !yield(tok) {
                return
            }
        }

    if !yield(clawiter.Token{Kind: clawiter.TokenStructEnd, Name: "Pong"}) {
        return
    }
}

