// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

package msgs

import (
    "fmt"
    "iter"

    "github.com/bearlytools/claw/clawc/languages/go/clawiter"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    "github.com/bearlytools/claw/clawc/languages/go/types/list"
)

// Ensure imports are used.
var _ = fmt.Errorf
var _ = field.FTBool
var _ list.Bools


// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Descr) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Descr) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Descr")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Package":
            x.SetPackage(tok.String())
        case "Service":
            x.SetService(tok.String())
        case "Call":
            x.SetCall(tok.String())
        case "Type":
            if len(tok.Bytes) > 0 {
                x.SetType(RPCTypeByName[tok.String()])
            } else {
                x.SetType(RPCType(tok.Uint8()))
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Metadata) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Metadata) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Metadata")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Key":
            x.SetKey(tok.String())
        case "Value":
            x.SetValue(tok.Bytes)
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Open) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Open) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Open")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "OpenID":
            x.SetOpenID(tok.Uint32())
        case "Descr":
            if tok.IsNil {
                continue
            }
            nested := NewDescr()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting Descr: %w", err)
            }
            x.SetDescr(nested)
        case "ProtocolMajor":
            x.SetProtocolMajor(tok.Uint8())
        case "ProtocolMinor":
            x.SetProtocolMinor(tok.Uint8())
        case "DeadlineMS":
            x.SetDeadlineMS(tok.Uint64())
        case "MaxPayloadSize":
            x.SetMaxPayloadSize(tok.Uint32())
        case "TraceID":
            x.SetTraceID(tok.Bytes)
        case "SpanID":
            x.SetSpanID(tok.Bytes)
        case "Metadata":
            if tok.IsNil {
                continue
            }
            listTok, ok := ts.Next()
            if !ok || listTok.Kind != clawiter.TokenListStart {
                return fmt.Errorf("expected TokenListStart for Metadata")
            }
            for {
                peekTok, ok := ts.Peek()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Metadata list")
                }
                if peekTok.Kind == clawiter.TokenListEnd {
                    ts.Next() // consume the ListEnd
                    break
                }
                item := NewMetadata()
                if err := item.XXXIngestFrom(ts, opts); err != nil {
                    return fmt.Errorf("ingesting Metadata[]: %w", err)
                }
                x.MetadataAppend(item)
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Cancel) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Cancel) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Cancel")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "SessionID":
            x.SetSessionID(tok.Uint32())
        case "ReqID":
            x.SetReqID(tok.Uint32())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *OpenAck) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *OpenAck) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in OpenAck")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "OpenID":
            x.SetOpenID(tok.Uint32())
        case "SessionID":
            x.SetSessionID(tok.Uint32())
        case "ProtocolMajor":
            x.SetProtocolMajor(tok.Uint8())
        case "ProtocolMinor":
            x.SetProtocolMinor(tok.Uint8())
        case "MaxPayloadSize":
            x.SetMaxPayloadSize(tok.Uint32())
        case "ErrCode":
            if len(tok.Bytes) > 0 {
                x.SetErrCode(ErrCodeByName[tok.String()])
            } else {
                x.SetErrCode(ErrCode(tok.Uint8()))
            }
        case "Error":
            x.SetError(tok.String())
        case "Metadata":
            if tok.IsNil {
                continue
            }
            listTok, ok := ts.Next()
            if !ok || listTok.Kind != clawiter.TokenListStart {
                return fmt.Errorf("expected TokenListStart for Metadata")
            }
            for {
                peekTok, ok := ts.Peek()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Metadata list")
                }
                if peekTok.Kind == clawiter.TokenListEnd {
                    ts.Next() // consume the ListEnd
                    break
                }
                item := NewMetadata()
                if err := item.XXXIngestFrom(ts, opts); err != nil {
                    return fmt.Errorf("ingesting Metadata[]: %w", err)
                }
                x.MetadataAppend(item)
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Close) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Close) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Close")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "SessionID":
            x.SetSessionID(tok.Uint32())
        case "ErrCode":
            if len(tok.Bytes) > 0 {
                x.SetErrCode(ErrCodeByName[tok.String()])
            } else {
                x.SetErrCode(ErrCode(tok.Uint8()))
            }
        case "Error":
            x.SetError(tok.String())
        case "Metadata":
            if tok.IsNil {
                continue
            }
            listTok, ok := ts.Next()
            if !ok || listTok.Kind != clawiter.TokenListStart {
                return fmt.Errorf("expected TokenListStart for Metadata")
            }
            for {
                peekTok, ok := ts.Peek()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Metadata list")
                }
                if peekTok.Kind == clawiter.TokenListEnd {
                    ts.Next() // consume the ListEnd
                    break
                }
                item := NewMetadata()
                if err := item.XXXIngestFrom(ts, opts); err != nil {
                    return fmt.Errorf("ingesting Metadata[]: %w", err)
                }
                x.MetadataAppend(item)
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Payload) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Payload) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Payload")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "SessionID":
            x.SetSessionID(tok.Uint32())
        case "ReqID":
            x.SetReqID(tok.Uint32())
        case "Payload":
            x.SetPayload(tok.Bytes)
        case "EndStream":
            x.SetEndStream(tok.Bool())
        case "Compression":
            if len(tok.Bytes) > 0 {
                x.SetCompression(CompressionByName[tok.String()])
            } else {
                x.SetCompression(Compression(tok.Uint8()))
            }
        case "Metadata":
            if tok.IsNil {
                continue
            }
            listTok, ok := ts.Next()
            if !ok || listTok.Kind != clawiter.TokenListStart {
                return fmt.Errorf("expected TokenListStart for Metadata")
            }
            for {
                peekTok, ok := ts.Peek()
                if !ok {
                    return fmt.Errorf("unexpected EOF in Metadata list")
                }
                if peekTok.Kind == clawiter.TokenListEnd {
                    ts.Next() // consume the ListEnd
                    break
                }
                item := NewMetadata()
                if err := item.XXXIngestFrom(ts, opts); err != nil {
                    return fmt.Errorf("ingesting Metadata[]: %w", err)
                }
                x.MetadataAppend(item)
            }
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Pong) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Pong) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Pong")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "ID":
            x.SetID(tok.Uint32())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Msg) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Msg) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Msg")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "Type":
            if len(tok.Bytes) > 0 {
                x.SetType(MsgTypeByName[tok.String()])
            } else {
                x.SetType(MsgType(tok.Uint8()))
            }
        case "Open":
            if tok.IsNil {
                continue
            }
            nested := NewOpen()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting Open: %w", err)
            }
            x.SetOpen(nested)
        case "OpenAck":
            if tok.IsNil {
                continue
            }
            nested := NewOpenAck()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting OpenAck: %w", err)
            }
            x.SetOpenAck(nested)
        case "Close":
            if tok.IsNil {
                continue
            }
            nested := NewClose()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting Close: %w", err)
            }
            x.SetClose(nested)
        case "Payload":
            if tok.IsNil {
                continue
            }
            nested := NewPayload()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting Payload: %w", err)
            }
            x.SetPayload(nested)
        case "Cancel":
            if tok.IsNil {
                continue
            }
            nested := NewCancel()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting Cancel: %w", err)
            }
            x.SetCancel(nested)
        case "Ping":
            if tok.IsNil {
                continue
            }
            nested := NewPing()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting Ping: %w", err)
            }
            x.SetPing(nested)
        case "Pong":
            if tok.IsNil {
                continue
            }
            nested := NewPong()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting Pong: %w", err)
            }
            x.SetPong(nested)
        case "GoAway":
            if tok.IsNil {
                continue
            }
            nested := NewGoAway()
            if err := nested.XXXIngestFrom(ts, opts); err != nil {
                return fmt.Errorf("ingesting GoAway: %w", err)
            }
            x.SetGoAway(nested)
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *Ping) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *Ping) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in Ping")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "ID":
            x.SetID(tok.Uint32())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

// IngestWithOptions populates the struct from a token stream with options.
// This is the inverse of Walk().
func (x *GoAway) IngestWithOptions(tokens iter.Seq[clawiter.Token], opts clawiter.IngestOptions) error {
    ts := clawiter.NewTokenStream(tokens)
    defer ts.Close()
    return x.XXXIngestFrom(ts, opts)
}

// XXXIngestFrom is for internal use - ingests from a shared token stream.
func (x *GoAway) XXXIngestFrom(ts *clawiter.TokenStream, opts clawiter.IngestOptions) error {
    tok, ok := ts.Next()
    if !ok {
        return fmt.Errorf("expected TokenStructStart, got EOF")
    }
    if tok.Kind != clawiter.TokenStructStart {
        return fmt.Errorf("expected TokenStructStart, got %v", tok.Kind)
    }

    for {
        tok, ok = ts.Next()
        if !ok {
            return fmt.Errorf("unexpected EOF in GoAway")
        }

        if tok.Kind == clawiter.TokenStructEnd {
            return nil
        }

        if tok.Kind != clawiter.TokenField {
            return fmt.Errorf("expected TokenField, got %v", tok.Kind)
        }

        switch tok.Name {
        case "LastSessionID":
            x.SetLastSessionID(tok.Uint32())
        case "ErrCode":
            if len(tok.Bytes) > 0 {
                x.SetErrCode(ErrCodeByName[tok.String()])
            } else {
                x.SetErrCode(ErrCode(tok.Uint8()))
            }
        case "DebugData":
            x.SetDebugData(tok.String())
        default:
            if opts.IgnoreUnknownFields {
                if err := clawiter.SkipValue(ts, tok); err != nil {
                    return err
                }
                continue
            }
            return fmt.Errorf("unknown field: %s", tok.Name)
        }
    }
}

