// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

// Package msgs
package msgs

import (
    "context"
    "io"
    "bytes"
    "fmt"

    "github.com/bearlytools/claw/clawc/languages/go/mapping"
    "github.com/bearlytools/claw/languages/go/reflect"
    "github.com/bearlytools/claw/languages/go/reflect/runtime"
    "github.com/bearlytools/claw/clawc/languages/go/segment"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
)

// Ensure imports are used.
var (
    _ context.Context
    _ = io.EOF
    _ = bytes.MinRead
    _ = fmt.Errorf
    _ mapping.Map
    _ reflect.StructDescr
    _ = runtime.RegisterPackage
    _ segment.Struct
    _ = field.FTBool
)

// SyntaxVersion is the major version of the Claw language that is being rendered.
const SyntaxVersion = 0

var _package = "msgs"
var _packagePath = "github.com/bearlytools/claw/rpc/internal/msgs"


// Compression indicates the compression algorithm used on a payload.
type Compression uint8

// String implements fmt.Stringer.
func (x Compression) String() string {
    return CompressionByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x Compression) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(0)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x Compression) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(0).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum Compression.
const (
    // CmpNone indicates no compression.
    CmpNone Compression = 0
    // CmpGzip indicates gzip compression.
    CmpGzip Compression = 1
    // CmpSnappy indicates snappy compression.
    CmpSnappy Compression = 2
    // CmpZstd indicates zstd compression.
    CmpZstd Compression = 3
)

// CompressionByName converts a string representing the enumerator into a Compression.
var CompressionByName = map[string]Compression{
    "CmpGzip": 1,
    "CmpNone": 0,
    "CmpSnappy": 2,
    "CmpZstd": 3,
}

// CompressionByValue converts a uint8 representing a Compression into its string name.
var CompressionByValue = map[uint8]string{
    0: "CmpNone",
    1: "CmpGzip",
    2: "CmpSnappy",
    3: "CmpZstd",
}
// ErrCode are error codes sent over Close or OpenAck messages.
// Values are aligned with rpc/errors.Category for direct conversion.
type ErrCode uint16

// String implements fmt.Stringer.
func (x ErrCode) String() string {
    return ErrCodeByValue[uint16(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ErrCode) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(1)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ErrCode) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(1).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum ErrCode.
const (
    // ErrNone indicates there was no error.
    ErrNone ErrCode = 0
    // ErrCanceled indicates the operation was canceled.
    ErrCanceled ErrCode = 1
    // ErrReserved is reserved (gRPC Unknown, we use 0 for unknown). Do not use.
    ErrReserved ErrCode = 2
    // ErrInvalidArgument indicates the client specified an invalid argument.
    ErrInvalidArgument ErrCode = 3
    // ErrDeadlineExceeded indicates the deadline expired before the operation completed.
    ErrDeadlineExceeded ErrCode = 4
    // ErrNotFound indicates a requested resource was not found.
    ErrNotFound ErrCode = 5
    // ErrAlreadyExists indicates the resource already exists.
    ErrAlreadyExists ErrCode = 6
    // ErrPermissionDenied indicates the caller does not have permission.
    ErrPermissionDenied ErrCode = 7
    // ErrResourceExhausted indicates some resource has been exhausted.
    ErrResourceExhausted ErrCode = 8
    // ErrFailedPrecondition indicates the operation was rejected because the system is not in a required state.
    ErrFailedPrecondition ErrCode = 9
    // ErrAborted indicates the operation was aborted.
    ErrAborted ErrCode = 10
    // ErrOutOfRange indicates the operation was attempted past the valid range.
    ErrOutOfRange ErrCode = 11
    // ErrUnimplemented indicates the operation is not implemented.
    ErrUnimplemented ErrCode = 12
    // ErrInternal indicates there was an internal error.
    ErrInternal ErrCode = 13
    // ErrUnavailable indicates the service is currently unavailable.
    ErrUnavailable ErrCode = 14
    // ErrDataLoss indicates unrecoverable data loss or corruption.
    ErrDataLoss ErrCode = 15
    // ErrUnauthenticated indicates the request does not have valid authentication credentials.
    ErrUnauthenticated ErrCode = 16
)

// ErrCodeByName converts a string representing the enumerator into a ErrCode.
var ErrCodeByName = map[string]ErrCode{
    "ErrAborted": 10,
    "ErrAlreadyExists": 6,
    "ErrCanceled": 1,
    "ErrDataLoss": 15,
    "ErrDeadlineExceeded": 4,
    "ErrFailedPrecondition": 9,
    "ErrInternal": 13,
    "ErrInvalidArgument": 3,
    "ErrNone": 0,
    "ErrNotFound": 5,
    "ErrOutOfRange": 11,
    "ErrPermissionDenied": 7,
    "ErrReserved": 2,
    "ErrResourceExhausted": 8,
    "ErrUnauthenticated": 16,
    "ErrUnavailable": 14,
    "ErrUnimplemented": 12,
}

// ErrCodeByValue converts a uint16 representing a ErrCode into its string name.
var ErrCodeByValue = map[uint16]string{
    0: "ErrNone",
    1: "ErrCanceled",
    2: "ErrReserved",
    3: "ErrInvalidArgument",
    4: "ErrDeadlineExceeded",
    5: "ErrNotFound",
    6: "ErrAlreadyExists",
    7: "ErrPermissionDenied",
    8: "ErrResourceExhausted",
    9: "ErrFailedPrecondition",
    10: "ErrAborted",
    11: "ErrOutOfRange",
    12: "ErrUnimplemented",
    13: "ErrInternal",
    14: "ErrUnavailable",
    15: "ErrDataLoss",
    16: "ErrUnauthenticated",
}
// MsgType is used to determine the type of message.
type MsgType uint8

// String implements fmt.Stringer.
func (x MsgType) String() string {
    return MsgTypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x MsgType) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(2)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x MsgType) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(2).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum MsgType.
const (
    // TUnknown indicates a bug.
    TUnknown MsgType = 0
    // TOpen indicates this message is for opening the stream.
    TOpen MsgType = 1
    // TOpenAck indicates this message is an ack for opening the stream.
    TOpenAck MsgType = 2
    // TClose indicates this message is for closing the stream.
    TClose MsgType = 3
    // TPayload indicates this message is a payload message.
    TPayload MsgType = 4
    // TCancel indicates this message is a cancel message.
    TCancel MsgType = 5
    // TPing indicates this message is a ping for keepalive.
    TPing MsgType = 6
    // TPong indicates this message is a pong response to a ping.
    TPong MsgType = 7
    // TGoAway indicates the server is going away and will stop accepting new streams.
    TGoAway MsgType = 8
)

// MsgTypeByName converts a string representing the enumerator into a MsgType.
var MsgTypeByName = map[string]MsgType{
    "TCancel": 5,
    "TClose": 3,
    "TGoAway": 8,
    "TOpen": 1,
    "TOpenAck": 2,
    "TPayload": 4,
    "TPing": 6,
    "TPong": 7,
    "TUnknown": 0,
}

// MsgTypeByValue converts a uint8 representing a MsgType into its string name.
var MsgTypeByValue = map[uint8]string{
    0: "TUnknown",
    1: "TOpen",
    2: "TOpenAck",
    3: "TClose",
    4: "TPayload",
    5: "TCancel",
    6: "TPing",
    7: "TPong",
    8: "TGoAway",
}
// RPCType is the type of RPC being performed.
type RPCType uint8

// String implements fmt.Stringer.
func (x RPCType) String() string {
    return RPCTypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x RPCType) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(3)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x RPCType) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(3).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum RPCType.
const (
    // RTUnknown is always a bug.
    RTUnknown RPCType = 0
    // RTSynchronous represents a request-response style RPC.
    RTSynchronous RPCType = 1
    // RTSend represents a send-only RPC.
    RTSend RPCType = 2
    // RTRecv represents a receive-only RPC.
    RTRecv RPCType = 3
    // RTBiDirectional represents a bi-directional streaming RPC.
    RTBiDirectional RPCType = 4
)

// RPCTypeByName converts a string representing the enumerator into a RPCType.
var RPCTypeByName = map[string]RPCType{
    "RTBiDirectional": 4,
    "RTRecv": 3,
    "RTSend": 2,
    "RTSynchronous": 1,
    "RTUnknown": 0,
}

// RPCTypeByValue converts a uint8 representing a RPCType into its string name.
var RPCTypeByValue = map[uint8]string{
    0: "RTUnknown",
    1: "RTSynchronous",
    2: "RTSend",
    3: "RTRecv",
    4: "RTBiDirectional",
}


// Cancel is a message sent to cancel an RPC. Works for all RPC types.
type Cancel struct {
   s *segment.Struct
}

// NewCancel creates a new pooled instance of Cancel.
// Call Release() when done to return it to the pool for reuse.
func NewCancel(ctx context.Context) Cancel {
    s := segment.New(ctx, XXXMappingCancel)
    s.SetIsSetEnabled(true)
    return Cancel{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Cancel) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewCancelFrom creates a new Cancel from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewCancelFrom(s *segment.Struct) Cancel {
    return Cancel{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Cancel) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Cancel) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Cancel) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Cancel) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Cancel) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// SessionID is the ID of the session being cancelled.
func (x Cancel) SessionID() uint32 {
    return segment.GetUint32(x.s, 0)
}

func (x Cancel) SetSessionID(value uint32) Cancel {
    segment.SetUint32(x.s, 0, value)
    return x
}
func (x Cancel) IsSetSessionID() bool{
    return x.s.HasField(0)
}

// ReqID is the ID of the request that is being cancelled. For non-Synchronous RPCs, this is 0.
func (x Cancel) ReqID() uint32 {
    return segment.GetUint32(x.s, 1)
}

func (x Cancel) SetReqID(value uint32) Cancel {
    segment.SetUint32(x.s, 1, value)
    return x
}
func (x Cancel) IsSetReqID() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Cancel) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Cancel) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Cancel) XXXTypeHash() [16]byte {
    return XXXTypeHashCancel
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Cancel) SetRecording(enabled bool) Cancel {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Cancel) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Cancel) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Cancel) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// CancelRaw is a plain Go struct representation of Cancel.
// Zero values are not set (sparse encoding).
type CancelRaw struct {
    SessionID uint32
    ReqID uint32
}

// NewCancelFromRaw creates a new Cancel from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewCancelFromRaw(ctx context.Context, raw CancelRaw) Cancel {
    x := NewCancel(ctx)
    if raw.SessionID != 0 {
        x.SetSessionID(raw.SessionID)
    }
    if raw.ReqID != 0 {
        x.SetReqID(raw.ReqID)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Cancel) ToRaw(ctx context.Context) CancelRaw {
    raw := CancelRaw{}
    raw.SessionID = x.SessionID()
    raw.ReqID = x.ReqID()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Cancel) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(0)
}

// Close is a message that closes the session. If ErrCode is set then the session close is due to some type
// of error.
type Close struct {
   s *segment.Struct
}

// NewClose creates a new pooled instance of Close.
// Call Release() when done to return it to the pool for reuse.
func NewClose(ctx context.Context) Close {
    s := segment.New(ctx, XXXMappingClose)
    s.SetIsSetEnabled(true)
    return Close{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Close) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewCloseFrom creates a new Close from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewCloseFrom(s *segment.Struct) Close {
    return Close{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Close) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Close) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Close) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Close) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Close) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// SessionID is the ID of the session that is closing.
func (x Close) SessionID() uint32 {
    return segment.GetUint32(x.s, 0)
}

func (x Close) SetSessionID(value uint32) Close {
    segment.SetUint32(x.s, 0, value)
    return x
}
func (x Close) IsSetSessionID() bool{
    return x.s.HasField(0)
}

// ErrCode is a code describing the error type. 0 indicates no error.
func (x Close) ErrCode() ErrCode {
    return ErrCode(segment.GetUint16(x.s, 1))
}

func (x Close) SetErrCode(value ErrCode) Close {
    segment.SetUint16(x.s, 1, uint16(value))
    return x
}
func (x Close) IsSetErrCode() bool{
    return x.s.HasField(1)
}

// Error is an error message.
func (x Close) Error() string {
    return segment.GetString(x.s, 2)
}

func (x Close) SetError(value string) Close {
    segment.SetString(x.s, 2, value)
    return x
}
func (x Close) IsSetError() bool{
    return x.s.HasField(2)
}

// Metadata is trailing metadata sent with the close.
// MetadataList returns the underlying Structs list for iteration.
// Use NewMetadata() to create items and Append to add them.
func (x Close) MetadataList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 3, XXXMappingMetadata); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 3, XXXMappingMetadata)
    return structs
}

// MetadataLen returns the number of items in the list.
func (x Close) MetadataLen(ctx context.Context) int {
    return x.MetadataList(ctx).Len()
}

// MetadataGet returns the item at the given index.
func (x Close) MetadataGet(ctx context.Context, index int) Metadata {
    s := x.MetadataList(ctx).Get(index)
    return Metadata{s: s}
}

// MetadataAppend appends items to the list.
func (x Close) MetadataAppend(ctx context.Context, values ...Metadata) {
    list := x.MetadataList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// MetadataAppendRaw appends items to the list using Raw struct representations.
func (x Close) MetadataAppendRaw(ctx context.Context, values ...*MetadataRaw) {
    list := x.MetadataList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewMetadataFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Close) IsSetMetadata() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Close) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Close) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Close) XXXTypeHash() [16]byte {
    return XXXTypeHashClose
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Close) SetRecording(enabled bool) Close {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Close) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Close) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Close) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// CloseRaw is a plain Go struct representation of Close.
// Zero values are not set (sparse encoding).
type CloseRaw struct {
    SessionID uint32
    ErrCode ErrCode
    Error string
    Metadata []*MetadataRaw
}

// NewCloseFromRaw creates a new Close from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewCloseFromRaw(ctx context.Context, raw CloseRaw) Close {
    x := NewClose(ctx)
    if raw.SessionID != 0 {
        x.SetSessionID(raw.SessionID)
    }
    if raw.ErrCode != 0 {
        x.SetErrCode(raw.ErrCode)
    }
    if raw.Error != "" {
        x.SetError(raw.Error)
    }
    if raw.Metadata != nil {
        list := x.MetadataList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Metadata))
        for _, r := range raw.Metadata {
            if r != nil {
                items = append(items, NewMetadataFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Close) ToRaw(ctx context.Context) CloseRaw {
    raw := CloseRaw{}
    raw.SessionID = x.SessionID()
    raw.ErrCode = x.ErrCode()
    raw.Error = x.Error()
    if l := x.s.GetList(3); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Metadata = make([]*MetadataRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Metadata{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Metadata[i] = &itemRaw
        }
    } else if x.s.HasField(3) {
        list := x.MetadataList(ctx)
        raw.Metadata = make([]*MetadataRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Metadata{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Metadata[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Close) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(1)
}

// Descr gives the description of the RPC so that it can match up with the other side.
type Descr struct {
   s *segment.Struct
}

// NewDescr creates a new pooled instance of Descr.
// Call Release() when done to return it to the pool for reuse.
func NewDescr(ctx context.Context) Descr {
    s := segment.New(ctx, XXXMappingDescr)
    s.SetIsSetEnabled(true)
    return Descr{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Descr) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewDescrFrom creates a new Descr from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewDescrFrom(s *segment.Struct) Descr {
    return Descr{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Descr) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Descr) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Descr) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Descr) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Descr) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// Package is the package the RPC is defined in.
func (x Descr) Package() string {
    return segment.GetString(x.s, 0)
}

func (x Descr) SetPackage(value string) Descr {
    segment.SetString(x.s, 0, value)
    return x
}
func (x Descr) IsSetPackage() bool{
    return x.s.HasField(0)
}

// Service is the name of the service the RPC is defined in.
func (x Descr) Service() string {
    return segment.GetString(x.s, 1)
}

func (x Descr) SetService(value string) Descr {
    segment.SetString(x.s, 1, value)
    return x
}
func (x Descr) IsSetService() bool{
    return x.s.HasField(1)
}

// Call is the name of the call the RPC defines.
func (x Descr) Call() string {
    return segment.GetString(x.s, 2)
}

func (x Descr) SetCall(value string) Descr {
    segment.SetString(x.s, 2, value)
    return x
}
func (x Descr) IsSetCall() bool{
    return x.s.HasField(2)
}

// Type is the type of RPC being performed.
func (x Descr) Type() RPCType {
    return RPCType(segment.GetUint8(x.s, 3))
}

func (x Descr) SetType(value RPCType) Descr {
    segment.SetUint8(x.s, 3, uint8(value))
    return x
}
func (x Descr) IsSetType() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Descr) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Descr) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Descr) XXXTypeHash() [16]byte {
    return XXXTypeHashDescr
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Descr) SetRecording(enabled bool) Descr {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Descr) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Descr) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Descr) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// DescrRaw is a plain Go struct representation of Descr.
// Zero values are not set (sparse encoding).
type DescrRaw struct {
    Package string
    Service string
    Call string
    Type RPCType
}

// NewDescrFromRaw creates a new Descr from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewDescrFromRaw(ctx context.Context, raw DescrRaw) Descr {
    x := NewDescr(ctx)
    if raw.Package != "" {
        x.SetPackage(raw.Package)
    }
    if raw.Service != "" {
        x.SetService(raw.Service)
    }
    if raw.Call != "" {
        x.SetCall(raw.Call)
    }
    if raw.Type != 0 {
        x.SetType(raw.Type)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Descr) ToRaw(ctx context.Context) DescrRaw {
    raw := DescrRaw{}
    raw.Package = x.Package()
    raw.Service = x.Service()
    raw.Call = x.Call()
    raw.Type = x.Type()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Descr) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(2)
}

// GoAway is sent to indicate the sender is going away and will stop accepting new streams.
type GoAway struct {
   s *segment.Struct
}

// NewGoAway creates a new pooled instance of GoAway.
// Call Release() when done to return it to the pool for reuse.
func NewGoAway(ctx context.Context) GoAway {
    s := segment.New(ctx, XXXMappingGoAway)
    s.SetIsSetEnabled(true)
    return GoAway{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x GoAway) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewGoAwayFrom creates a new GoAway from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewGoAwayFrom(s *segment.Struct) GoAway {
    return GoAway{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x GoAway) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x GoAway) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x GoAway) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x GoAway) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x GoAway) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// LastSessionID is the last session ID that will be processed.
func (x GoAway) LastSessionID() uint32 {
    return segment.GetUint32(x.s, 0)
}

func (x GoAway) SetLastSessionID(value uint32) GoAway {
    segment.SetUint32(x.s, 0, value)
    return x
}
func (x GoAway) IsSetLastSessionID() bool{
    return x.s.HasField(0)
}

// ErrCode is a code describing the reason for going away.
func (x GoAway) ErrCode() ErrCode {
    return ErrCode(segment.GetUint16(x.s, 1))
}

func (x GoAway) SetErrCode(value ErrCode) GoAway {
    segment.SetUint16(x.s, 1, uint16(value))
    return x
}
func (x GoAway) IsSetErrCode() bool{
    return x.s.HasField(1)
}

// DebugData is optional debug information about the shutdown.
func (x GoAway) DebugData() string {
    return segment.GetString(x.s, 2)
}

func (x GoAway) SetDebugData(value string) GoAway {
    segment.SetString(x.s, 2, value)
    return x
}
func (x GoAway) IsSetDebugData() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x GoAway) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x GoAway) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x GoAway) XXXTypeHash() [16]byte {
    return XXXTypeHashGoAway
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x GoAway) SetRecording(enabled bool) GoAway {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x GoAway) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x GoAway) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x GoAway) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// GoAwayRaw is a plain Go struct representation of GoAway.
// Zero values are not set (sparse encoding).
type GoAwayRaw struct {
    LastSessionID uint32
    ErrCode ErrCode
    DebugData string
}

// NewGoAwayFromRaw creates a new GoAway from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewGoAwayFromRaw(ctx context.Context, raw GoAwayRaw) GoAway {
    x := NewGoAway(ctx)
    if raw.LastSessionID != 0 {
        x.SetLastSessionID(raw.LastSessionID)
    }
    if raw.ErrCode != 0 {
        x.SetErrCode(raw.ErrCode)
    }
    if raw.DebugData != "" {
        x.SetDebugData(raw.DebugData)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x GoAway) ToRaw(ctx context.Context) GoAwayRaw {
    raw := GoAwayRaw{}
    raw.LastSessionID = x.LastSessionID()
    raw.ErrCode = x.ErrCode()
    raw.DebugData = x.DebugData()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x GoAway) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(3)
}

// Metadata represents a key-value pair for request/response metadata.
type Metadata struct {
   s *segment.Struct
}

// NewMetadata creates a new pooled instance of Metadata.
// Call Release() when done to return it to the pool for reuse.
func NewMetadata(ctx context.Context) Metadata {
    s := segment.New(ctx, XXXMappingMetadata)
    s.SetIsSetEnabled(true)
    return Metadata{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Metadata) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewMetadataFrom creates a new Metadata from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewMetadataFrom(s *segment.Struct) Metadata {
    return Metadata{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Metadata) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Metadata) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Metadata) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Metadata) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Metadata) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// Key is the metadata key.
func (x Metadata) Key() string {
    return segment.GetString(x.s, 0)
}

func (x Metadata) SetKey(value string) Metadata {
    segment.SetString(x.s, 0, value)
    return x
}
func (x Metadata) IsSetKey() bool{
    return x.s.HasField(0)
}

// Value is the metadata value.
func (x Metadata) Value() []byte {
    return segment.GetBytes(x.s, 1)
}

func (x Metadata) SafeGetValue() []byte {
    return segment.GetBytesCopy(x.s, 1)
}

func (x Metadata) SetValue(value []byte) Metadata {
    segment.SetBytes(x.s, 1, value)
    return x
}
func (x Metadata) IsSetValue() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Metadata) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Metadata) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Metadata) XXXTypeHash() [16]byte {
    return XXXTypeHashMetadata
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Metadata) SetRecording(enabled bool) Metadata {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Metadata) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Metadata) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Metadata) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// MetadataRaw is a plain Go struct representation of Metadata.
// Zero values are not set (sparse encoding).
type MetadataRaw struct {
    Key string
    Value []byte
}

// NewMetadataFromRaw creates a new Metadata from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewMetadataFromRaw(ctx context.Context, raw MetadataRaw) Metadata {
    x := NewMetadata(ctx)
    if raw.Key != "" {
        x.SetKey(raw.Key)
    }
    if raw.Value != nil {
        x.SetValue(raw.Value)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Metadata) ToRaw(ctx context.Context) MetadataRaw {
    raw := MetadataRaw{}
    raw.Key = x.Key()
    if x.s.HasField(1) {
        raw.Value = x.Value()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Metadata) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(4)
}

// Msg represents any message that we decode on the wire.
type Msg struct {
   s *segment.Struct
}

// NewMsg creates a new pooled instance of Msg.
// Call Release() when done to return it to the pool for reuse.
func NewMsg(ctx context.Context) Msg {
    s := segment.New(ctx, XXXMappingMsg)
    s.SetIsSetEnabled(true)
    return Msg{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Msg) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewMsgFrom creates a new Msg from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewMsgFrom(s *segment.Struct) Msg {
    return Msg{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Msg) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Msg) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Msg) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Msg) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Msg) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// Type is the type of message.
func (x Msg) Type() MsgType {
    return MsgType(segment.GetUint8(x.s, 0))
}

func (x Msg) SetType(value MsgType) Msg {
    segment.SetUint8(x.s, 0, uint8(value))
    return x
}
func (x Msg) IsSetType() bool{
    return x.s.HasField(0)
}

// Open is an open message.
func (x Msg) Open() Open {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingOpen)
    return Open{s: s}
}

func (x Msg) SetOpen(value Open) Msg {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x Msg) IsSetOpen() bool{
    return x.s.HasField(1)
}

// OpenAck is an open ack message.
func (x Msg) OpenAck() OpenAck {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingOpenAck)
    return OpenAck{s: s}
}

func (x Msg) SetOpenAck(value OpenAck) Msg {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x Msg) IsSetOpenAck() bool{
    return x.s.HasField(2)
}

// Close is a close message.
func (x Msg) Close() Close {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingClose)
    return Close{s: s}
}

func (x Msg) SetClose(value Close) Msg {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x Msg) IsSetClose() bool{
    return x.s.HasField(3)
}

// Payload is a payload message.
func (x Msg) Payload() Payload {
    s := segment.GetNestedStruct(x.s, 4, XXXMappingPayload)
    return Payload{s: s}
}

func (x Msg) SetPayload(value Payload) Msg {
    segment.SetNestedStruct(x.s, 4, value.XXXGetStruct())
    return x
}
func (x Msg) IsSetPayload() bool{
    return x.s.HasField(4)
}

// Cancel is a Cancel message.
func (x Msg) Cancel() Cancel {
    s := segment.GetNestedStruct(x.s, 5, XXXMappingCancel)
    return Cancel{s: s}
}

func (x Msg) SetCancel(value Cancel) Msg {
    segment.SetNestedStruct(x.s, 5, value.XXXGetStruct())
    return x
}
func (x Msg) IsSetCancel() bool{
    return x.s.HasField(5)
}

// Ping is a ping message for keepalive.
func (x Msg) Ping() Ping {
    s := segment.GetNestedStruct(x.s, 6, XXXMappingPing)
    return Ping{s: s}
}

func (x Msg) SetPing(value Ping) Msg {
    segment.SetNestedStruct(x.s, 6, value.XXXGetStruct())
    return x
}
func (x Msg) IsSetPing() bool{
    return x.s.HasField(6)
}

// Pong is a pong response to a ping.
func (x Msg) Pong() Pong {
    s := segment.GetNestedStruct(x.s, 7, XXXMappingPong)
    return Pong{s: s}
}

func (x Msg) SetPong(value Pong) Msg {
    segment.SetNestedStruct(x.s, 7, value.XXXGetStruct())
    return x
}
func (x Msg) IsSetPong() bool{
    return x.s.HasField(7)
}

// GoAway is a message indicating the server is going away.
func (x Msg) GoAway() GoAway {
    s := segment.GetNestedStruct(x.s, 8, XXXMappingGoAway)
    return GoAway{s: s}
}

func (x Msg) SetGoAway(value GoAway) Msg {
    segment.SetNestedStruct(x.s, 8, value.XXXGetStruct())
    return x
}
func (x Msg) IsSetGoAway() bool{
    return x.s.HasField(8)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Msg) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Msg) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Msg) XXXTypeHash() [16]byte {
    return XXXTypeHashMsg
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Msg) SetRecording(enabled bool) Msg {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Msg) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Msg) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Msg) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// MsgRaw is a plain Go struct representation of Msg.
// Zero values are not set (sparse encoding).
type MsgRaw struct {
    Type MsgType
    Open *OpenRaw
    OpenAck *OpenAckRaw
    Close *CloseRaw
    Payload *PayloadRaw
    Cancel *CancelRaw
    Ping *PingRaw
    Pong *PongRaw
    GoAway *GoAwayRaw
}

// NewMsgFromRaw creates a new Msg from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewMsgFromRaw(ctx context.Context, raw MsgRaw) Msg {
    x := NewMsg(ctx)
    if raw.Type != 0 {
        x.SetType(raw.Type)
    }
    if raw.Open != nil {
        x.SetOpen(NewOpenFromRaw(ctx, *raw.Open))
    }
    if raw.OpenAck != nil {
        x.SetOpenAck(NewOpenAckFromRaw(ctx, *raw.OpenAck))
    }
    if raw.Close != nil {
        x.SetClose(NewCloseFromRaw(ctx, *raw.Close))
    }
    if raw.Payload != nil {
        x.SetPayload(NewPayloadFromRaw(ctx, *raw.Payload))
    }
    if raw.Cancel != nil {
        x.SetCancel(NewCancelFromRaw(ctx, *raw.Cancel))
    }
    if raw.Ping != nil {
        x.SetPing(NewPingFromRaw(ctx, *raw.Ping))
    }
    if raw.Pong != nil {
        x.SetPong(NewPongFromRaw(ctx, *raw.Pong))
    }
    if raw.GoAway != nil {
        x.SetGoAway(NewGoAwayFromRaw(ctx, *raw.GoAway))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Msg) ToRaw(ctx context.Context) MsgRaw {
    raw := MsgRaw{}
    raw.Type = x.Type()
    if x.s.HasField(1) {
        nestedRaw := x.Open().ToRaw(ctx)
        raw.Open = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.OpenAck().ToRaw(ctx)
        raw.OpenAck = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.Close().ToRaw(ctx)
        raw.Close = &nestedRaw
    }
    if x.s.HasField(4) {
        nestedRaw := x.Payload().ToRaw(ctx)
        raw.Payload = &nestedRaw
    }
    if x.s.HasField(5) {
        nestedRaw := x.Cancel().ToRaw(ctx)
        raw.Cancel = &nestedRaw
    }
    if x.s.HasField(6) {
        nestedRaw := x.Ping().ToRaw(ctx)
        raw.Ping = &nestedRaw
    }
    if x.s.HasField(7) {
        nestedRaw := x.Pong().ToRaw(ctx)
        raw.Pong = &nestedRaw
    }
    if x.s.HasField(8) {
        nestedRaw := x.GoAway().ToRaw(ctx)
        raw.GoAway = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Msg) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(5)
}

// Open is the open message for an RPC.
type Open struct {
   s *segment.Struct
}

// NewOpen creates a new pooled instance of Open.
// Call Release() when done to return it to the pool for reuse.
func NewOpen(ctx context.Context) Open {
    s := segment.New(ctx, XXXMappingOpen)
    s.SetIsSetEnabled(true)
    return Open{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Open) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewOpenFrom creates a new Open from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewOpenFrom(s *segment.Struct) Open {
    return Open{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Open) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Open) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Open) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Open) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Open) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// OpenID is the ID of the Open message so the response can refer to it.
func (x Open) OpenID() uint32 {
    return segment.GetUint32(x.s, 0)
}

func (x Open) SetOpenID(value uint32) Open {
    segment.SetUint32(x.s, 0, value)
    return x
}
func (x Open) IsSetOpenID() bool{
    return x.s.HasField(0)
}

// Descr is the RPC descriptor.
func (x Open) Descr() Descr {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingDescr)
    return Descr{s: s}
}

func (x Open) SetDescr(value Descr) Open {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x Open) IsSetDescr() bool{
    return x.s.HasField(1)
}

// ProtocolMajor is the major version of the protocol.

func (x Open) ProtocolMajor() uint8 {
    return segment.GetUint8(x.s, 2)
}

func (x Open) SetProtocolMajor(value uint8) Open {
    segment.SetUint8(x.s, 2, value)
    return x
}
func (x Open) IsSetProtocolMajor() bool{
    return x.s.HasField(2)
}

// ProtocolMinor is the minor version of the protocol.

func (x Open) ProtocolMinor() uint8 {
    return segment.GetUint8(x.s, 3)
}

func (x Open) SetProtocolMinor(value uint8) Open {
    segment.SetUint8(x.s, 3, value)
    return x
}
func (x Open) IsSetProtocolMinor() bool{
    return x.s.HasField(3)
}

// DeadlineMS is the deadline in milliseconds from now. 0 means no deadline.
func (x Open) DeadlineMS() uint64 {
    return segment.GetUint64(x.s, 4)
}

func (x Open) SetDeadlineMS(value uint64) Open {
    segment.SetUint64(x.s, 4, value)
    return x
}
func (x Open) IsSetDeadlineMS() bool{
    return x.s.HasField(4)
}

// MaxPayloadSize is the maximum payload size the client will accept. 0 means use server default.
func (x Open) MaxPayloadSize() uint32 {
    return segment.GetUint32(x.s, 5)
}

func (x Open) SetMaxPayloadSize(value uint32) Open {
    segment.SetUint32(x.s, 5, value)
    return x
}
func (x Open) IsSetMaxPayloadSize() bool{
    return x.s.HasField(5)
}

// TraceID is the trace ID for distributed tracing.
func (x Open) TraceID() []byte {
    return segment.GetBytes(x.s, 6)
}

func (x Open) SafeGetTraceID() []byte {
    return segment.GetBytesCopy(x.s, 6)
}

func (x Open) SetTraceID(value []byte) Open {
    segment.SetBytes(x.s, 6, value)
    return x
}
func (x Open) IsSetTraceID() bool{
    return x.s.HasField(6)
}

// SpanID is the span ID for distributed tracing.
func (x Open) SpanID() []byte {
    return segment.GetBytes(x.s, 7)
}

func (x Open) SafeGetSpanID() []byte {
    return segment.GetBytesCopy(x.s, 7)
}

func (x Open) SetSpanID(value []byte) Open {
    segment.SetBytes(x.s, 7, value)
    return x
}
func (x Open) IsSetSpanID() bool{
    return x.s.HasField(7)
}

// Metadata is the request metadata (headers).
// MetadataList returns the underlying Structs list for iteration.
// Use NewMetadata() to create items and Append to add them.
func (x Open) MetadataList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 8, XXXMappingMetadata); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 8, XXXMappingMetadata)
    return structs
}

// MetadataLen returns the number of items in the list.
func (x Open) MetadataLen(ctx context.Context) int {
    return x.MetadataList(ctx).Len()
}

// MetadataGet returns the item at the given index.
func (x Open) MetadataGet(ctx context.Context, index int) Metadata {
    s := x.MetadataList(ctx).Get(index)
    return Metadata{s: s}
}

// MetadataAppend appends items to the list.
func (x Open) MetadataAppend(ctx context.Context, values ...Metadata) {
    list := x.MetadataList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// MetadataAppendRaw appends items to the list using Raw struct representations.
func (x Open) MetadataAppendRaw(ctx context.Context, values ...*MetadataRaw) {
    list := x.MetadataList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewMetadataFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Open) IsSetMetadata() bool{
    return x.s.HasField(8)
}

// Packing indicates the client wants to use Cap'n Proto-style packing for subsequent messages.
// If true and the server agrees, all messages after OpenAck will be packed.
func (x Open) Packing() bool {
    return segment.GetBool(x.s, 9)
}

func (x Open) SetPacking(value bool) Open {
    segment.SetBool(x.s, 9, value)
    return x
}
func (x Open) IsSetPacking() bool{
    return x.s.HasField(9)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Open) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Open) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Open) XXXTypeHash() [16]byte {
    return XXXTypeHashOpen
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Open) SetRecording(enabled bool) Open {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Open) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Open) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Open) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// OpenRaw is a plain Go struct representation of Open.
// Zero values are not set (sparse encoding).
type OpenRaw struct {
    OpenID uint32
    Descr *DescrRaw
    ProtocolMajor uint8
    ProtocolMinor uint8
    DeadlineMS uint64
    MaxPayloadSize uint32
    TraceID []byte
    SpanID []byte
    Metadata []*MetadataRaw
    Packing bool
}

// NewOpenFromRaw creates a new Open from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewOpenFromRaw(ctx context.Context, raw OpenRaw) Open {
    x := NewOpen(ctx)
    if raw.OpenID != 0 {
        x.SetOpenID(raw.OpenID)
    }
    if raw.Descr != nil {
        x.SetDescr(NewDescrFromRaw(ctx, *raw.Descr))
    }
    if raw.ProtocolMajor != 0 {
        x.SetProtocolMajor(raw.ProtocolMajor)
    }
    if raw.ProtocolMinor != 0 {
        x.SetProtocolMinor(raw.ProtocolMinor)
    }
    if raw.DeadlineMS != 0 {
        x.SetDeadlineMS(raw.DeadlineMS)
    }
    if raw.MaxPayloadSize != 0 {
        x.SetMaxPayloadSize(raw.MaxPayloadSize)
    }
    if raw.TraceID != nil {
        x.SetTraceID(raw.TraceID)
    }
    if raw.SpanID != nil {
        x.SetSpanID(raw.SpanID)
    }
    if raw.Metadata != nil {
        list := x.MetadataList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Metadata))
        for _, r := range raw.Metadata {
            if r != nil {
                items = append(items, NewMetadataFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Packing {
        x.SetPacking(raw.Packing)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Open) ToRaw(ctx context.Context) OpenRaw {
    raw := OpenRaw{}
    raw.OpenID = x.OpenID()
    if x.s.HasField(1) {
        nestedRaw := x.Descr().ToRaw(ctx)
        raw.Descr = &nestedRaw
    }
    raw.ProtocolMajor = x.ProtocolMajor()
    raw.ProtocolMinor = x.ProtocolMinor()
    raw.DeadlineMS = x.DeadlineMS()
    raw.MaxPayloadSize = x.MaxPayloadSize()
    if x.s.HasField(6) {
        raw.TraceID = x.TraceID()
    }
    if x.s.HasField(7) {
        raw.SpanID = x.SpanID()
    }
    if l := x.s.GetList(8); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Metadata = make([]*MetadataRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Metadata{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Metadata[i] = &itemRaw
        }
    } else if x.s.HasField(8) {
        list := x.MetadataList(ctx)
        raw.Metadata = make([]*MetadataRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Metadata{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Metadata[i] = &itemRaw
        }
    }
    raw.Packing = x.Packing()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Open) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(6)
}

// OpenAck is the response to an Open message.
type OpenAck struct {
   s *segment.Struct
}

// NewOpenAck creates a new pooled instance of OpenAck.
// Call Release() when done to return it to the pool for reuse.
func NewOpenAck(ctx context.Context) OpenAck {
    s := segment.New(ctx, XXXMappingOpenAck)
    s.SetIsSetEnabled(true)
    return OpenAck{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x OpenAck) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewOpenAckFrom creates a new OpenAck from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewOpenAckFrom(s *segment.Struct) OpenAck {
    return OpenAck{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x OpenAck) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x OpenAck) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x OpenAck) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x OpenAck) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x OpenAck) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// OpenID is the ID of the Open message being acknowledged.
func (x OpenAck) OpenID() uint32 {
    return segment.GetUint32(x.s, 0)
}

func (x OpenAck) SetOpenID(value uint32) OpenAck {
    segment.SetUint32(x.s, 0, value)
    return x
}
func (x OpenAck) IsSetOpenID() bool{
    return x.s.HasField(0)
}

// SessionID is the ID of the session.
func (x OpenAck) SessionID() uint32 {
    return segment.GetUint32(x.s, 1)
}

func (x OpenAck) SetSessionID(value uint32) OpenAck {
    segment.SetUint32(x.s, 1, value)
    return x
}
func (x OpenAck) IsSetSessionID() bool{
    return x.s.HasField(1)
}

// ProtocolMajor is the major version of the protocol the server will use.

func (x OpenAck) ProtocolMajor() uint8 {
    return segment.GetUint8(x.s, 2)
}

func (x OpenAck) SetProtocolMajor(value uint8) OpenAck {
    segment.SetUint8(x.s, 2, value)
    return x
}
func (x OpenAck) IsSetProtocolMajor() bool{
    return x.s.HasField(2)
}

// ProtocolMinor is the minor version of the protocol the server will use.

func (x OpenAck) ProtocolMinor() uint8 {
    return segment.GetUint8(x.s, 3)
}

func (x OpenAck) SetProtocolMinor(value uint8) OpenAck {
    segment.SetUint8(x.s, 3, value)
    return x
}
func (x OpenAck) IsSetProtocolMinor() bool{
    return x.s.HasField(3)
}

// MaxPayloadSize is the maximum payload size the server will accept.
func (x OpenAck) MaxPayloadSize() uint32 {
    return segment.GetUint32(x.s, 4)
}

func (x OpenAck) SetMaxPayloadSize(value uint32) OpenAck {
    segment.SetUint32(x.s, 4, value)
    return x
}
func (x OpenAck) IsSetMaxPayloadSize() bool{
    return x.s.HasField(4)
}

// ErrCode is a code describing an error if the open was rejected. 0 indicates success.
func (x OpenAck) ErrCode() ErrCode {
    return ErrCode(segment.GetUint16(x.s, 5))
}

func (x OpenAck) SetErrCode(value ErrCode) OpenAck {
    segment.SetUint16(x.s, 5, uint16(value))
    return x
}
func (x OpenAck) IsSetErrCode() bool{
    return x.s.HasField(5)
}

// Error is an error message if the open was rejected.
func (x OpenAck) Error() string {
    return segment.GetString(x.s, 6)
}

func (x OpenAck) SetError(value string) OpenAck {
    segment.SetString(x.s, 6, value)
    return x
}
func (x OpenAck) IsSetError() bool{
    return x.s.HasField(6)
}

// Metadata is the response metadata (headers).
// MetadataList returns the underlying Structs list for iteration.
// Use NewMetadata() to create items and Append to add them.
func (x OpenAck) MetadataList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 7, XXXMappingMetadata); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 7, XXXMappingMetadata)
    return structs
}

// MetadataLen returns the number of items in the list.
func (x OpenAck) MetadataLen(ctx context.Context) int {
    return x.MetadataList(ctx).Len()
}

// MetadataGet returns the item at the given index.
func (x OpenAck) MetadataGet(ctx context.Context, index int) Metadata {
    s := x.MetadataList(ctx).Get(index)
    return Metadata{s: s}
}

// MetadataAppend appends items to the list.
func (x OpenAck) MetadataAppend(ctx context.Context, values ...Metadata) {
    list := x.MetadataList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// MetadataAppendRaw appends items to the list using Raw struct representations.
func (x OpenAck) MetadataAppendRaw(ctx context.Context, values ...*MetadataRaw) {
    list := x.MetadataList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewMetadataFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x OpenAck) IsSetMetadata() bool{
    return x.s.HasField(7)
}

// Packing indicates the server agrees to use Cap'n Proto-style packing.
// If true, all messages after this OpenAck will be packed.
func (x OpenAck) Packing() bool {
    return segment.GetBool(x.s, 8)
}

func (x OpenAck) SetPacking(value bool) OpenAck {
    segment.SetBool(x.s, 8, value)
    return x
}
func (x OpenAck) IsSetPacking() bool{
    return x.s.HasField(8)
}



// ClawStruct returns a reflection type representing the Struct.
func (x OpenAck) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x OpenAck) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x OpenAck) XXXTypeHash() [16]byte {
    return XXXTypeHashOpenAck
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x OpenAck) SetRecording(enabled bool) OpenAck {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x OpenAck) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x OpenAck) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x OpenAck) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// OpenAckRaw is a plain Go struct representation of OpenAck.
// Zero values are not set (sparse encoding).
type OpenAckRaw struct {
    OpenID uint32
    SessionID uint32
    ProtocolMajor uint8
    ProtocolMinor uint8
    MaxPayloadSize uint32
    ErrCode ErrCode
    Error string
    Metadata []*MetadataRaw
    Packing bool
}

// NewOpenAckFromRaw creates a new OpenAck from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewOpenAckFromRaw(ctx context.Context, raw OpenAckRaw) OpenAck {
    x := NewOpenAck(ctx)
    if raw.OpenID != 0 {
        x.SetOpenID(raw.OpenID)
    }
    if raw.SessionID != 0 {
        x.SetSessionID(raw.SessionID)
    }
    if raw.ProtocolMajor != 0 {
        x.SetProtocolMajor(raw.ProtocolMajor)
    }
    if raw.ProtocolMinor != 0 {
        x.SetProtocolMinor(raw.ProtocolMinor)
    }
    if raw.MaxPayloadSize != 0 {
        x.SetMaxPayloadSize(raw.MaxPayloadSize)
    }
    if raw.ErrCode != 0 {
        x.SetErrCode(raw.ErrCode)
    }
    if raw.Error != "" {
        x.SetError(raw.Error)
    }
    if raw.Metadata != nil {
        list := x.MetadataList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Metadata))
        for _, r := range raw.Metadata {
            if r != nil {
                items = append(items, NewMetadataFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Packing {
        x.SetPacking(raw.Packing)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x OpenAck) ToRaw(ctx context.Context) OpenAckRaw {
    raw := OpenAckRaw{}
    raw.OpenID = x.OpenID()
    raw.SessionID = x.SessionID()
    raw.ProtocolMajor = x.ProtocolMajor()
    raw.ProtocolMinor = x.ProtocolMinor()
    raw.MaxPayloadSize = x.MaxPayloadSize()
    raw.ErrCode = x.ErrCode()
    raw.Error = x.Error()
    if l := x.s.GetList(7); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Metadata = make([]*MetadataRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Metadata{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Metadata[i] = &itemRaw
        }
    } else if x.s.HasField(7) {
        list := x.MetadataList(ctx)
        raw.Metadata = make([]*MetadataRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Metadata{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Metadata[i] = &itemRaw
        }
    }
    raw.Packing = x.Packing()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x OpenAck) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(7)
}

// Payload is a payload message.
type Payload struct {
   s *segment.Struct
}

// NewPayload creates a new pooled instance of Payload.
// Call Release() when done to return it to the pool for reuse.
func NewPayload(ctx context.Context) Payload {
    s := segment.New(ctx, XXXMappingPayload)
    s.SetIsSetEnabled(true)
    return Payload{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Payload) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPayloadFrom creates a new Payload from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPayloadFrom(s *segment.Struct) Payload {
    return Payload{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Payload) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Payload) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Payload) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Payload) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Payload) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// SessionID is the ID of the session on this connection.
func (x Payload) SessionID() uint32 {
    return segment.GetUint32(x.s, 0)
}

func (x Payload) SetSessionID(value uint32) Payload {
    segment.SetUint32(x.s, 0, value)
    return x
}
func (x Payload) IsSetSessionID() bool{
    return x.s.HasField(0)
}

// ReqID is the ID of the request. If this is not Synchronous, this is 0.
func (x Payload) ReqID() uint32 {
    return segment.GetUint32(x.s, 1)
}

func (x Payload) SetReqID(value uint32) Payload {
    segment.SetUint32(x.s, 1, value)
    return x
}
func (x Payload) IsSetReqID() bool{
    return x.s.HasField(1)
}

// Payload is the payload of a request.
func (x Payload) Payload() []byte {
    return segment.GetBytes(x.s, 2)
}

func (x Payload) SafeGetPayload() []byte {
    return segment.GetBytesCopy(x.s, 2)
}

func (x Payload) SetPayload(value []byte) Payload {
    segment.SetBytes(x.s, 2, value)
    return x
}
func (x Payload) IsSetPayload() bool{
    return x.s.HasField(2)
}

// EndStream indicates the sender is done sending. They may still receive.
func (x Payload) EndStream() bool {
    return segment.GetBool(x.s, 3)
}

func (x Payload) SetEndStream(value bool) Payload {
    segment.SetBool(x.s, 3, value)
    return x
}
func (x Payload) IsSetEndStream() bool{
    return x.s.HasField(3)
}

// Compression indicates the compression algorithm used on the payload.
func (x Payload) Compression() Compression {
    return Compression(segment.GetUint8(x.s, 4))
}

func (x Payload) SetCompression(value Compression) Payload {
    segment.SetUint8(x.s, 4, uint8(value))
    return x
}
func (x Payload) IsSetCompression() bool{
    return x.s.HasField(4)
}

// Metadata is per-message metadata.
// MetadataList returns the underlying Structs list for iteration.
// Use NewMetadata() to create items and Append to add them.
func (x Payload) MetadataList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 5, XXXMappingMetadata); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 5, XXXMappingMetadata)
    return structs
}

// MetadataLen returns the number of items in the list.
func (x Payload) MetadataLen(ctx context.Context) int {
    return x.MetadataList(ctx).Len()
}

// MetadataGet returns the item at the given index.
func (x Payload) MetadataGet(ctx context.Context, index int) Metadata {
    s := x.MetadataList(ctx).Get(index)
    return Metadata{s: s}
}

// MetadataAppend appends items to the list.
func (x Payload) MetadataAppend(ctx context.Context, values ...Metadata) {
    list := x.MetadataList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// MetadataAppendRaw appends items to the list using Raw struct representations.
func (x Payload) MetadataAppendRaw(ctx context.Context, values ...*MetadataRaw) {
    list := x.MetadataList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewMetadataFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Payload) IsSetMetadata() bool{
    return x.s.HasField(5)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Payload) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Payload) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Payload) XXXTypeHash() [16]byte {
    return XXXTypeHashPayload
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Payload) SetRecording(enabled bool) Payload {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Payload) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Payload) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Payload) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PayloadRaw is a plain Go struct representation of Payload.
// Zero values are not set (sparse encoding).
type PayloadRaw struct {
    SessionID uint32
    ReqID uint32
    Payload []byte
    EndStream bool
    Compression Compression
    Metadata []*MetadataRaw
}

// NewPayloadFromRaw creates a new Payload from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPayloadFromRaw(ctx context.Context, raw PayloadRaw) Payload {
    x := NewPayload(ctx)
    if raw.SessionID != 0 {
        x.SetSessionID(raw.SessionID)
    }
    if raw.ReqID != 0 {
        x.SetReqID(raw.ReqID)
    }
    if raw.Payload != nil {
        x.SetPayload(raw.Payload)
    }
    if raw.EndStream {
        x.SetEndStream(raw.EndStream)
    }
    if raw.Compression != 0 {
        x.SetCompression(raw.Compression)
    }
    if raw.Metadata != nil {
        list := x.MetadataList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Metadata))
        for _, r := range raw.Metadata {
            if r != nil {
                items = append(items, NewMetadataFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Payload) ToRaw(ctx context.Context) PayloadRaw {
    raw := PayloadRaw{}
    raw.SessionID = x.SessionID()
    raw.ReqID = x.ReqID()
    if x.s.HasField(2) {
        raw.Payload = x.Payload()
    }
    raw.EndStream = x.EndStream()
    raw.Compression = x.Compression()
    if l := x.s.GetList(5); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Metadata = make([]*MetadataRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Metadata{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Metadata[i] = &itemRaw
        }
    } else if x.s.HasField(5) {
        list := x.MetadataList(ctx)
        raw.Metadata = make([]*MetadataRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Metadata{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Metadata[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Payload) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(8)
}

// Ping is a keepalive ping message.
type Ping struct {
   s *segment.Struct
}

// NewPing creates a new pooled instance of Ping.
// Call Release() when done to return it to the pool for reuse.
func NewPing(ctx context.Context) Ping {
    s := segment.New(ctx, XXXMappingPing)
    s.SetIsSetEnabled(true)
    return Ping{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Ping) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPingFrom creates a new Ping from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPingFrom(s *segment.Struct) Ping {
    return Ping{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Ping) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Ping) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Ping) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Ping) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Ping) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// ID is the ping identifier, echoed back in the Pong.
func (x Ping) ID() uint32 {
    return segment.GetUint32(x.s, 0)
}

func (x Ping) SetID(value uint32) Ping {
    segment.SetUint32(x.s, 0, value)
    return x
}
func (x Ping) IsSetID() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Ping) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Ping) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Ping) XXXTypeHash() [16]byte {
    return XXXTypeHashPing
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Ping) SetRecording(enabled bool) Ping {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Ping) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Ping) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Ping) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PingRaw is a plain Go struct representation of Ping.
// Zero values are not set (sparse encoding).
type PingRaw struct {
    ID uint32
}

// NewPingFromRaw creates a new Ping from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPingFromRaw(ctx context.Context, raw PingRaw) Ping {
    x := NewPing(ctx)
    if raw.ID != 0 {
        x.SetID(raw.ID)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Ping) ToRaw(ctx context.Context) PingRaw {
    raw := PingRaw{}
    raw.ID = x.ID()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Ping) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(9)
}

// Pong is a keepalive pong response.
type Pong struct {
   s *segment.Struct
}

// NewPong creates a new pooled instance of Pong.
// Call Release() when done to return it to the pool for reuse.
func NewPong(ctx context.Context) Pong {
    s := segment.New(ctx, XXXMappingPong)
    s.SetIsSetEnabled(true)
    return Pong{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Pong) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPongFrom creates a new Pong from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPongFrom(s *segment.Struct) Pong {
    return Pong{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Pong) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Pong) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Pong) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Pong) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Pong) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// ID is the ping identifier being responded to.
func (x Pong) ID() uint32 {
    return segment.GetUint32(x.s, 0)
}

func (x Pong) SetID(value uint32) Pong {
    segment.SetUint32(x.s, 0, value)
    return x
}
func (x Pong) IsSetID() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Pong) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Pong) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Pong) XXXTypeHash() [16]byte {
    return XXXTypeHashPong
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Pong) SetRecording(enabled bool) Pong {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Pong) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Pong) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Pong) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PongRaw is a plain Go struct representation of Pong.
// Zero values are not set (sparse encoding).
type PongRaw struct {
    ID uint32
}

// NewPongFromRaw creates a new Pong from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPongFromRaw(ctx context.Context, raw PongRaw) Pong {
    x := NewPong(ctx)
    if raw.ID != 0 {
        x.SetID(raw.ID)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Pong) ToRaw(ctx context.Context) PongRaw {
    raw := PongRaw{}
    raw.ID = x.ID()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Pong) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(10)
} 

// Everything below this line is internal details.

// Type hash constants for Any type support.
// These are SHAKE128 hashes (128 bits) of the full type path + name.
// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashCancel = [16]byte{0x27, 0x12, 0x10, 0x3f, 0x41, 0x01, 0xe8, 0x81, 0x86, 0xd8, 0x1d, 0xfc, 0xb1, 0x87, 0x20, 0x54}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashClose = [16]byte{0xb9, 0x61, 0xf8, 0x04, 0x52, 0x84, 0x74, 0xf2, 0xc1, 0x2f, 0x9d, 0xfe, 0x3e, 0x15, 0x15, 0xb0}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashDescr = [16]byte{0x4a, 0x9e, 0x2f, 0x67, 0x2f, 0x29, 0xef, 0x42, 0x9b, 0x26, 0x35, 0xc5, 0x14, 0xe2, 0x30, 0x62}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashGoAway = [16]byte{0x16, 0x28, 0xae, 0x65, 0xf8, 0x90, 0xad, 0x02, 0x3b, 0xa0, 0x67, 0x56, 0x53, 0x99, 0xbf, 0xb3}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashMetadata = [16]byte{0x73, 0x78, 0xa0, 0x60, 0x33, 0x08, 0x4a, 0xd7, 0x24, 0xb4, 0x1b, 0x0c, 0xe5, 0x4a, 0x30, 0xee}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashMsg = [16]byte{0x2d, 0x16, 0x41, 0x75, 0x5d, 0xba, 0x40, 0xd8, 0xa0, 0xea, 0xba, 0x24, 0xb7, 0x91, 0x6b, 0x22}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashOpen = [16]byte{0xb6, 0x42, 0xcb, 0x81, 0xa4, 0x95, 0xd4, 0xbe, 0x31, 0x5a, 0x6c, 0xce, 0x2c, 0xda, 0xe4, 0xc7}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashOpenAck = [16]byte{0xb5, 0x8a, 0x70, 0xf7, 0xda, 0x02, 0x72, 0x09, 0x87, 0x8e, 0xb7, 0x85, 0x17, 0x16, 0xa1, 0x6e}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPayload = [16]byte{0x72, 0xd1, 0x6c, 0x82, 0x0d, 0xa5, 0x68, 0x94, 0xbb, 0x43, 0x80, 0xcf, 0x25, 0x86, 0x3e, 0x65}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPing = [16]byte{0xd0, 0xc8, 0xe7, 0x22, 0xba, 0x81, 0x4c, 0x70, 0x0b, 0xe6, 0xbb, 0xed, 0x20, 0xae, 0x86, 0x28}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPong = [16]byte{0x4d, 0x17, 0xb1, 0xaa, 0xe1, 0x1a, 0xa8, 0x2b, 0x21, 0xd8, 0xd3, 0xeb, 0x7a, 0xe9, 0xed, 0x7c}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingCancel = &mapping.Map{
    Name: "Cancel",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "SessionID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReqID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingClose = &mapping.Map{
    Name: "Close",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "SessionID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ErrCode",
            Type: field.FTUint16,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "ErrCode",
        },
        {
            Name: "Error",
            Type: field.FTString,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Metadata",
            Type: field.FTListStructs,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "Metadata",
            
            Mapping: XXXMappingMetadata,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingDescr = &mapping.Map{
    Name: "Descr",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Package",
            Type: field.FTString,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Service",
            Type: field.FTString,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Call",
            Type: field.FTString,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Type",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 3,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "RPCType",
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingGoAway = &mapping.Map{
    Name: "GoAway",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "LastSessionID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ErrCode",
            Type: field.FTUint16,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "ErrCode",
        },
        {
            Name: "DebugData",
            Type: field.FTString,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingMetadata = &mapping.Map{
    Name: "Metadata",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Key",
            Type: field.FTString,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Value",
            Type: field.FTBytes,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingMsg = &mapping.Map{
    Name: "Msg",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Type",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "MsgType",
        },
        {
            Name: "Open",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "Open",
            
            Mapping: XXXMappingOpen,
        },
        {
            Name: "OpenAck",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "OpenAck",
            
            Mapping: XXXMappingOpenAck,
        },
        {
            Name: "Close",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "Close",
            
            Mapping: XXXMappingClose,
        },
        {
            Name: "Payload",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
            StructName: "Payload",
            
            Mapping: XXXMappingPayload,
        },
        {
            Name: "Cancel",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
            StructName: "Cancel",
            
            Mapping: XXXMappingCancel,
        },
        {
            Name: "Ping",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
            StructName: "Ping",
            
            Mapping: XXXMappingPing,
        },
        {
            Name: "Pong",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
            StructName: "Pong",
            
            Mapping: XXXMappingPong,
        },
        {
            Name: "GoAway",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "GoAway",
            
            Mapping: XXXMappingGoAway,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingOpen = &mapping.Map{
    Name: "Open",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "OpenID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Descr",
            Type: field.FTStruct,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "Descr",
            
            Mapping: XXXMappingDescr,
        },
        {
            Name: "ProtocolMajor",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ProtocolMinor",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "DeadlineMS",
            Type: field.FTUint64,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "MaxPayloadSize",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "TraceID",
            Type: field.FTBytes,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SpanID",
            Type: field.FTBytes,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Metadata",
            Type: field.FTListStructs,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "Metadata",
            
            Mapping: XXXMappingMetadata,
        },
        {
            Name: "Packing",
            Type: field.FTBool,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 9,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingOpenAck = &mapping.Map{
    Name: "OpenAck",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "OpenID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SessionID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ProtocolMajor",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ProtocolMinor",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "MaxPayloadSize",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ErrCode",
            Type: field.FTUint16,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 5,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "ErrCode",
        },
        {
            Name: "Error",
            Type: field.FTString,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Metadata",
            Type: field.FTListStructs,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
            StructName: "Metadata",
            
            Mapping: XXXMappingMetadata,
        },
        {
            Name: "Packing",
            Type: field.FTBool,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPayload = &mapping.Map{
    Name: "Payload",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "SessionID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReqID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Payload",
            Type: field.FTBytes,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "EndStream",
            Type: field.FTBool,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Compression",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 4,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "Compression",
        },
        {
            Name: "Metadata",
            Type: field.FTListStructs,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
            StructName: "Metadata",
            
            Mapping: XXXMappingMetadata,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPing = &mapping.Map{
    Name: "Ping",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPong = &mapping.Map{
    Name: "Pong",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ID",
            Type: field.FTUint32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}


// init initializes all mapping function pointer tables for O(1) dispatch.
func init() {
    XXXMappingCancel.Init()
    XXXMappingClose.Init()
    XXXMappingDescr.Init()
    XXXMappingGoAway.Init()
    XXXMappingMetadata.Init()
    XXXMappingMsg.Init()
    XXXMappingOpen.Init()
    XXXMappingOpenAck.Init()
    XXXMappingPayload.Init()
    XXXMappingPing.Init()
    XXXMappingPong.Init()
}




var XXXEnumGroupCompression = reflect.XXXEnumGroupImpl{
    GroupName: "Compression",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "CmpNone",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "CmpGzip",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "CmpSnappy",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "CmpZstd",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupErrCode = reflect.XXXEnumGroupImpl{
    GroupName: "ErrCode",
    GroupLen: 17,
    EnumSize: 16,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrNone",
            EnumNumber: 0,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrCanceled",
            EnumNumber: 1,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrReserved",
            EnumNumber: 2,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrInvalidArgument",
            EnumNumber: 3,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrDeadlineExceeded",
            EnumNumber: 4,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrNotFound",
            EnumNumber: 5,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrAlreadyExists",
            EnumNumber: 6,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrPermissionDenied",
            EnumNumber: 7,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrResourceExhausted",
            EnumNumber: 8,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrFailedPrecondition",
            EnumNumber: 9,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrAborted",
            EnumNumber: 10,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrOutOfRange",
            EnumNumber: 11,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrUnimplemented",
            EnumNumber: 12,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrInternal",
            EnumNumber: 13,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrUnavailable",
            EnumNumber: 14,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrDataLoss",
            EnumNumber: 15,
            EnumSize: 16,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ErrUnauthenticated",
            EnumNumber: 16,
            EnumSize: 16,
        },
    },
}

var XXXEnumGroupMsgType = reflect.XXXEnumGroupImpl{
    GroupName: "MsgType",
    GroupLen: 9,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TUnknown",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TOpen",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TOpenAck",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TClose",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TPayload",
            EnumNumber: 4,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TCancel",
            EnumNumber: 5,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TPing",
            EnumNumber: 6,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TPong",
            EnumNumber: 7,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TGoAway",
            EnumNumber: 8,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupRPCType = reflect.XXXEnumGroupImpl{
    GroupName: "RPCType",
    GroupLen: 5,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RTUnknown",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RTSynchronous",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RTSend",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RTRecv",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RTBiDirectional",
            EnumNumber: 4,
            EnumSize: 8,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXEnumGroups reflect.EnumGroups = reflect.XXXEnumGroupsImpl{
    List:   []reflect.EnumGroup{
        XXXEnumGroupCompression,
        XXXEnumGroupErrCode,
        XXXEnumGroupMsgType,
        XXXEnumGroupRPCType,
    },
    Lookup: map[string]reflect.EnumGroup{
        "Compression": XXXEnumGroupCompression,
        "ErrCode": XXXEnumGroupErrCode,
        "MsgType": XXXEnumGroupMsgType,
        "RPCType": XXXEnumGroupRPCType,
    },
}
 


var XXXStructDescrCancel = &reflect.XXXStructDescrImpl{
    Name:      "Cancel",
    Pkg:       XXXMappingCancel.Pkg,
    Path:      XXXMappingCancel.Path,
    Mapping:   XXXMappingCancel,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCancel.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCancel.Fields[1],  
        },  
    },
}

var XXXStructDescrClose = &reflect.XXXStructDescrImpl{
    Name:      "Close",
    Pkg:       XXXMappingClose.Pkg,
    Path:      XXXMappingClose.Path,
    Mapping:   XXXMappingClose,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClose.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClose.Fields[1],
            EG: XXXEnumGroupErrCode, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClose.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClose.Fields[3],
            SD: XXXStructDescrMetadata,  
        },  
    },
}

var XXXStructDescrDescr = &reflect.XXXStructDescrImpl{
    Name:      "Descr",
    Pkg:       XXXMappingDescr.Pkg,
    Path:      XXXMappingDescr.Path,
    Mapping:   XXXMappingDescr,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDescr.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDescr.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDescr.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDescr.Fields[3],
            EG: XXXEnumGroupRPCType, 
        },  
    },
}

var XXXStructDescrGoAway = &reflect.XXXStructDescrImpl{
    Name:      "GoAway",
    Pkg:       XXXMappingGoAway.Pkg,
    Path:      XXXMappingGoAway.Path,
    Mapping:   XXXMappingGoAway,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGoAway.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGoAway.Fields[1],
            EG: XXXEnumGroupErrCode, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGoAway.Fields[2],  
        },  
    },
}

var XXXStructDescrMetadata = &reflect.XXXStructDescrImpl{
    Name:      "Metadata",
    Pkg:       XXXMappingMetadata.Pkg,
    Path:      XXXMappingMetadata.Path,
    Mapping:   XXXMappingMetadata,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMetadata.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMetadata.Fields[1],  
        },  
    },
}

var XXXStructDescrMsg = &reflect.XXXStructDescrImpl{
    Name:      "Msg",
    Pkg:       XXXMappingMsg.Pkg,
    Path:      XXXMappingMsg.Path,
    Mapping:   XXXMappingMsg,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[0],
            EG: XXXEnumGroupMsgType, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[1],
            SD: XXXStructDescrOpen,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[2],
            SD: XXXStructDescrOpenAck,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[3],
            SD: XXXStructDescrClose,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[4],
            SD: XXXStructDescrPayload,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[5],
            SD: XXXStructDescrCancel,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[6],
            SD: XXXStructDescrPing,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[7],
            SD: XXXStructDescrPong,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingMsg.Fields[8],
            SD: XXXStructDescrGoAway,  
        },  
    },
}

var XXXStructDescrOpen = &reflect.XXXStructDescrImpl{
    Name:      "Open",
    Pkg:       XXXMappingOpen.Pkg,
    Path:      XXXMappingOpen.Path,
    Mapping:   XXXMappingOpen,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[1],
            SD: XXXStructDescrDescr,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[6],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[7],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[8],
            SD: XXXStructDescrMetadata,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpen.Fields[9],  
        },  
    },
}

var XXXStructDescrOpenAck = &reflect.XXXStructDescrImpl{
    Name:      "OpenAck",
    Pkg:       XXXMappingOpenAck.Pkg,
    Path:      XXXMappingOpenAck.Path,
    Mapping:   XXXMappingOpenAck,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[5],
            EG: XXXEnumGroupErrCode, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[6],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[7],
            SD: XXXStructDescrMetadata,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOpenAck.Fields[8],  
        },  
    },
}

var XXXStructDescrPayload = &reflect.XXXStructDescrImpl{
    Name:      "Payload",
    Pkg:       XXXMappingPayload.Pkg,
    Path:      XXXMappingPayload.Path,
    Mapping:   XXXMappingPayload,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPayload.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPayload.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPayload.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPayload.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPayload.Fields[4],
            EG: XXXEnumGroupCompression, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPayload.Fields[5],
            SD: XXXStructDescrMetadata,  
        },  
    },
}

var XXXStructDescrPing = &reflect.XXXStructDescrImpl{
    Name:      "Ping",
    Pkg:       XXXMappingPing.Pkg,
    Path:      XXXMappingPing.Path,
    Mapping:   XXXMappingPing,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPing.Fields[0],  
        },  
    },
}

var XXXStructDescrPong = &reflect.XXXStructDescrImpl{
    Name:      "Pong",
    Pkg:       XXXMappingPong.Pkg,
    Path:      XXXMappingPong.Path,
    Mapping:   XXXMappingPong,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPong.Fields[0],  
        },  
    },
}

var XXXStructDescrs = map[string]*reflect.XXXStructDescrImpl{
    "Cancel":  XXXStructDescrCancel,
    "Close":  XXXStructDescrClose,
    "Descr":  XXXStructDescrDescr,
    "GoAway":  XXXStructDescrGoAway,
    "Metadata":  XXXStructDescrMetadata,
    "Msg":  XXXStructDescrMsg,
    "Open":  XXXStructDescrOpen,
    "OpenAck":  XXXStructDescrOpenAck,
    "Payload":  XXXStructDescrPayload,
    "Ping":  XXXStructDescrPing,
    "Pong":  XXXStructDescrPong,
}

// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
var XXXPackageDescr reflect.PackageDescr = &reflect.XXXPackageDescrImpl{
    Name: "msgs",
    Path: "github.com/bearlytools/claw/rpc/internal/msgs",
    EnumGroupsDescrs: XXXEnumGroups,
    StructsDescrs: reflect.XXXStructDescrsImpl{
        Descrs: []reflect.StructDescr{
            XXXStructDescrCancel,
            XXXStructDescrClose,
            XXXStructDescrDescr,
            XXXStructDescrGoAway,
            XXXStructDescrMetadata,
            XXXStructDescrMsg,
            XXXStructDescrOpen,
            XXXStructDescrOpenAck,
            XXXStructDescrPayload,
            XXXStructDescrPing,
            XXXStructDescrPong,
        },
    },
}

// PackageDescr returns a PackageDescr for this package.
func PackageDescr() reflect.PackageDescr {
    return XXXPackageDescr
}

// Registers our package description with the runtime.
func init() {
    runtime.RegisterPackage(XXXPackageDescr)

    // Register each struct type by its hash for Any field decoding.
    runtime.RegisterTypeHash(XXXTypeHashCancel, runtime.TypeEntry{
        Name:     "Cancel",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewCancel(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashClose, runtime.TypeEntry{
        Name:     "Close",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewClose(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashDescr, runtime.TypeEntry{
        Name:     "Descr",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewDescr(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashGoAway, runtime.TypeEntry{
        Name:     "GoAway",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewGoAway(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashMetadata, runtime.TypeEntry{
        Name:     "Metadata",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewMetadata(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashMsg, runtime.TypeEntry{
        Name:     "Msg",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewMsg(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashOpen, runtime.TypeEntry{
        Name:     "Open",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewOpen(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashOpenAck, runtime.TypeEntry{
        Name:     "OpenAck",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewOpenAck(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPayload, runtime.TypeEntry{
        Name:     "Payload",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPayload(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPing, runtime.TypeEntry{
        Name:     "Ping",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPing(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPong, runtime.TypeEntry{
        Name:     "Pong",
        FullPath: "github.com/bearlytools/claw/rpc/internal/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPong(ctx)
        },
    })
}
