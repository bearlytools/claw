// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

// Package msgs
package msgs

import (
    "context"
    "io"
    "bytes"
    "fmt"

    "github.com/bearlytools/claw/clawc/languages/go/mapping"
    "github.com/bearlytools/claw/languages/go/reflect"
    "github.com/bearlytools/claw/languages/go/reflect/runtime"
    "github.com/bearlytools/claw/clawc/languages/go/segment"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
)

// Ensure imports are used.
var (
    _ context.Context
    _ = io.EOF
    _ = bytes.MinRead
    _ = fmt.Errorf
    _ mapping.Map
    _ reflect.StructDescr
    _ = runtime.RegisterPackage
    _ segment.Struct
    _ = field.FTBool
)

// SyntaxVersion is the major version of the Claw language that is being rendered.
const SyntaxVersion = 0

var _package = "msgs"
var _packagePath = "github.com/bearlytools/claw/languages/go/patch/msgs"


// OpType defines the type of patch operation.
type OpType uint8

// String implements fmt.Stringer.
func (x OpType) String() string {
    return OpTypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x OpType) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(0)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x OpType) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(0).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum OpType.
const (
    // Unknown is invalid.
    Unknown OpType = 0
    // Set sets a scalar/bytes/string field to a new value.
    Set OpType = 1
    // Clear clears a field (sets to zero value).
    Clear OpType = 2
    // StructPatch applies a nested patch to a struct field.
    StructPatch OpType = 3
    // ListReplace replaces an entire list.
    ListReplace OpType = 4
    // ListSet sets a value at a specific index.
    ListSet OpType = 5
    // ListInsert inserts a value at a specific index.
    ListInsert OpType = 6
    // ListRemove removes a value at a specific index.
    ListRemove OpType = 7
    // ListStructPatch applies a patch to a struct at a list index.
    ListStructPatch OpType = 8
)

// OpTypeByName converts a string representing the enumerator into a OpType.
var OpTypeByName = map[string]OpType{
    "Clear": 2,
    "ListInsert": 6,
    "ListRemove": 7,
    "ListReplace": 4,
    "ListSet": 5,
    "ListStructPatch": 8,
    "Set": 1,
    "StructPatch": 3,
    "Unknown": 0,
}

// OpTypeByValue converts a uint8 representing a OpType into its string name.
var OpTypeByValue = map[uint8]string{
    0: "Unknown",
    1: "Set",
    2: "Clear",
    3: "StructPatch",
    4: "ListReplace",
    5: "ListSet",
    6: "ListInsert",
    7: "ListRemove",
    8: "ListStructPatch",
}


// Op is a single patch operation.
type Op struct {
   s *segment.Struct
}

// NewOp creates a new pooled instance of Op.
// Call Release() when done to return it to the pool for reuse.
func NewOp(ctx context.Context) Op {
    s := segment.New(ctx, XXXMappingOp)
    return Op{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Op) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewOpFrom creates a new Op from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewOpFrom(s *segment.Struct) Op {
    return Op{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Op) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Op) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Op) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Op) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Op) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// FieldNum is the field number this operation applies to.

func (x Op) FieldNum() uint16 {
    return segment.GetUint16(x.s, 0)
}

func (x Op) SetFieldNum(value uint16) Op {
    segment.SetUint16(x.s, 0, value)
    return x
}

// Type is the operation type.
func (x Op) Type() OpType {
    return OpType(segment.GetUint8(x.s, 1))
}

func (x Op) SetType(value OpType) Op {
    segment.SetUint8(x.s, 1, uint8(value))
    return x
}

// Index is the list index (for list operations, -1 otherwise).
func (x Op) Index() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x Op) SetIndex(value int32) Op {
    segment.SetInt32(x.s, 2, value)
    return x
}

// Data is the encoded payload (value, nested patch, etc.).
func (x Op) Data() []byte {
    return segment.GetBytes(x.s, 3)
}

func (x Op) SafeGetData() []byte {
    return segment.GetBytesCopy(x.s, 3)
}

func (x Op) SetData(value []byte) Op {
    segment.SetBytes(x.s, 3, value)
    return x
}



// ClawStruct returns a reflection type representing the Struct.
func (x Op) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Op) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Op) XXXTypeHash() [16]byte {
    return XXXTypeHashOp
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Op) SetRecording(enabled bool) Op {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Op) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Op) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Op) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// OpRaw is a plain Go struct representation of Op.
// Zero values are not set (sparse encoding).
type OpRaw struct {
    FieldNum uint16
    Type OpType
    Index int32
    Data []byte
}

// NewOpFromRaw creates a new Op from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewOpFromRaw(ctx context.Context, raw OpRaw) Op {
    x := NewOp(ctx)
    if raw.FieldNum != 0 {
        x.SetFieldNum(raw.FieldNum)
    }
    if raw.Type != 0 {
        x.SetType(raw.Type)
    }
    if raw.Index != 0 {
        x.SetIndex(raw.Index)
    }
    if raw.Data != nil {
        x.SetData(raw.Data)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Op) ToRaw(ctx context.Context) OpRaw {
    raw := OpRaw{}
    raw.FieldNum = x.FieldNum()
    raw.Type = x.Type()
    raw.Index = x.Index()
    if x.s.HasField(3) {
        raw.Data = x.Data()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Op) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(0)
}

// Patch represents a diff between two structs.
type Patch struct {
   s *segment.Struct
}

// NewPatch creates a new pooled instance of Patch.
// Call Release() when done to return it to the pool for reuse.
func NewPatch(ctx context.Context) Patch {
    s := segment.New(ctx, XXXMappingPatch)
    return Patch{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Patch) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPatchFrom creates a new Patch from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPatchFrom(s *segment.Struct) Patch {
    return Patch{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Patch) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Patch) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Patch) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Patch) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Patch) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// Version is the patch format version.

func (x Patch) Version() uint8 {
    return segment.GetUint8(x.s, 0)
}

func (x Patch) SetVersion(value uint8) Patch {
    segment.SetUint8(x.s, 0, value)
    return x
}

// Ops is the list of operations to apply.
// OpsList returns the underlying Structs list for iteration.
// Use NewOp() to create items and Append to add them.
func (x Patch) OpsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingOp); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingOp)
    return structs
}

// OpsLen returns the number of items in the list.
func (x Patch) OpsLen(ctx context.Context) int {
    return x.OpsList(ctx).Len()
}

// OpsGet returns the item at the given index.
func (x Patch) OpsGet(ctx context.Context, index int) Op {
    s := x.OpsList(ctx).Get(index)
    return Op{s: s}
}

// OpsAppend appends items to the list.
func (x Patch) OpsAppend(ctx context.Context, values ...Op) {
    list := x.OpsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// OpsAppendRaw appends items to the list using Raw struct representations.
func (x Patch) OpsAppendRaw(ctx context.Context, values ...*OpRaw) {
    list := x.OpsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewOpFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}



// ClawStruct returns a reflection type representing the Struct.
func (x Patch) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Patch) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Patch) XXXTypeHash() [16]byte {
    return XXXTypeHashPatch
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Patch) SetRecording(enabled bool) Patch {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Patch) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Patch) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Patch) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PatchRaw is a plain Go struct representation of Patch.
// Zero values are not set (sparse encoding).
type PatchRaw struct {
    Version uint8
    Ops []*OpRaw
}

// NewPatchFromRaw creates a new Patch from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPatchFromRaw(ctx context.Context, raw PatchRaw) Patch {
    x := NewPatch(ctx)
    if raw.Version != 0 {
        x.SetVersion(raw.Version)
    }
    if raw.Ops != nil {
        list := x.OpsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Ops))
        for _, r := range raw.Ops {
            if r != nil {
                items = append(items, NewOpFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Patch) ToRaw(ctx context.Context) PatchRaw {
    raw := PatchRaw{}
    raw.Version = x.Version()
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Ops = make([]*OpRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Op{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Ops[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.OpsList(ctx)
        raw.Ops = make([]*OpRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Op{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Ops[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Patch) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(1)
} 

// Everything below this line is internal details.

// Type hash constants for Any type support.
// These are SHAKE128 hashes (128 bits) of the full type path + name.
// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashOp = [16]byte{0xb8, 0xa7, 0x0b, 0xdb, 0xd6, 0x8a, 0xc3, 0xe3, 0xd5, 0x8c, 0x75, 0x1d, 0x5c, 0xa3, 0x4e, 0xf7}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPatch = [16]byte{0x0e, 0xcb, 0x47, 0x08, 0xfe, 0x68, 0x87, 0x65, 0x40, 0xbb, 0xde, 0x43, 0x53, 0x1c, 0x00, 0xc7}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingOp = &mapping.Map{
    Name: "Op",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/languages/go/patch/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "FieldNum",
            Type: field.FTUint16,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/languages/go/patch/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Type",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/languages/go/patch/msgs",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "OpType",
        },
        {
            Name: "Index",
            Type: field.FTInt32,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/languages/go/patch/msgs",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Data",
            Type: field.FTBytes,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/languages/go/patch/msgs",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPatch = &mapping.Map{
    Name: "Patch",
    Pkg: "msgs",
    Path: "github.com/bearlytools/claw/languages/go/patch/msgs",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Version",
            Type: field.FTUint8,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/languages/go/patch/msgs",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Ops",
            Type: field.FTListStructs,
            Package: "msgs",
            FullPath: "github.com/bearlytools/claw/languages/go/patch/msgs",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "Op",
            
            Mapping: XXXMappingOp,
        },
    },
}


// init initializes all mapping function pointer tables for O(1) dispatch.
func init() {
    XXXMappingOp.Init()
    XXXMappingPatch.Init()
}




var XXXEnumGroupOpType = reflect.XXXEnumGroupImpl{
    GroupName: "OpType",
    GroupLen: 9,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "Unknown",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "Set",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "Clear",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "StructPatch",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ListReplace",
            EnumNumber: 4,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ListSet",
            EnumNumber: 5,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ListInsert",
            EnumNumber: 6,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ListRemove",
            EnumNumber: 7,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ListStructPatch",
            EnumNumber: 8,
            EnumSize: 8,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXEnumGroups reflect.EnumGroups = reflect.XXXEnumGroupsImpl{
    List:   []reflect.EnumGroup{
        XXXEnumGroupOpType,
    },
    Lookup: map[string]reflect.EnumGroup{
        "OpType": XXXEnumGroupOpType,
    },
}
 


var XXXStructDescrOp = &reflect.XXXStructDescrImpl{
    Name:      "Op",
    Pkg:       XXXMappingOp.Pkg,
    Path:      XXXMappingOp.Path,
    Mapping:   XXXMappingOp,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOp.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOp.Fields[1],
            EG: XXXEnumGroupOpType, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOp.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOp.Fields[3],  
        },  
    },
}

var XXXStructDescrPatch = &reflect.XXXStructDescrImpl{
    Name:      "Patch",
    Pkg:       XXXMappingPatch.Pkg,
    Path:      XXXMappingPatch.Path,
    Mapping:   XXXMappingPatch,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPatch.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPatch.Fields[1],
            SD: XXXStructDescrOp,  
        },  
    },
}

var XXXStructDescrs = map[string]*reflect.XXXStructDescrImpl{
    "Op":  XXXStructDescrOp,
    "Patch":  XXXStructDescrPatch,
}

// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
var XXXPackageDescr reflect.PackageDescr = &reflect.XXXPackageDescrImpl{
    Name: "msgs",
    Path: "github.com/bearlytools/claw/languages/go/patch/msgs",
    EnumGroupsDescrs: XXXEnumGroups,
    StructsDescrs: reflect.XXXStructDescrsImpl{
        Descrs: []reflect.StructDescr{
            XXXStructDescrOp,
            XXXStructDescrPatch,
        },
    },
}

// PackageDescr returns a PackageDescr for this package.
func PackageDescr() reflect.PackageDescr {
    return XXXPackageDescr
}

// Registers our package description with the runtime.
func init() {
    runtime.RegisterPackage(XXXPackageDescr)

    // Register each struct type by its hash for Any field decoding.
    runtime.RegisterTypeHash(XXXTypeHashOp, runtime.TypeEntry{
        Name:     "Op",
        FullPath: "github.com/bearlytools/claw/languages/go/patch/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewOp(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPatch, runtime.TypeEntry{
        Name:     "Patch",
        FullPath: "github.com/bearlytools/claw/languages/go/patch/msgs",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPatch(ctx)
        },
    })
}
