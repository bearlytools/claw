# Claw Compilation process

## Introduction

This document gives an overview of the `clawc` compilation process. This is mean as a guide to understanding how `clawc` works and what it does during this process. 

This is an overview, not a flowchart. Error flows are not detailed, as an error at any stage simply stops the process and exits.

The main thing to understand is the compilation of `.claw` files that are imported from other repos is completely isolated to your local repo. While the `.claw` files will be download from the repos, none of the language specific files are used. Based on the `.claw` files, all compilations to language specific files are put in the local repository. 

This keeps differences in `clawc` version internals from having any incompatibility effects on the language specific files generated in another repo. These files are always rendered locally in a location designated by the `claw.imports` file.  This means all files are always generated by the same `clawc` compiler.

For clarification, if:
* Repo root is `github.com/example/repo`
* `claw.imports` `directive` points at `github.com/example/repo/clawimports`
* `clawc` is invoked on `cars.claw` file at `github.com/example/repo/dir/cars`
* `cars.claw` imports `github.com/vehicles/makes`
* `github.com/vehicles/makes` language compilations will be located at `github.com/example/repo/clawimports/github.com/vehicles/makes`

## Process

Claw compilation is done using the `clawc` binary. To use `clawc`, you invoke clawc in a directory containing a `.claw` and `claw.mod` file and optional `local.replace` and `global.replace` file.

### Step 1
`clawc` parses the `claw.mod` file. 

### Step 2
`clawc` does discovery on its current git repo setup. Currently, `clawc` only works if in a public git repo. This will change in future.

### Step 3
`clawc` parses the `claw.mod` file to undertand the full package path.

### Step 4
`clawc` parses the `.claw` file to discover all imports and then constructs partial representations in memory for every file.

Partial, as at this stage we can only detail information about types that are define in our file. External types (types defined in packages that are imported) cannot be rendered until we have parsed those file's local types.

### Step 5
`clawc` loops through all imports.

If the import is in the same git repostiory, it finds it in the local copy.

If the import is in another repository, it fetches that repo into a temporary caching location and begins parsing the `.claw` and `claw.mod` files. Unless, there is a `local.replace` that lists that repo in our root directory, in which case we look at that location on disk.

If the repo lists a `global.replace` file, we fetch where the `global.replace` points. There is a limit to how many redirects allowd.

If the remote `claw.mod` doesn't have an open ACL, or list our root `claw.mod` path, this stops.

Otherwise, for each imported file we repeat `Step 4` and `Step 5` until we have parsed the entire import tree. 

During each stage, we use the eBGP (network protocol) loop prevention mechanism applied to import paths to prevent import loops.

### Step 6
With the inmemory representations of each file in memory, we go through each representation and updated it to have information about the external types.

### Step 7
We try to locate the `claw.imports` file at the root of our repo. If it is not there, we search down from the root to our directory. If not found, we error.

If the directive doesn't point at a location that is in the current repo, we error.

### Step 8
In this stage we write out our language specific representations.  The root package is written to our invocation directory for each language that was to be rendered.

For each of our imports:
* If the import is in the local git repo, we write the language specific versions to its directory.
* Otherwise we write out our language files inside the `claw.imports` directive location creating directories that match the full package path of the import.

### Completed
This completes a clawc compilation.

