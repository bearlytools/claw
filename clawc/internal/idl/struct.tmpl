{{- $isSetEnabled := false }}
{{- if .File.Options.IsSet }}
{{- $isSetEnabled = true }}
{{- end }}
{{- if .Comment }}
// {{ .Comment }}
{{- end }}
type {{ .Name }} struct {
   s *segment.Struct
}

// New{{ .Name }} creates a new pooled instance of {{ .Name }}.
// Call Release() when done to return it to the pool for reuse.
func New{{ .Name }}(ctx context.Context) {{ .Name }} {
    s := segment.New(ctx, XXXMapping{{ .Name }})
    {{- if $isSetEnabled }}
    s.SetIsSetEnabled(true)
    {{- end }}
    return {{ .Name }}{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x {{ .Name }}) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNew{{ .Name }}From creates a new {{ .Name }} from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNew{{ .Name }}From(s *segment.Struct) {{ .Name }} {
    return {{ .Name }}{s: s}
}

{{- $struct := . }}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x {{ $struct.Name }}) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x {{ $struct.Name }}) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x {{ $struct.Name }}) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x {{ $struct.Name }}) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x {{ $struct.Name }}) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

{{ range $index, $field := .Fields }}
{{- if eq $field.TypeAsString "Bool" }}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() bool {
    return segment.GetBool(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value bool) {{ $struct.Name }} {
    segment.SetBool(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Int8" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() int8 {
    return segment.GetInt8(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value int8) {{ $struct.Name }} {
    segment.SetInt8(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ .Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Int16" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() int16 {
    return segment.GetInt16(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value int16) {{ $struct.Name }} {
    segment.SetInt16(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Int32" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() int32 {
    return segment.GetInt32(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value int32) {{ $struct.Name }} {
    segment.SetInt32(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Int64" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() int64 {
    return segment.GetInt64(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value int64) {{ $struct.Name }} {
    segment.SetInt64(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Uint8" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
{{- if $field.IdentName -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() {{ $field.IdentName }} {
    return {{ $field.IdentName }}(segment.GetUint8(x.s, {{ $field.Index }}))
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value {{ $field.IdentName }}) {{ $struct.Name }} {
    segment.SetUint8(x.s, {{ $field.Index }}, uint8(value))
    return x
}
{{- else }}
func (x {{ $struct.Name }}) {{ $field.Name }}() uint8 {
    return segment.GetUint8(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value uint8) {{ $struct.Name }} {
    segment.SetUint8(x.s, {{ $field.Index }}, value)
    return x
}
{{- end }}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Uint16" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
{{- if $field.IdentName -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() {{ $field.IdentName }} {
    return {{ $field.IdentName }}(segment.GetUint16(x.s, {{ $field.Index }}))
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value {{ $field.IdentName }}) {{ $struct.Name }} {
    segment.SetUint16(x.s, {{ $field.Index }}, uint16(value))
    return x
}
{{- else }}
func (x {{ $struct.Name }}) {{ $field.Name }}() uint16 {
    return segment.GetUint16(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value uint16) {{ $struct.Name }} {
    segment.SetUint16(x.s, {{ $field.Index }}, value)
    return x
}
{{- end }}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Uint32" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() uint32 {
    return segment.GetUint32(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value uint32) {{ $struct.Name }} {
    segment.SetUint32(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Uint64" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() uint64 {
    return segment.GetUint64(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value uint64) {{ $struct.Name }} {
    segment.SetUint64(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Float32" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() float32 {
    return segment.GetFloat32(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value float32) {{ $struct.Name }} {
    segment.SetFloat32(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Float64" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() float64 {
    return segment.GetFloat64(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value float64) {{ $struct.Name }} {
    segment.SetFloat64(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "String" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() string {
    return segment.GetString(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value string) {{ $struct.Name }} {
    segment.SetString(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Bytes" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() []byte {
    return segment.GetBytes(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) SafeGet{{ $field.Name }}() []byte {
    return segment.GetBytesCopy(x.s, {{ $field.Index }})
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value []byte) {{ $struct.Name }} {
    segment.SetBytes(x.s, {{ $field.Index }}, value)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Struct" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() {{ $field.IdentName }} {
    {{- if $field.IsExternal }}
    s := segment.GetNestedStruct(x.s, {{ $field.Index }}, {{ $field.Package }}.XXXMapping{{ $field.IdentInFile }})
    return {{ $field.Package }}.XXXNew{{ $field.IdentInFile }}From(s)
    {{- else }}
    s := segment.GetNestedStruct(x.s, {{ $field.Index }}, XXXMapping{{ $field.IdentInFile }})
    return {{ $field.IdentName }}{s: s}
    {{- end }}
}

func (x {{ $struct.Name }}) Set{{ $field.Name }}(value {{ $field.IdentName }}) {{ $struct.Name }} {
    segment.SetNestedStruct(x.s, {{ $field.Index }}, value.XXXGetStruct())
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "ListBools" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() *segment.Bools {
    // Try to get cached or parse from segment
    if bools := segment.GetListBools(x.s, {{ $field.Index }}); bools != nil {
        return bools
    }
    // Create new empty list if no data exists
    bools := segment.NewBools(x.s, {{ $field.Index }})
    return bools
}

// Set{{ $field.Name }} replaces all values in the bool list.
func (x {{ $struct.Name }}) Set{{ $field.Name }}(v ...bool) {{ $struct.Name }} {
    bools := x.{{ $field.Name }}()
    bools.SetAll(v)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "ListUint8" "ListUint16" "ListUint32" "ListUint64" "ListInt8" "ListInt16" "ListInt32" "ListInt64" "ListFloat32" "ListFloat64" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
{{- if $field.IdentName -}}
// Enum list - returns a number list that can be cast to the enum type
func (x {{ $struct.Name }}) {{ $field.Name }}() *segment.Numbers[{{ $field.GoListType }}] {
    // Try to get cached or parse from segment
    if nums := segment.GetListNumbers[{{ $field.GoListType }}](x.s, {{ $field.Index }}); nums != nil {
        return nums
    }
    // Create new empty list if no data exists
    nums := segment.NewNumbers[{{ $field.GoListType }}](x.s, {{ $field.Index }})
    return nums
}
{{- else }}
func (x {{ $struct.Name }}) {{ $field.Name }}() *segment.Numbers[{{ $field.GoListType }}] {
    // Try to get cached or parse from segment
    if nums := segment.GetListNumbers[{{ $field.GoListType }}](x.s, {{ $field.Index }}); nums != nil {
        return nums
    }
    // Create new empty list if no data exists
    nums := segment.NewNumbers[{{ $field.GoListType }}](x.s, {{ $field.Index }})
    return nums
}
{{- end }}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

// Set{{ $field.Name }} replaces all values in the numeric list.
func (x {{ $struct.Name }}) Set{{ $field.Name }}(v ...{{ $field.GoListType }}) {{ $struct.Name }} {
    nums := x.{{ $field.Name }}()
    nums.SetAll(v)
    return x
}

{{ else if eq $field.TypeAsString "ListBytes" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() *segment.Bytes {
    // Try to get cached or parse from segment
    if b := segment.GetListBytes(x.s, {{ $field.Index }}); b != nil {
        return b
    }
    // Create new empty list if no data exists
    b := segment.NewBytes(x.s, {{ $field.Index }})
    return b
}

// Set{{ $field.Name }} replaces all values in the bytes list.
func (x {{ $struct.Name }}) Set{{ $field.Name }}(v ...[]byte) {{ $struct.Name }} {
    b := x.{{ $field.Name }}()
    b.SetAll(v)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "ListStrings" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
func (x {{ $struct.Name }}) {{ $field.Name }}() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, {{ $field.Index }}); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, {{ $field.Index }})
    return strs
}

// Set{{ $field.Name }} replaces all values in the string list.
func (x {{ $struct.Name }}) Set{{ $field.Name }}(v ...string) {{ $struct.Name }} {
    strs := x.{{ $field.Name }}()
    strs.SetAll(v)
    return x
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "ListStructs" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
// {{ $field.Name }}List returns the underlying Structs list for iteration.
// Use New{{ $field.IdentInFile }}() to create items and Append to add them.
func (x {{ $struct.Name }}) {{ $field.Name }}List(ctx context.Context) *segment.Structs {
    {{- if $field.IsExternal }}
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, {{ $field.Index }}, {{ $field.Package }}.XXXMapping{{ $field.IdentInFile }}); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, {{ $field.Index }}, {{ $field.Package }}.XXXMapping{{ $field.IdentInFile }})
    {{- else }}
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, {{ $field.Index }}, XXXMapping{{ $field.IdentInFile }}); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, {{ $field.Index }}, XXXMapping{{ $field.IdentInFile }})
    {{- end }}
    return structs
}

// {{ $field.Name }}Len returns the number of items in the list.
func (x {{ $struct.Name }}) {{ $field.Name }}Len(ctx context.Context) int {
    return x.{{ $field.Name }}List(ctx).Len()
}

// {{ $field.Name }}Get returns the item at the given index.
func (x {{ $struct.Name }}) {{ $field.Name }}Get(ctx context.Context, index int) {{ $field.IdentName }} {
    s := x.{{ $field.Name }}List(ctx).Get(index)
    {{- if $field.IsExternal }}
    return {{ $field.Package }}.XXXNew{{ $field.IdentInFile }}From(s)
    {{- else }}
    return {{ $field.IdentName }}{s: s}
    {{- end }}
}

// {{ $field.Name }}Append appends items to the list.
func (x {{ $struct.Name }}) {{ $field.Name }}Append(ctx context.Context, values ...{{ $field.IdentName }}) {
    list := x.{{ $field.Name }}List(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// Append{{ $field.Name }} is an alias for {{ $field.Name }}Append for backwards compatibility.
func (x {{ $struct.Name }}) Append{{ $field.Name }}(ctx context.Context, values ...{{ $field.IdentName }}) {
    x.{{ $field.Name }}Append(ctx, values...)
}

// {{ $field.Name }}AppendRaw appends items to the list using Raw struct representations.
func (x {{ $struct.Name }}) {{ $field.Name }}AppendRaw(ctx context.Context, values ...*{{ if $field.IsExternal }}{{ $field.Package }}.{{ $field.IdentInFile }}{{ else }}{{ $field.IdentName }}{{ end }}Raw) {
    list := x.{{ $field.Name }}List(ctx)
    for _, raw := range values {
        if raw != nil {
            {{- if $field.IsExternal }}
            list.Append({{ $field.Package }}.New{{ $field.IdentInFile }}FromRaw(ctx, *raw).XXXGetStruct())
            {{- else }}
            list.Append(New{{ $field.IdentInFile }}FromRaw(ctx, *raw).XXXGetStruct())
            {{- end }}
        }
    }
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ else if eq $field.TypeAsString "Map" -}}
{{- if $field.Comment -}}
// {{ $field.Comment }}
{{ end -}}
{{- if $field.ValueIdentName }}
// {{ $field.Name }}Map returns the underlying map for iteration and modification.
// The map values are *segment.Struct - use XXXNew{{ $field.ValueIdentName }}From() to wrap them.
func (x {{ $struct.Name }}) {{ $field.Name }}Map() *segment.Maps[{{ $field.MapKeyGoType }}, *segment.Struct] {
    // Check if we already have this map cached
    if m := segment.GetMapStruct[{{ $field.MapKeyGoType }}](x.s, {{ $field.Index }}, field.{{ $field.KeyTypeConst }}, {{ if $field.ValueIsExternal }}{{ $field.ValuePackage }}.XXXMapping{{ $field.ValueIdentName }}{{ else }}XXXMapping{{ $field.ValueIdentName }}{{ end }}); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[{{ $field.MapKeyGoType }}, *segment.Struct](x.s, {{ $field.Index }}, field.{{ $field.KeyTypeConst }}, field.{{ $field.ValueTypeConst }}, {{ if $field.ValueIsExternal }}{{ $field.ValuePackage }}.XXXMapping{{ $field.ValueIdentName }}{{ else }}XXXMapping{{ $field.ValueIdentName }}{{ end }})
}

// {{ $field.Name }}Get returns the value for the given key, or nil if not found.
func (x {{ $struct.Name }}) {{ $field.Name }}Get(key {{ $field.MapKeyGoType }}) ({{ $field.ValueIdentName }}, bool) {
    s, ok := x.{{ $field.Name }}Map().Get(key)
    if !ok || s == nil {
        return {{ $field.ValueIdentName }}{}, false
    }
    return {{ if $field.ValueIsExternal }}{{ $field.ValuePackage }}.XXXNew{{ $field.ValueIdentName }}From{{ else }}XXXNew{{ $field.ValueIdentName }}From{{ end }}(s), true
}

// {{ $field.Name }}Set sets a key-value pair in the map.
func (x {{ $struct.Name }}) {{ $field.Name }}Set(key {{ $field.MapKeyGoType }}, value {{ $field.ValueIdentName }}) {{ $struct.Name }} {
    x.{{ $field.Name }}Map().Set(key, value.XXXGetStruct())
    return x
}
{{- else if $field.NestedMapInfo }}
// {{ $field.Name }}Map returns the underlying map for iteration and modification.
// Note: Nested maps are represented as Go maps for simplicity.
func (x {{ $struct.Name }}) {{ $field.Name }}Map() *segment.Maps[{{ $field.MapKeyGoType }}, {{ $field.MapValueGoType }}] {
    // Check if we already have this map cached
    if m := segment.GetMapScalar[{{ $field.MapKeyGoType }}, {{ $field.MapValueGoType }}](x.s, {{ $field.Index }}, field.{{ $field.KeyTypeConst }}, field.{{ $field.ValueTypeConst }}); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[{{ $field.MapKeyGoType }}, {{ $field.MapValueGoType }}](x.s, {{ $field.Index }}, field.{{ $field.KeyTypeConst }}, field.{{ $field.ValueTypeConst }}, nil)
}

// {{ $field.Name }}Get returns the value for the given key, or false if not found.
func (x {{ $struct.Name }}) {{ $field.Name }}Get(key {{ $field.MapKeyGoType }}) ({{ $field.MapValueGoType }}, bool) {
    return x.{{ $field.Name }}Map().Get(key)
}

// {{ $field.Name }}Set sets a key-value pair in the map.
func (x {{ $struct.Name }}) {{ $field.Name }}Set(key {{ $field.MapKeyGoType }}, value {{ $field.MapValueGoType }}) {{ $struct.Name }} {
    x.{{ $field.Name }}Map().Set(key, value)
    return x
}
{{- else }}
// {{ $field.Name }}Map returns the underlying map for iteration and modification.
func (x {{ $struct.Name }}) {{ $field.Name }}Map() *segment.Maps[{{ $field.MapKeyGoType }}, {{ $field.MapValueGoType }}] {
    // Check if we already have this map cached
    if m := segment.GetMapScalar[{{ $field.MapKeyGoType }}, {{ $field.MapValueGoType }}](x.s, {{ $field.Index }}, field.{{ $field.KeyTypeConst }}, field.{{ $field.ValueTypeConst }}); m != nil {
        return m
    }
    // Create new empty map if no data exists
    return segment.NewMaps[{{ $field.MapKeyGoType }}, {{ $field.MapValueGoType }}](x.s, {{ $field.Index }}, field.{{ $field.KeyTypeConst }}, field.{{ $field.ValueTypeConst }}, nil)
}

// {{ $field.Name }}Get returns the value for the given key, or false if not found.
func (x {{ $struct.Name }}) {{ $field.Name }}Get(key {{ $field.MapKeyGoType }}) ({{ $field.MapValueGoType }}, bool) {
    return x.{{ $field.Name }}Map().Get(key)
}

// {{ $field.Name }}Set sets a key-value pair in the map.
func (x {{ $struct.Name }}) {{ $field.Name }}Set(key {{ $field.MapKeyGoType }}, value {{ $field.MapValueGoType }}) {{ $struct.Name }} {
    x.{{ $field.Name }}Map().Set(key, value)
    return x
}
{{- end }}

// {{ $field.Name }}Delete removes a key from the map.
func (x {{ $struct.Name }}) {{ $field.Name }}Delete(key {{ $field.MapKeyGoType }}) {{ $struct.Name }} {
    x.{{ $field.Name }}Map().Delete(key)
    return x
}

// {{ $field.Name }}Has returns true if the key exists in the map.
func (x {{ $struct.Name }}) {{ $field.Name }}Has(key {{ $field.MapKeyGoType }}) bool {
    return x.{{ $field.Name }}Map().Has(key)
}

// {{ $field.Name }}Len returns the number of entries in the map.
func (x {{ $struct.Name }}) {{ $field.Name }}Len() int {
    return x.{{ $field.Name }}Map().Len()
}

{{- if $isSetEnabled }}
func (x {{ $struct.Name }}) IsSet{{ $field.Name }}() bool{
    return x.s.HasField({{ $field.Index }})
}
{{- end }}

{{ end }}{{/* End if eq $field.Type */}}
{{- end }}{{/* End range $index, $field := .Fields */}}

// ClawStruct returns a reflection type representing the Struct.
func (x {{ $struct.Name }}) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x {{ $struct.Name }}) XXXGetStruct() *segment.Struct {
    return x.s
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x {{ $struct.Name }}) SetRecording(enabled bool) {{ $struct.Name }} {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x {{ $struct.Name }}) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x {{ $struct.Name }}) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x {{ $struct.Name }}) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// {{ $struct.Name }}Raw is a plain Go struct representation of {{ $struct.Name }}.
// Zero values are not set (sparse encoding).
type {{ $struct.Name }}Raw struct {
{{- range $field := .Fields }}
    {{ $field.Name }} {{ $field.RawGoType }}
{{- end }}
}

// New{{ $struct.Name }}FromRaw creates a new {{ $struct.Name }} from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func New{{ $struct.Name }}FromRaw(ctx context.Context, raw {{ $struct.Name }}Raw) {{ $struct.Name }} {
    x := New{{ $struct.Name }}(ctx)
{{- range $field := .Fields }}
{{- if eq $field.TypeAsString "Bool" }}
    if raw.{{ $field.Name }} {
        x.Set{{ $field.Name }}(raw.{{ $field.Name }})
    }
{{- else if eq $field.TypeAsString "Int8" "Int16" "Int32" "Int64" "Uint8" "Uint16" "Uint32" "Uint64" "Float32" "Float64" }}
    if raw.{{ $field.Name }} != 0 {
        x.Set{{ $field.Name }}(raw.{{ $field.Name }})
    }
{{- else if eq $field.TypeAsString "String" }}
    if raw.{{ $field.Name }} != "" {
        x.Set{{ $field.Name }}(raw.{{ $field.Name }})
    }
{{- else if eq $field.TypeAsString "Bytes" }}
    if raw.{{ $field.Name }} != nil {
        x.Set{{ $field.Name }}(raw.{{ $field.Name }})
    }
{{- else if eq $field.TypeAsString "Struct" }}
    if raw.{{ $field.Name }} != nil {
        {{- if $field.IsExternal }}
        x.Set{{ $field.Name }}({{ $field.Package }}.New{{ $field.IdentInFile }}FromRaw(ctx, *raw.{{ $field.Name }}))
        {{- else }}
        x.Set{{ $field.Name }}(New{{ $field.IdentName }}FromRaw(ctx, *raw.{{ $field.Name }}))
        {{- end }}
    }
{{- else if eq $field.TypeAsString "ListBools" }}
    if raw.{{ $field.Name }} != nil {
        x.Set{{ $field.Name }}(raw.{{ $field.Name }}...)
    }
{{- else if eq $field.TypeAsString "ListUint8" "ListUint16" "ListUint32" "ListUint64" "ListInt8" "ListInt16" "ListInt32" "ListInt64" "ListFloat32" "ListFloat64" }}
    if raw.{{ $field.Name }} != nil {
        x.Set{{ $field.Name }}(raw.{{ $field.Name }}...)
    }
{{- else if eq $field.TypeAsString "ListBytes" }}
    if raw.{{ $field.Name }} != nil {
        x.Set{{ $field.Name }}(raw.{{ $field.Name }}...)
    }
{{- else if eq $field.TypeAsString "ListStrings" }}
    if raw.{{ $field.Name }} != nil {
        x.Set{{ $field.Name }}(raw.{{ $field.Name }}...)
    }
{{- else if eq $field.TypeAsString "ListStructs" }}
    if raw.{{ $field.Name }} != nil {
        list := x.{{ $field.Name }}List(ctx)
        items := make([]*segment.Struct, 0, len(raw.{{ $field.Name }}))
        for _, r := range raw.{{ $field.Name }} {
            if r != nil {
                {{- if $field.IsExternal }}
                items = append(items, {{ $field.Package }}.New{{ $field.IdentInFile }}FromRaw(ctx, *r).XXXGetStruct())
                {{- else }}
                items = append(items, New{{ $field.IdentInFile }}FromRaw(ctx, *r).XXXGetStruct())
                {{- end }}
            }
        }
        list.SetAll(items)
    }
{{- else if eq $field.TypeAsString "Map" }}
    if raw.{{ $field.Name }} != nil {
        m := x.{{ $field.Name }}Map()
        for k, v := range raw.{{ $field.Name }} {
            {{- if $field.ValueIdentName }}
            {{- if $field.ValueIsExternal }}
            if v != nil {
                m.Set(k, {{ $field.ValuePackage }}.New{{ $field.ValueIdentName }}FromRaw(ctx, *v).XXXGetStruct())
            }
            {{- else }}
            if v != nil {
                m.Set(k, New{{ $field.ValueIdentName }}FromRaw(ctx, *v).XXXGetStruct())
            }
            {{- end }}
            {{- else }}
            m.Set(k, v)
            {{- end }}
        }
    }
{{- end }}
{{- end }}
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x {{ $struct.Name }}) ToRaw(ctx context.Context) {{ $struct.Name }}Raw {
    raw := {{ $struct.Name }}Raw{}
{{- range $field := .Fields }}
{{- if eq $field.TypeAsString "Bool" "Int8" "Int16" "Int32" "Int64" "Uint8" "Uint16" "Uint32" "Uint64" "Float32" "Float64" "String" }}
    raw.{{ $field.Name }} = x.{{ $field.Name }}()
{{- else if eq $field.TypeAsString "Bytes" }}
    if x.s.HasField({{ $field.Index }}) {
        raw.{{ $field.Name }} = x.{{ $field.Name }}()
    }
{{- else if eq $field.TypeAsString "Struct" }}
    if x.s.HasField({{ $field.Index }}) {
        nestedRaw := x.{{ $field.Name }}().ToRaw(ctx)
        raw.{{ $field.Name }} = &nestedRaw
    }
{{- else if eq $field.TypeAsString "ListBools" }}
    if l := x.s.GetList({{ $field.Index }}); l != nil && l.(*segment.Bools).Len() > 0 {
        raw.{{ $field.Name }} = l.(*segment.Bools).Slice()
    } else if x.s.HasField({{ $field.Index }}) {
        raw.{{ $field.Name }} = x.{{ $field.Name }}().Slice()
    }
{{- else if eq $field.TypeAsString "ListUint8" "ListUint16" "ListUint32" "ListUint64" "ListInt8" "ListInt16" "ListInt32" "ListInt64" "ListFloat32" "ListFloat64" }}
    if l := x.s.GetList({{ $field.Index }}); l != nil && l.(*segment.Numbers[{{ $field.GoListType }}]).Len() > 0 {
        raw.{{ $field.Name }} = l.(*segment.Numbers[{{ $field.GoListType }}]).Slice()
    } else if x.s.HasField({{ $field.Index }}) {
        raw.{{ $field.Name }} = x.{{ $field.Name }}().Slice()
    }
{{- else if eq $field.TypeAsString "ListBytes" }}
    if l := x.s.GetList({{ $field.Index }}); l != nil && l.(*segment.Bytes).Len() > 0 {
        raw.{{ $field.Name }} = l.(*segment.Bytes).Slice()
    } else if x.s.HasField({{ $field.Index }}) {
        raw.{{ $field.Name }} = x.{{ $field.Name }}().Slice()
    }
{{- else if eq $field.TypeAsString "ListStrings" }}
    if l := x.s.GetList({{ $field.Index }}); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.{{ $field.Name }} = l.(*segment.Strings).Slice()
    } else if x.s.HasField({{ $field.Index }}) {
        raw.{{ $field.Name }} = x.{{ $field.Name }}().Slice()
    }
{{- else if eq $field.TypeAsString "ListStructs" }}
    if l := x.s.GetList({{ $field.Index }}); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.{{ $field.Name }} = make({{ $field.RawGoType }}, list.Len())
        for i := 0; i < list.Len(); i++ {
            {{- if $field.IsExternal }}
            item := {{ $field.Package }}.XXXNew{{ $field.IdentInFile }}From(list.Get(i))
            {{- else }}
            item := {{ $field.IdentName }}{s: list.Get(i)}
            {{- end }}
            itemRaw := item.ToRaw(ctx)
            raw.{{ $field.Name }}[i] = &itemRaw
        }
    } else if x.s.HasField({{ $field.Index }}) {
        list := x.{{ $field.Name }}List(ctx)
        raw.{{ $field.Name }} = make({{ $field.RawGoType }}, list.Len())
        for i := 0; i < list.Len(); i++ {
            {{- if $field.IsExternal }}
            item := {{ $field.Package }}.XXXNew{{ $field.IdentInFile }}From(list.Get(i))
            {{- else }}
            item := {{ $field.IdentName }}{s: list.Get(i)}
            {{- end }}
            itemRaw := item.ToRaw(ctx)
            raw.{{ $field.Name }}[i] = &itemRaw
        }
    }
{{- else if eq $field.TypeAsString "Map" }}
    // For maps, check if there's a cached dirty map or field data
    // Don't use HasField alone as the map may not have been synced yet
    if m := x.{{ $field.Name }}Map(); m.Len() > 0 {
        raw.{{ $field.Name }} = make({{ $field.RawGoType }})
        for k, v := range m.All() {
            {{- if $field.ValueIdentName }}
            {{- if $field.ValueIsExternal }}
            item := {{ $field.ValuePackage }}.XXXNew{{ $field.ValueIdentName }}From(v)
            {{- else }}
            item := {{ $field.ValueIdentName }}{s: v}
            {{- end }}
            itemRaw := item.ToRaw(ctx)
            raw.{{ $field.Name }}[k] = &itemRaw
            {{- else }}
            raw.{{ $field.Name }}[k] = v
            {{- end }}
        }
    }
{{- end }}
{{- end }}
    return raw
}
