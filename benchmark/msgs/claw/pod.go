// DO NOT EDIT
// This package is autogenerated and should not be modified except by the clawc compiler.

// Package pod
package pod

import (
    "context"
    "io"
    "bytes"
    "fmt"

    "github.com/bearlytools/claw/clawc/languages/go/mapping"
    "github.com/bearlytools/claw/languages/go/reflect"
    "github.com/bearlytools/claw/languages/go/reflect/runtime"
    "github.com/bearlytools/claw/clawc/languages/go/segment"
    "github.com/bearlytools/claw/clawc/languages/go/field"
    
)

// Ensure imports are used.
var (
    _ context.Context
    _ = io.EOF
    _ = bytes.MinRead
    _ = fmt.Errorf
    _ mapping.Map
    _ reflect.StructDescr
    _ = runtime.RegisterPackage
    _ segment.Struct
    _ = field.FTBool
)

// SyntaxVersion is the major version of the Claw language that is being rendered.
const SyntaxVersion = 0

var _package = "pod"
var _packagePath = "github.com/bearlytools/claw/benchmark/msgs/claw"


// AppArmorProfileType describes the AppArmor profile type.
type AppArmorProfileType uint8

// String implements fmt.Stringer.
func (x AppArmorProfileType) String() string {
    return AppArmorProfileTypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x AppArmorProfileType) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(0)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x AppArmorProfileType) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(0).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum AppArmorProfileType.
const (
    AppArmorProfileTypeUnspecified AppArmorProfileType = 0
    AppArmorProfileTypeUnconfined AppArmorProfileType = 1
    AppArmorProfileTypeRuntimeDefault AppArmorProfileType = 2
    AppArmorProfileTypeLocalhost AppArmorProfileType = 3
)

// AppArmorProfileTypeByName converts a string representing the enumerator into a AppArmorProfileType.
var AppArmorProfileTypeByName = map[string]AppArmorProfileType{
    "AppArmorProfileTypeLocalhost": 3,
    "AppArmorProfileTypeRuntimeDefault": 2,
    "AppArmorProfileTypeUnconfined": 1,
    "AppArmorProfileTypeUnspecified": 0,
}

// AppArmorProfileTypeByValue converts a uint8 representing a AppArmorProfileType into its string name.
var AppArmorProfileTypeByValue = map[uint8]string{
    0: "AppArmorProfileTypeUnspecified",
    1: "AppArmorProfileTypeUnconfined",
    2: "AppArmorProfileTypeRuntimeDefault",
    3: "AppArmorProfileTypeLocalhost",
}
// ConditionStatus describes the status of a condition.
type ConditionStatus uint8

// String implements fmt.Stringer.
func (x ConditionStatus) String() string {
    return ConditionStatusByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ConditionStatus) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(1)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ConditionStatus) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(1).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum ConditionStatus.
const (
    ConditionStatusUnspecified ConditionStatus = 0
    ConditionStatusTrue ConditionStatus = 1
    ConditionStatusFalse ConditionStatus = 2
    ConditionStatusUnknown ConditionStatus = 3
)

// ConditionStatusByName converts a string representing the enumerator into a ConditionStatus.
var ConditionStatusByName = map[string]ConditionStatus{
    "ConditionStatusFalse": 2,
    "ConditionStatusTrue": 1,
    "ConditionStatusUnknown": 3,
    "ConditionStatusUnspecified": 0,
}

// ConditionStatusByValue converts a uint8 representing a ConditionStatus into its string name.
var ConditionStatusByValue = map[uint8]string{
    0: "ConditionStatusUnspecified",
    1: "ConditionStatusTrue",
    2: "ConditionStatusFalse",
    3: "ConditionStatusUnknown",
}
// ContainerRestartPolicy is the restart policy for a container.
type ContainerRestartPolicy uint8

// String implements fmt.Stringer.
func (x ContainerRestartPolicy) String() string {
    return ContainerRestartPolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ContainerRestartPolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(2)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ContainerRestartPolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(2).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum ContainerRestartPolicy.
const (
    ContainerRestartPolicyUnspecified ContainerRestartPolicy = 0
    ContainerRestartPolicyAlways ContainerRestartPolicy = 1
)

// ContainerRestartPolicyByName converts a string representing the enumerator into a ContainerRestartPolicy.
var ContainerRestartPolicyByName = map[string]ContainerRestartPolicy{
    "ContainerRestartPolicyAlways": 1,
    "ContainerRestartPolicyUnspecified": 0,
}

// ContainerRestartPolicyByValue converts a uint8 representing a ContainerRestartPolicy into its string name.
var ContainerRestartPolicyByValue = map[uint8]string{
    0: "ContainerRestartPolicyUnspecified",
    1: "ContainerRestartPolicyAlways",
}
// DNSPolicy defines how a pod's DNS will be configured.
type DNSPolicy uint8

// String implements fmt.Stringer.
func (x DNSPolicy) String() string {
    return DNSPolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x DNSPolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(3)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x DNSPolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(3).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum DNSPolicy.
const (
    DNSPolicyUnspecified DNSPolicy = 0
    DNSPolicyClusterFirstWithHostNet DNSPolicy = 1
    DNSPolicyClusterFirst DNSPolicy = 2
    DNSPolicyDefault DNSPolicy = 3
    DNSPolicyNone DNSPolicy = 4
)

// DNSPolicyByName converts a string representing the enumerator into a DNSPolicy.
var DNSPolicyByName = map[string]DNSPolicy{
    "DNSPolicyClusterFirst": 2,
    "DNSPolicyClusterFirstWithHostNet": 1,
    "DNSPolicyDefault": 3,
    "DNSPolicyNone": 4,
    "DNSPolicyUnspecified": 0,
}

// DNSPolicyByValue converts a uint8 representing a DNSPolicy into its string name.
var DNSPolicyByValue = map[uint8]string{
    0: "DNSPolicyUnspecified",
    1: "DNSPolicyClusterFirstWithHostNet",
    2: "DNSPolicyClusterFirst",
    3: "DNSPolicyDefault",
    4: "DNSPolicyNone",
}
// HostPathType describes the type of the host path.
type HostPathType uint8

// String implements fmt.Stringer.
func (x HostPathType) String() string {
    return HostPathTypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x HostPathType) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(4)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x HostPathType) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(4).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum HostPathType.
const (
    HostPathTypeUnspecified HostPathType = 0
    HostPathTypeDirectoryOrCreate HostPathType = 1
    HostPathTypeDirectory HostPathType = 2
    HostPathTypeFileOrCreate HostPathType = 3
    HostPathTypeFile HostPathType = 4
    HostPathTypeSocket HostPathType = 5
    HostPathTypeCharDevice HostPathType = 6
    HostPathTypeBlockDevice HostPathType = 7
)

// HostPathTypeByName converts a string representing the enumerator into a HostPathType.
var HostPathTypeByName = map[string]HostPathType{
    "HostPathTypeBlockDevice": 7,
    "HostPathTypeCharDevice": 6,
    "HostPathTypeDirectory": 2,
    "HostPathTypeDirectoryOrCreate": 1,
    "HostPathTypeFile": 4,
    "HostPathTypeFileOrCreate": 3,
    "HostPathTypeSocket": 5,
    "HostPathTypeUnspecified": 0,
}

// HostPathTypeByValue converts a uint8 representing a HostPathType into its string name.
var HostPathTypeByValue = map[uint8]string{
    0: "HostPathTypeUnspecified",
    1: "HostPathTypeDirectoryOrCreate",
    2: "HostPathTypeDirectory",
    3: "HostPathTypeFileOrCreate",
    4: "HostPathTypeFile",
    5: "HostPathTypeSocket",
    6: "HostPathTypeCharDevice",
    7: "HostPathTypeBlockDevice",
}
// LabelSelectorOperator represents a label selector operator.
type LabelSelectorOperator uint8

// String implements fmt.Stringer.
func (x LabelSelectorOperator) String() string {
    return LabelSelectorOperatorByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x LabelSelectorOperator) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(5)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x LabelSelectorOperator) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(5).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum LabelSelectorOperator.
const (
    LabelSelectorOperatorUnspecified LabelSelectorOperator = 0
    LabelSelectorOperatorIn LabelSelectorOperator = 1
    LabelSelectorOperatorNotIn LabelSelectorOperator = 2
    LabelSelectorOperatorExists LabelSelectorOperator = 3
    LabelSelectorOperatorDoesNotExist LabelSelectorOperator = 4
)

// LabelSelectorOperatorByName converts a string representing the enumerator into a LabelSelectorOperator.
var LabelSelectorOperatorByName = map[string]LabelSelectorOperator{
    "LabelSelectorOperatorDoesNotExist": 4,
    "LabelSelectorOperatorExists": 3,
    "LabelSelectorOperatorIn": 1,
    "LabelSelectorOperatorNotIn": 2,
    "LabelSelectorOperatorUnspecified": 0,
}

// LabelSelectorOperatorByValue converts a uint8 representing a LabelSelectorOperator into its string name.
var LabelSelectorOperatorByValue = map[uint8]string{
    0: "LabelSelectorOperatorUnspecified",
    1: "LabelSelectorOperatorIn",
    2: "LabelSelectorOperatorNotIn",
    3: "LabelSelectorOperatorExists",
    4: "LabelSelectorOperatorDoesNotExist",
}
// MountPropagationMode describes mount propagation.
type MountPropagationMode uint8

// String implements fmt.Stringer.
func (x MountPropagationMode) String() string {
    return MountPropagationModeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x MountPropagationMode) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(6)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x MountPropagationMode) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(6).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum MountPropagationMode.
const (
    MountPropagationModeUnspecified MountPropagationMode = 0
    MountPropagationModeNone MountPropagationMode = 1
    MountPropagationModeHostToContainer MountPropagationMode = 2
    MountPropagationModeBidirectional MountPropagationMode = 3
)

// MountPropagationModeByName converts a string representing the enumerator into a MountPropagationMode.
var MountPropagationModeByName = map[string]MountPropagationMode{
    "MountPropagationModeBidirectional": 3,
    "MountPropagationModeHostToContainer": 2,
    "MountPropagationModeNone": 1,
    "MountPropagationModeUnspecified": 0,
}

// MountPropagationModeByValue converts a uint8 representing a MountPropagationMode into its string name.
var MountPropagationModeByValue = map[uint8]string{
    0: "MountPropagationModeUnspecified",
    1: "MountPropagationModeNone",
    2: "MountPropagationModeHostToContainer",
    3: "MountPropagationModeBidirectional",
}
// NodeInclusionPolicy defines the type of node inclusion policy.
type NodeInclusionPolicy uint8

// String implements fmt.Stringer.
func (x NodeInclusionPolicy) String() string {
    return NodeInclusionPolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x NodeInclusionPolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(7)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x NodeInclusionPolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(7).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum NodeInclusionPolicy.
const (
    NodeInclusionPolicyUnspecified NodeInclusionPolicy = 0
    NodeInclusionPolicyIgnore NodeInclusionPolicy = 1
    NodeInclusionPolicyHonor NodeInclusionPolicy = 2
)

// NodeInclusionPolicyByName converts a string representing the enumerator into a NodeInclusionPolicy.
var NodeInclusionPolicyByName = map[string]NodeInclusionPolicy{
    "NodeInclusionPolicyHonor": 2,
    "NodeInclusionPolicyIgnore": 1,
    "NodeInclusionPolicyUnspecified": 0,
}

// NodeInclusionPolicyByValue converts a uint8 representing a NodeInclusionPolicy into its string name.
var NodeInclusionPolicyByValue = map[uint8]string{
    0: "NodeInclusionPolicyUnspecified",
    1: "NodeInclusionPolicyIgnore",
    2: "NodeInclusionPolicyHonor",
}
// NodeSelectorOperator represents a node selector operator.
type NodeSelectorOperator uint8

// String implements fmt.Stringer.
func (x NodeSelectorOperator) String() string {
    return NodeSelectorOperatorByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x NodeSelectorOperator) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(8)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x NodeSelectorOperator) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(8).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum NodeSelectorOperator.
const (
    NodeSelectorOperatorUnspecified NodeSelectorOperator = 0
    NodeSelectorOperatorIn NodeSelectorOperator = 1
    NodeSelectorOperatorNotIn NodeSelectorOperator = 2
    NodeSelectorOperatorExists NodeSelectorOperator = 3
    NodeSelectorOperatorDoesNotExist NodeSelectorOperator = 4
    NodeSelectorOperatorGt NodeSelectorOperator = 5
    NodeSelectorOperatorLt NodeSelectorOperator = 6
)

// NodeSelectorOperatorByName converts a string representing the enumerator into a NodeSelectorOperator.
var NodeSelectorOperatorByName = map[string]NodeSelectorOperator{
    "NodeSelectorOperatorDoesNotExist": 4,
    "NodeSelectorOperatorExists": 3,
    "NodeSelectorOperatorGt": 5,
    "NodeSelectorOperatorIn": 1,
    "NodeSelectorOperatorLt": 6,
    "NodeSelectorOperatorNotIn": 2,
    "NodeSelectorOperatorUnspecified": 0,
}

// NodeSelectorOperatorByValue converts a uint8 representing a NodeSelectorOperator into its string name.
var NodeSelectorOperatorByValue = map[uint8]string{
    0: "NodeSelectorOperatorUnspecified",
    1: "NodeSelectorOperatorIn",
    2: "NodeSelectorOperatorNotIn",
    3: "NodeSelectorOperatorExists",
    4: "NodeSelectorOperatorDoesNotExist",
    5: "NodeSelectorOperatorGt",
    6: "NodeSelectorOperatorLt",
}
// PersistentVolumeAccessMode describes how a volume can be mounted.
type PersistentVolumeAccessMode uint8

// String implements fmt.Stringer.
func (x PersistentVolumeAccessMode) String() string {
    return PersistentVolumeAccessModeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PersistentVolumeAccessMode) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(9)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PersistentVolumeAccessMode) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(9).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PersistentVolumeAccessMode.
const (
    PersistentVolumeAccessModeUnspecified PersistentVolumeAccessMode = 0
    PersistentVolumeAccessModeReadWriteOnce PersistentVolumeAccessMode = 1
    PersistentVolumeAccessModeReadOnlyMany PersistentVolumeAccessMode = 2
    PersistentVolumeAccessModeReadWriteMany PersistentVolumeAccessMode = 3
    PersistentVolumeAccessModeReadWriteOncePod PersistentVolumeAccessMode = 4
)

// PersistentVolumeAccessModeByName converts a string representing the enumerator into a PersistentVolumeAccessMode.
var PersistentVolumeAccessModeByName = map[string]PersistentVolumeAccessMode{
    "PersistentVolumeAccessModeReadOnlyMany": 2,
    "PersistentVolumeAccessModeReadWriteMany": 3,
    "PersistentVolumeAccessModeReadWriteOnce": 1,
    "PersistentVolumeAccessModeReadWriteOncePod": 4,
    "PersistentVolumeAccessModeUnspecified": 0,
}

// PersistentVolumeAccessModeByValue converts a uint8 representing a PersistentVolumeAccessMode into its string name.
var PersistentVolumeAccessModeByValue = map[uint8]string{
    0: "PersistentVolumeAccessModeUnspecified",
    1: "PersistentVolumeAccessModeReadWriteOnce",
    2: "PersistentVolumeAccessModeReadOnlyMany",
    3: "PersistentVolumeAccessModeReadWriteMany",
    4: "PersistentVolumeAccessModeReadWriteOncePod",
}
// PersistentVolumeMode describes how a volume is intended to be consumed.
type PersistentVolumeMode uint8

// String implements fmt.Stringer.
func (x PersistentVolumeMode) String() string {
    return PersistentVolumeModeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PersistentVolumeMode) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(10)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PersistentVolumeMode) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(10).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PersistentVolumeMode.
const (
    PersistentVolumeModeUnspecified PersistentVolumeMode = 0
    PersistentVolumeModeBlock PersistentVolumeMode = 1
    PersistentVolumeModeFilesystem PersistentVolumeMode = 2
)

// PersistentVolumeModeByName converts a string representing the enumerator into a PersistentVolumeMode.
var PersistentVolumeModeByName = map[string]PersistentVolumeMode{
    "PersistentVolumeModeBlock": 1,
    "PersistentVolumeModeFilesystem": 2,
    "PersistentVolumeModeUnspecified": 0,
}

// PersistentVolumeModeByValue converts a uint8 representing a PersistentVolumeMode into its string name.
var PersistentVolumeModeByValue = map[uint8]string{
    0: "PersistentVolumeModeUnspecified",
    1: "PersistentVolumeModeBlock",
    2: "PersistentVolumeModeFilesystem",
}
// PodConditionType describes the type of pod condition.
type PodConditionType uint8

// String implements fmt.Stringer.
func (x PodConditionType) String() string {
    return PodConditionTypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodConditionType) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(11)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodConditionType) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(11).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PodConditionType.
const (
    PodConditionTypeUnspecified PodConditionType = 0
    PodConditionTypeContainersReady PodConditionType = 1
    PodConditionTypeInitialized PodConditionType = 2
    PodConditionTypeReady PodConditionType = 3
    PodConditionTypePodScheduled PodConditionType = 4
    PodConditionTypeDisruptionTarget PodConditionType = 5
    PodConditionTypePodReadyToStartContainers PodConditionType = 6
)

// PodConditionTypeByName converts a string representing the enumerator into a PodConditionType.
var PodConditionTypeByName = map[string]PodConditionType{
    "PodConditionTypeContainersReady": 1,
    "PodConditionTypeDisruptionTarget": 5,
    "PodConditionTypeInitialized": 2,
    "PodConditionTypePodReadyToStartContainers": 6,
    "PodConditionTypePodScheduled": 4,
    "PodConditionTypeReady": 3,
    "PodConditionTypeUnspecified": 0,
}

// PodConditionTypeByValue converts a uint8 representing a PodConditionType into its string name.
var PodConditionTypeByValue = map[uint8]string{
    0: "PodConditionTypeUnspecified",
    1: "PodConditionTypeContainersReady",
    2: "PodConditionTypeInitialized",
    3: "PodConditionTypeReady",
    4: "PodConditionTypePodScheduled",
    5: "PodConditionTypeDisruptionTarget",
    6: "PodConditionTypePodReadyToStartContainers",
}
// PodFSGroupChangePolicy describes how the fsGroup should be applied.
type PodFSGroupChangePolicy uint8

// String implements fmt.Stringer.
func (x PodFSGroupChangePolicy) String() string {
    return PodFSGroupChangePolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodFSGroupChangePolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(12)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodFSGroupChangePolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(12).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PodFSGroupChangePolicy.
const (
    PodFSGroupChangePolicyUnspecified PodFSGroupChangePolicy = 0
    PodFSGroupChangePolicyOnRootMismatch PodFSGroupChangePolicy = 1
    PodFSGroupChangePolicyAlways PodFSGroupChangePolicy = 2
)

// PodFSGroupChangePolicyByName converts a string representing the enumerator into a PodFSGroupChangePolicy.
var PodFSGroupChangePolicyByName = map[string]PodFSGroupChangePolicy{
    "PodFSGroupChangePolicyAlways": 2,
    "PodFSGroupChangePolicyOnRootMismatch": 1,
    "PodFSGroupChangePolicyUnspecified": 0,
}

// PodFSGroupChangePolicyByValue converts a uint8 representing a PodFSGroupChangePolicy into its string name.
var PodFSGroupChangePolicyByValue = map[uint8]string{
    0: "PodFSGroupChangePolicyUnspecified",
    1: "PodFSGroupChangePolicyOnRootMismatch",
    2: "PodFSGroupChangePolicyAlways",
}
// PodPhase is a label for the condition of a pod at the current time.
type PodPhase uint8

// String implements fmt.Stringer.
func (x PodPhase) String() string {
    return PodPhaseByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodPhase) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(13)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodPhase) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(13).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PodPhase.
const (
    PodPhaseUnspecified PodPhase = 0
    PodPhasePending PodPhase = 1
    PodPhaseRunning PodPhase = 2
    PodPhaseSucceeded PodPhase = 3
    PodPhaseFailed PodPhase = 4
    PodPhaseUnknown PodPhase = 5
)

// PodPhaseByName converts a string representing the enumerator into a PodPhase.
var PodPhaseByName = map[string]PodPhase{
    "PodPhaseFailed": 4,
    "PodPhasePending": 1,
    "PodPhaseRunning": 2,
    "PodPhaseSucceeded": 3,
    "PodPhaseUnknown": 5,
    "PodPhaseUnspecified": 0,
}

// PodPhaseByValue converts a uint8 representing a PodPhase into its string name.
var PodPhaseByValue = map[uint8]string{
    0: "PodPhaseUnspecified",
    1: "PodPhasePending",
    2: "PodPhaseRunning",
    3: "PodPhaseSucceeded",
    4: "PodPhaseFailed",
    5: "PodPhaseUnknown",
}
// PodQOSClass defines the QoS class assigned to a pod.
type PodQOSClass uint8

// String implements fmt.Stringer.
func (x PodQOSClass) String() string {
    return PodQOSClassByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodQOSClass) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(14)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodQOSClass) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(14).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PodQOSClass.
const (
    PodQOSClassUnspecified PodQOSClass = 0
    PodQOSClassGuaranteed PodQOSClass = 1
    PodQOSClassBurstable PodQOSClass = 2
    PodQOSClassBestEffort PodQOSClass = 3
)

// PodQOSClassByName converts a string representing the enumerator into a PodQOSClass.
var PodQOSClassByName = map[string]PodQOSClass{
    "PodQOSClassBestEffort": 3,
    "PodQOSClassBurstable": 2,
    "PodQOSClassGuaranteed": 1,
    "PodQOSClassUnspecified": 0,
}

// PodQOSClassByValue converts a uint8 representing a PodQOSClass into its string name.
var PodQOSClassByValue = map[uint8]string{
    0: "PodQOSClassUnspecified",
    1: "PodQOSClassGuaranteed",
    2: "PodQOSClassBurstable",
    3: "PodQOSClassBestEffort",
}
// PodResizeStatus defines the status of pod resize operation.
type PodResizeStatus uint8

// String implements fmt.Stringer.
func (x PodResizeStatus) String() string {
    return PodResizeStatusByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodResizeStatus) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(15)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodResizeStatus) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(15).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PodResizeStatus.
const (
    PodResizeStatusUnspecified PodResizeStatus = 0
    PodResizeStatusProposed PodResizeStatus = 1
    PodResizeStatusInProgress PodResizeStatus = 2
    PodResizeStatusDeferred PodResizeStatus = 3
    PodResizeStatusInfeasible PodResizeStatus = 4
)

// PodResizeStatusByName converts a string representing the enumerator into a PodResizeStatus.
var PodResizeStatusByName = map[string]PodResizeStatus{
    "PodResizeStatusDeferred": 3,
    "PodResizeStatusInProgress": 2,
    "PodResizeStatusInfeasible": 4,
    "PodResizeStatusProposed": 1,
    "PodResizeStatusUnspecified": 0,
}

// PodResizeStatusByValue converts a uint8 representing a PodResizeStatus into its string name.
var PodResizeStatusByValue = map[uint8]string{
    0: "PodResizeStatusUnspecified",
    1: "PodResizeStatusProposed",
    2: "PodResizeStatusInProgress",
    3: "PodResizeStatusDeferred",
    4: "PodResizeStatusInfeasible",
}
// PodSELinuxChangePolicy describes how SELinux labels should be applied.
type PodSELinuxChangePolicy uint8

// String implements fmt.Stringer.
func (x PodSELinuxChangePolicy) String() string {
    return PodSELinuxChangePolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodSELinuxChangePolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(16)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PodSELinuxChangePolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(16).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PodSELinuxChangePolicy.
const (
    PodSELinuxChangePolicyUnspecified PodSELinuxChangePolicy = 0
    PodSELinuxChangePolicyRecursive PodSELinuxChangePolicy = 1
    PodSELinuxChangePolicyMountOption PodSELinuxChangePolicy = 2
)

// PodSELinuxChangePolicyByName converts a string representing the enumerator into a PodSELinuxChangePolicy.
var PodSELinuxChangePolicyByName = map[string]PodSELinuxChangePolicy{
    "PodSELinuxChangePolicyMountOption": 2,
    "PodSELinuxChangePolicyRecursive": 1,
    "PodSELinuxChangePolicyUnspecified": 0,
}

// PodSELinuxChangePolicyByValue converts a uint8 representing a PodSELinuxChangePolicy into its string name.
var PodSELinuxChangePolicyByValue = map[uint8]string{
    0: "PodSELinuxChangePolicyUnspecified",
    1: "PodSELinuxChangePolicyRecursive",
    2: "PodSELinuxChangePolicyMountOption",
}
// PreemptionPolicy describes a policy for preempting pods.
type PreemptionPolicy uint8

// String implements fmt.Stringer.
func (x PreemptionPolicy) String() string {
    return PreemptionPolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PreemptionPolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(17)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PreemptionPolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(17).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PreemptionPolicy.
const (
    PreemptionPolicyUnspecified PreemptionPolicy = 0
    PreemptionPolicyPreemptLowerPriority PreemptionPolicy = 1
    PreemptionPolicyNever PreemptionPolicy = 2
)

// PreemptionPolicyByName converts a string representing the enumerator into a PreemptionPolicy.
var PreemptionPolicyByName = map[string]PreemptionPolicy{
    "PreemptionPolicyNever": 2,
    "PreemptionPolicyPreemptLowerPriority": 1,
    "PreemptionPolicyUnspecified": 0,
}

// PreemptionPolicyByValue converts a uint8 representing a PreemptionPolicy into its string name.
var PreemptionPolicyByValue = map[uint8]string{
    0: "PreemptionPolicyUnspecified",
    1: "PreemptionPolicyPreemptLowerPriority",
    2: "PreemptionPolicyNever",
}
// ProcMountType describes the proc mount type.
type ProcMountType uint8

// String implements fmt.Stringer.
func (x ProcMountType) String() string {
    return ProcMountTypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ProcMountType) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(18)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ProcMountType) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(18).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum ProcMountType.
const (
    ProcMountTypeUnspecified ProcMountType = 0
    ProcMountTypeDefault ProcMountType = 1
    ProcMountTypeUnmasked ProcMountType = 2
)

// ProcMountTypeByName converts a string representing the enumerator into a ProcMountType.
var ProcMountTypeByName = map[string]ProcMountType{
    "ProcMountTypeDefault": 1,
    "ProcMountTypeUnmasked": 2,
    "ProcMountTypeUnspecified": 0,
}

// ProcMountTypeByValue converts a uint8 representing a ProcMountType into its string name.
var ProcMountTypeByValue = map[uint8]string{
    0: "ProcMountTypeUnspecified",
    1: "ProcMountTypeDefault",
    2: "ProcMountTypeUnmasked",
}
// Protocol defines network protocols.
type Protocol uint8

// String implements fmt.Stringer.
func (x Protocol) String() string {
    return ProtocolByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x Protocol) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(19)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x Protocol) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(19).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum Protocol.
const (
    ProtocolUnspecified Protocol = 0
    ProtocolTcp Protocol = 1
    ProtocolUdp Protocol = 2
    ProtocolSctp Protocol = 3
)

// ProtocolByName converts a string representing the enumerator into a Protocol.
var ProtocolByName = map[string]Protocol{
    "ProtocolSctp": 3,
    "ProtocolTcp": 1,
    "ProtocolUdp": 2,
    "ProtocolUnspecified": 0,
}

// ProtocolByValue converts a uint8 representing a Protocol into its string name.
var ProtocolByValue = map[uint8]string{
    0: "ProtocolUnspecified",
    1: "ProtocolTcp",
    2: "ProtocolUdp",
    3: "ProtocolSctp",
}
// PullPolicy describes a policy for if/when to pull a container image.
type PullPolicy uint8

// String implements fmt.Stringer.
func (x PullPolicy) String() string {
    return PullPolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PullPolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(20)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x PullPolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(20).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum PullPolicy.
const (
    PullPolicyUnspecified PullPolicy = 0
    PullPolicyAlways PullPolicy = 1
    PullPolicyNever PullPolicy = 2
    PullPolicyIfNotPresent PullPolicy = 3
)

// PullPolicyByName converts a string representing the enumerator into a PullPolicy.
var PullPolicyByName = map[string]PullPolicy{
    "PullPolicyAlways": 1,
    "PullPolicyIfNotPresent": 3,
    "PullPolicyNever": 2,
    "PullPolicyUnspecified": 0,
}

// PullPolicyByValue converts a uint8 representing a PullPolicy into its string name.
var PullPolicyByValue = map[uint8]string{
    0: "PullPolicyUnspecified",
    1: "PullPolicyAlways",
    2: "PullPolicyNever",
    3: "PullPolicyIfNotPresent",
}
// RecursiveReadOnlyMode describes how the recursive read-only mode should be handled.
type RecursiveReadOnlyMode uint8

// String implements fmt.Stringer.
func (x RecursiveReadOnlyMode) String() string {
    return RecursiveReadOnlyModeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x RecursiveReadOnlyMode) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(21)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x RecursiveReadOnlyMode) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(21).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum RecursiveReadOnlyMode.
const (
    RecursiveReadOnlyModeUnspecified RecursiveReadOnlyMode = 0
    RecursiveReadOnlyModeDisabled RecursiveReadOnlyMode = 1
    RecursiveReadOnlyModeIfPossible RecursiveReadOnlyMode = 2
    RecursiveReadOnlyModeEnabled RecursiveReadOnlyMode = 3
)

// RecursiveReadOnlyModeByName converts a string representing the enumerator into a RecursiveReadOnlyMode.
var RecursiveReadOnlyModeByName = map[string]RecursiveReadOnlyMode{
    "RecursiveReadOnlyModeDisabled": 1,
    "RecursiveReadOnlyModeEnabled": 3,
    "RecursiveReadOnlyModeIfPossible": 2,
    "RecursiveReadOnlyModeUnspecified": 0,
}

// RecursiveReadOnlyModeByValue converts a uint8 representing a RecursiveReadOnlyMode into its string name.
var RecursiveReadOnlyModeByValue = map[uint8]string{
    0: "RecursiveReadOnlyModeUnspecified",
    1: "RecursiveReadOnlyModeDisabled",
    2: "RecursiveReadOnlyModeIfPossible",
    3: "RecursiveReadOnlyModeEnabled",
}
// ResourceResizeRestartPolicy describes the restart policy for container resource resize.
type ResourceResizeRestartPolicy uint8

// String implements fmt.Stringer.
func (x ResourceResizeRestartPolicy) String() string {
    return ResourceResizeRestartPolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ResourceResizeRestartPolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(22)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x ResourceResizeRestartPolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(22).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum ResourceResizeRestartPolicy.
const (
    ResourceResizeRestartPolicyUnspecified ResourceResizeRestartPolicy = 0
    ResourceResizeRestartPolicyNotRequired ResourceResizeRestartPolicy = 1
    ResourceResizeRestartPolicyRestartContainer ResourceResizeRestartPolicy = 2
)

// ResourceResizeRestartPolicyByName converts a string representing the enumerator into a ResourceResizeRestartPolicy.
var ResourceResizeRestartPolicyByName = map[string]ResourceResizeRestartPolicy{
    "ResourceResizeRestartPolicyNotRequired": 1,
    "ResourceResizeRestartPolicyRestartContainer": 2,
    "ResourceResizeRestartPolicyUnspecified": 0,
}

// ResourceResizeRestartPolicyByValue converts a uint8 representing a ResourceResizeRestartPolicy into its string name.
var ResourceResizeRestartPolicyByValue = map[uint8]string{
    0: "ResourceResizeRestartPolicyUnspecified",
    1: "ResourceResizeRestartPolicyNotRequired",
    2: "ResourceResizeRestartPolicyRestartContainer",
}
// RestartPolicy describes how the container should be restarted.
type RestartPolicy uint8

// String implements fmt.Stringer.
func (x RestartPolicy) String() string {
    return RestartPolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x RestartPolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(23)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x RestartPolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(23).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum RestartPolicy.
const (
    RestartPolicyUnspecified RestartPolicy = 0
    RestartPolicyAlways RestartPolicy = 1
    RestartPolicyOnFailure RestartPolicy = 2
    RestartPolicyNever RestartPolicy = 3
)

// RestartPolicyByName converts a string representing the enumerator into a RestartPolicy.
var RestartPolicyByName = map[string]RestartPolicy{
    "RestartPolicyAlways": 1,
    "RestartPolicyNever": 3,
    "RestartPolicyOnFailure": 2,
    "RestartPolicyUnspecified": 0,
}

// RestartPolicyByValue converts a uint8 representing a RestartPolicy into its string name.
var RestartPolicyByValue = map[uint8]string{
    0: "RestartPolicyUnspecified",
    1: "RestartPolicyAlways",
    2: "RestartPolicyOnFailure",
    3: "RestartPolicyNever",
}
// SeccompProfileType describes the seccomp profile type.
type SeccompProfileType uint8

// String implements fmt.Stringer.
func (x SeccompProfileType) String() string {
    return SeccompProfileTypeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x SeccompProfileType) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(24)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x SeccompProfileType) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(24).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum SeccompProfileType.
const (
    SeccompProfileTypeUnspecified SeccompProfileType = 0
    SeccompProfileTypeUnconfined SeccompProfileType = 1
    SeccompProfileTypeRuntimeDefault SeccompProfileType = 2
    SeccompProfileTypeLocalhost SeccompProfileType = 3
)

// SeccompProfileTypeByName converts a string representing the enumerator into a SeccompProfileType.
var SeccompProfileTypeByName = map[string]SeccompProfileType{
    "SeccompProfileTypeLocalhost": 3,
    "SeccompProfileTypeRuntimeDefault": 2,
    "SeccompProfileTypeUnconfined": 1,
    "SeccompProfileTypeUnspecified": 0,
}

// SeccompProfileTypeByValue converts a uint8 representing a SeccompProfileType into its string name.
var SeccompProfileTypeByValue = map[uint8]string{
    0: "SeccompProfileTypeUnspecified",
    1: "SeccompProfileTypeUnconfined",
    2: "SeccompProfileTypeRuntimeDefault",
    3: "SeccompProfileTypeLocalhost",
}
// StorageMedium defines the storage medium.
type StorageMedium uint8

// String implements fmt.Stringer.
func (x StorageMedium) String() string {
    return StorageMediumByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x StorageMedium) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(25)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x StorageMedium) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(25).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum StorageMedium.
const (
    StorageMediumUnspecified StorageMedium = 0
    StorageMediumDefault StorageMedium = 1
    StorageMediumMemory StorageMedium = 2
    StorageMediumHugePages StorageMedium = 3
    StorageMediumHugePages2Mi StorageMedium = 4
    StorageMediumHugePages1Gi StorageMedium = 5
)

// StorageMediumByName converts a string representing the enumerator into a StorageMedium.
var StorageMediumByName = map[string]StorageMedium{
    "StorageMediumDefault": 1,
    "StorageMediumHugePages": 3,
    "StorageMediumHugePages1Gi": 5,
    "StorageMediumHugePages2Mi": 4,
    "StorageMediumMemory": 2,
    "StorageMediumUnspecified": 0,
}

// StorageMediumByValue converts a uint8 representing a StorageMedium into its string name.
var StorageMediumByValue = map[uint8]string{
    0: "StorageMediumUnspecified",
    1: "StorageMediumDefault",
    2: "StorageMediumMemory",
    3: "StorageMediumHugePages",
    4: "StorageMediumHugePages2Mi",
    5: "StorageMediumHugePages1Gi",
}
// SupplementalGroupsPolicy describes supplemental groups policy.
type SupplementalGroupsPolicy uint8

// String implements fmt.Stringer.
func (x SupplementalGroupsPolicy) String() string {
    return SupplementalGroupsPolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x SupplementalGroupsPolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(26)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x SupplementalGroupsPolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(26).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum SupplementalGroupsPolicy.
const (
    SupplementalGroupsPolicyUnspecified SupplementalGroupsPolicy = 0
    SupplementalGroupsPolicyMerge SupplementalGroupsPolicy = 1
    SupplementalGroupsPolicyStrict SupplementalGroupsPolicy = 2
)

// SupplementalGroupsPolicyByName converts a string representing the enumerator into a SupplementalGroupsPolicy.
var SupplementalGroupsPolicyByName = map[string]SupplementalGroupsPolicy{
    "SupplementalGroupsPolicyMerge": 1,
    "SupplementalGroupsPolicyStrict": 2,
    "SupplementalGroupsPolicyUnspecified": 0,
}

// SupplementalGroupsPolicyByValue converts a uint8 representing a SupplementalGroupsPolicy into its string name.
var SupplementalGroupsPolicyByValue = map[uint8]string{
    0: "SupplementalGroupsPolicyUnspecified",
    1: "SupplementalGroupsPolicyMerge",
    2: "SupplementalGroupsPolicyStrict",
}
// TaintEffect describes the effect of a taint.
type TaintEffect uint8

// String implements fmt.Stringer.
func (x TaintEffect) String() string {
    return TaintEffectByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x TaintEffect) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(27)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x TaintEffect) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(27).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum TaintEffect.
const (
    TaintEffectUnspecified TaintEffect = 0
    TaintEffectNoSchedule TaintEffect = 1
    TaintEffectPreferNoSchedule TaintEffect = 2
    TaintEffectNoExecute TaintEffect = 3
)

// TaintEffectByName converts a string representing the enumerator into a TaintEffect.
var TaintEffectByName = map[string]TaintEffect{
    "TaintEffectNoExecute": 3,
    "TaintEffectNoSchedule": 1,
    "TaintEffectPreferNoSchedule": 2,
    "TaintEffectUnspecified": 0,
}

// TaintEffectByValue converts a uint8 representing a TaintEffect into its string name.
var TaintEffectByValue = map[uint8]string{
    0: "TaintEffectUnspecified",
    1: "TaintEffectNoSchedule",
    2: "TaintEffectPreferNoSchedule",
    3: "TaintEffectNoExecute",
}
// TerminationMessagePolicy describes how termination messages are retrieved.
type TerminationMessagePolicy uint8

// String implements fmt.Stringer.
func (x TerminationMessagePolicy) String() string {
    return TerminationMessagePolicyByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x TerminationMessagePolicy) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(28)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x TerminationMessagePolicy) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(28).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum TerminationMessagePolicy.
const (
    TerminationMessagePolicyUnspecified TerminationMessagePolicy = 0
    TerminationMessagePolicyFile TerminationMessagePolicy = 1
    TerminationMessagePolicyFallbackToLogsOnError TerminationMessagePolicy = 2
)

// TerminationMessagePolicyByName converts a string representing the enumerator into a TerminationMessagePolicy.
var TerminationMessagePolicyByName = map[string]TerminationMessagePolicy{
    "TerminationMessagePolicyFallbackToLogsOnError": 2,
    "TerminationMessagePolicyFile": 1,
    "TerminationMessagePolicyUnspecified": 0,
}

// TerminationMessagePolicyByValue converts a uint8 representing a TerminationMessagePolicy into its string name.
var TerminationMessagePolicyByValue = map[uint8]string{
    0: "TerminationMessagePolicyUnspecified",
    1: "TerminationMessagePolicyFile",
    2: "TerminationMessagePolicyFallbackToLogsOnError",
}
// TolerationOperator represents a toleration operator.
type TolerationOperator uint8

// String implements fmt.Stringer.
func (x TolerationOperator) String() string {
    return TolerationOperatorByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x TolerationOperator) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(29)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x TolerationOperator) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(29).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum TolerationOperator.
const (
    TolerationOperatorUnspecified TolerationOperator = 0
    TolerationOperatorExists TolerationOperator = 1
    TolerationOperatorEqual TolerationOperator = 2
)

// TolerationOperatorByName converts a string representing the enumerator into a TolerationOperator.
var TolerationOperatorByName = map[string]TolerationOperator{
    "TolerationOperatorEqual": 2,
    "TolerationOperatorExists": 1,
    "TolerationOperatorUnspecified": 0,
}

// TolerationOperatorByValue converts a uint8 representing a TolerationOperator into its string name.
var TolerationOperatorByValue = map[uint8]string{
    0: "TolerationOperatorUnspecified",
    1: "TolerationOperatorExists",
    2: "TolerationOperatorEqual",
}
// URIScheme defines URI schemes.
type URIScheme uint8

// String implements fmt.Stringer.
func (x URIScheme) String() string {
    return URISchemeByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x URIScheme) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(30)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x URIScheme) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(30).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum URIScheme.
const (
    URISchemeUnspecified URIScheme = 0
    URISchemeHttp URIScheme = 1
    URISchemeHttps URIScheme = 2
)

// URISchemeByName converts a string representing the enumerator into a URIScheme.
var URISchemeByName = map[string]URIScheme{
    "URISchemeHttp": 1,
    "URISchemeHttps": 2,
    "URISchemeUnspecified": 0,
}

// URISchemeByValue converts a uint8 representing a URIScheme into its string name.
var URISchemeByValue = map[uint8]string{
    0: "URISchemeUnspecified",
    1: "URISchemeHttp",
    2: "URISchemeHttps",
}
// UnsatisfiableConstraintAction describes what to do when constraints can't be satisfied.
type UnsatisfiableConstraintAction uint8

// String implements fmt.Stringer.
func (x UnsatisfiableConstraintAction) String() string {
    return UnsatisfiableConstraintActionByValue[uint8(x)]
}

// XXXEnumGroup will return the EnumGroup descriptor for this group of enumerators.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x UnsatisfiableConstraintAction) XXXEnumGroup() reflect.EnumGroup {
    return XXXEnumGroups.Get(31)
}

// XXXEnumGroup will return the EnumValueDescr descriptor for an enumerated value.
// This should only be used by the reflect package and is has no compatibility promises
// like all XXX fields.
func (x UnsatisfiableConstraintAction) XXXEnumValueDescr() reflect.EnumValueDescr {
    return XXXEnumGroups.Get(31).ByValue(uint16(x))
}
// This is a set of all constants representing enumerated values for enum UnsatisfiableConstraintAction.
const (
    UnsatisfiableConstraintActionUnspecified UnsatisfiableConstraintAction = 0
    UnsatisfiableConstraintActionDoNotSchedule UnsatisfiableConstraintAction = 1
    UnsatisfiableConstraintActionScheduleAnyway UnsatisfiableConstraintAction = 2
)

// UnsatisfiableConstraintActionByName converts a string representing the enumerator into a UnsatisfiableConstraintAction.
var UnsatisfiableConstraintActionByName = map[string]UnsatisfiableConstraintAction{
    "UnsatisfiableConstraintActionDoNotSchedule": 1,
    "UnsatisfiableConstraintActionScheduleAnyway": 2,
    "UnsatisfiableConstraintActionUnspecified": 0,
}

// UnsatisfiableConstraintActionByValue converts a uint8 representing a UnsatisfiableConstraintAction into its string name.
var UnsatisfiableConstraintActionByValue = map[uint8]string{
    0: "UnsatisfiableConstraintActionUnspecified",
    1: "UnsatisfiableConstraintActionDoNotSchedule",
    2: "UnsatisfiableConstraintActionScheduleAnyway",
}


// AWSElasticBlockStoreVolumeSource represents an AWS EBS disk.
type AWSElasticBlockStoreVolumeSource struct {
   s *segment.Struct
}

// NewAWSElasticBlockStoreVolumeSource creates a new pooled instance of AWSElasticBlockStoreVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewAWSElasticBlockStoreVolumeSource(ctx context.Context) AWSElasticBlockStoreVolumeSource {
    s := segment.New(ctx, XXXMappingAWSElasticBlockStoreVolumeSource)
    s.SetIsSetEnabled(true)
    return AWSElasticBlockStoreVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x AWSElasticBlockStoreVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewAWSElasticBlockStoreVolumeSourceFrom creates a new AWSElasticBlockStoreVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewAWSElasticBlockStoreVolumeSourceFrom(s *segment.Struct) AWSElasticBlockStoreVolumeSource {
    return AWSElasticBlockStoreVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x AWSElasticBlockStoreVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x AWSElasticBlockStoreVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x AWSElasticBlockStoreVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x AWSElasticBlockStoreVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x AWSElasticBlockStoreVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x AWSElasticBlockStoreVolumeSource) VolumeId() string {
    return segment.GetString(x.s, 0)
}

func (x AWSElasticBlockStoreVolumeSource) SetVolumeId(value string) AWSElasticBlockStoreVolumeSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x AWSElasticBlockStoreVolumeSource) IsSetVolumeId() bool{
    return x.s.HasField(0)
}

func (x AWSElasticBlockStoreVolumeSource) FsType() string {
    return segment.GetString(x.s, 1)
}

func (x AWSElasticBlockStoreVolumeSource) SetFsType(value string) AWSElasticBlockStoreVolumeSource {
    segment.SetString(x.s, 1, value)
    return x
}
func (x AWSElasticBlockStoreVolumeSource) IsSetFsType() bool{
    return x.s.HasField(1)
}

func (x AWSElasticBlockStoreVolumeSource) Partition() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x AWSElasticBlockStoreVolumeSource) SetPartition(value int32) AWSElasticBlockStoreVolumeSource {
    segment.SetInt32(x.s, 2, value)
    return x
}
func (x AWSElasticBlockStoreVolumeSource) IsSetPartition() bool{
    return x.s.HasField(2)
}

func (x AWSElasticBlockStoreVolumeSource) ReadOnly() bool {
    return segment.GetBool(x.s, 3)
}

func (x AWSElasticBlockStoreVolumeSource) SetReadOnly(value bool) AWSElasticBlockStoreVolumeSource {
    segment.SetBool(x.s, 3, value)
    return x
}
func (x AWSElasticBlockStoreVolumeSource) IsSetReadOnly() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x AWSElasticBlockStoreVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x AWSElasticBlockStoreVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x AWSElasticBlockStoreVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashAWSElasticBlockStoreVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x AWSElasticBlockStoreVolumeSource) SetRecording(enabled bool) AWSElasticBlockStoreVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x AWSElasticBlockStoreVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x AWSElasticBlockStoreVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x AWSElasticBlockStoreVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// AWSElasticBlockStoreVolumeSourceRaw is a plain Go struct representation of AWSElasticBlockStoreVolumeSource.
// Zero values are not set (sparse encoding).
type AWSElasticBlockStoreVolumeSourceRaw struct {
    VolumeId string
    FsType string
    Partition int32
    ReadOnly bool
}

// NewAWSElasticBlockStoreVolumeSourceFromRaw creates a new AWSElasticBlockStoreVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewAWSElasticBlockStoreVolumeSourceFromRaw(ctx context.Context, raw AWSElasticBlockStoreVolumeSourceRaw) AWSElasticBlockStoreVolumeSource {
    x := NewAWSElasticBlockStoreVolumeSource(ctx)
    if raw.VolumeId != "" {
        x.SetVolumeId(raw.VolumeId)
    }
    if raw.FsType != "" {
        x.SetFsType(raw.FsType)
    }
    if raw.Partition != 0 {
        x.SetPartition(raw.Partition)
    }
    if raw.ReadOnly {
        x.SetReadOnly(raw.ReadOnly)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x AWSElasticBlockStoreVolumeSource) ToRaw(ctx context.Context) AWSElasticBlockStoreVolumeSourceRaw {
    raw := AWSElasticBlockStoreVolumeSourceRaw{}
    raw.VolumeId = x.VolumeId()
    raw.FsType = x.FsType()
    raw.Partition = x.Partition()
    raw.ReadOnly = x.ReadOnly()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x AWSElasticBlockStoreVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(0)
}

// Affinity is a group of affinity scheduling rules.
type Affinity struct {
   s *segment.Struct
}

// NewAffinity creates a new pooled instance of Affinity.
// Call Release() when done to return it to the pool for reuse.
func NewAffinity(ctx context.Context) Affinity {
    s := segment.New(ctx, XXXMappingAffinity)
    s.SetIsSetEnabled(true)
    return Affinity{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Affinity) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewAffinityFrom creates a new Affinity from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewAffinityFrom(s *segment.Struct) Affinity {
    return Affinity{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Affinity) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Affinity) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Affinity) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Affinity) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Affinity) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Affinity) NodeAffinity() NodeAffinity {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingNodeAffinity)
    return NodeAffinity{s: s}
}

func (x Affinity) SetNodeAffinity(value NodeAffinity) Affinity {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x Affinity) IsSetNodeAffinity() bool{
    return x.s.HasField(0)
}

func (x Affinity) PodAffinity() PodAffinity {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingPodAffinity)
    return PodAffinity{s: s}
}

func (x Affinity) SetPodAffinity(value PodAffinity) Affinity {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x Affinity) IsSetPodAffinity() bool{
    return x.s.HasField(1)
}

func (x Affinity) PodAntiAffinity() PodAntiAffinity {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingPodAntiAffinity)
    return PodAntiAffinity{s: s}
}

func (x Affinity) SetPodAntiAffinity(value PodAntiAffinity) Affinity {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x Affinity) IsSetPodAntiAffinity() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Affinity) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Affinity) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Affinity) XXXTypeHash() [16]byte {
    return XXXTypeHashAffinity
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Affinity) SetRecording(enabled bool) Affinity {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Affinity) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Affinity) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Affinity) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// AffinityRaw is a plain Go struct representation of Affinity.
// Zero values are not set (sparse encoding).
type AffinityRaw struct {
    NodeAffinity *NodeAffinityRaw
    PodAffinity *PodAffinityRaw
    PodAntiAffinity *PodAntiAffinityRaw
}

// NewAffinityFromRaw creates a new Affinity from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewAffinityFromRaw(ctx context.Context, raw AffinityRaw) Affinity {
    x := NewAffinity(ctx)
    if raw.NodeAffinity != nil {
        x.SetNodeAffinity(NewNodeAffinityFromRaw(ctx, *raw.NodeAffinity))
    }
    if raw.PodAffinity != nil {
        x.SetPodAffinity(NewPodAffinityFromRaw(ctx, *raw.PodAffinity))
    }
    if raw.PodAntiAffinity != nil {
        x.SetPodAntiAffinity(NewPodAntiAffinityFromRaw(ctx, *raw.PodAntiAffinity))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Affinity) ToRaw(ctx context.Context) AffinityRaw {
    raw := AffinityRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.NodeAffinity().ToRaw(ctx)
        raw.NodeAffinity = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.PodAffinity().ToRaw(ctx)
        raw.PodAffinity = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.PodAntiAffinity().ToRaw(ctx)
        raw.PodAntiAffinity = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Affinity) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(1)
}

// AppArmorProfile defines a pod/container's AppArmor profile settings.
type AppArmorProfile struct {
   s *segment.Struct
}

// NewAppArmorProfile creates a new pooled instance of AppArmorProfile.
// Call Release() when done to return it to the pool for reuse.
func NewAppArmorProfile(ctx context.Context) AppArmorProfile {
    s := segment.New(ctx, XXXMappingAppArmorProfile)
    s.SetIsSetEnabled(true)
    return AppArmorProfile{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x AppArmorProfile) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewAppArmorProfileFrom creates a new AppArmorProfile from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewAppArmorProfileFrom(s *segment.Struct) AppArmorProfile {
    return AppArmorProfile{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x AppArmorProfile) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x AppArmorProfile) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x AppArmorProfile) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x AppArmorProfile) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x AppArmorProfile) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x AppArmorProfile) Type() AppArmorProfileType {
    return AppArmorProfileType(segment.GetUint8(x.s, 0))
}

func (x AppArmorProfile) SetType(value AppArmorProfileType) AppArmorProfile {
    segment.SetUint8(x.s, 0, uint8(value))
    return x
}
func (x AppArmorProfile) IsSetType() bool{
    return x.s.HasField(0)
}

func (x AppArmorProfile) LocalhostProfile() string {
    return segment.GetString(x.s, 1)
}

func (x AppArmorProfile) SetLocalhostProfile(value string) AppArmorProfile {
    segment.SetString(x.s, 1, value)
    return x
}
func (x AppArmorProfile) IsSetLocalhostProfile() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x AppArmorProfile) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x AppArmorProfile) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x AppArmorProfile) XXXTypeHash() [16]byte {
    return XXXTypeHashAppArmorProfile
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x AppArmorProfile) SetRecording(enabled bool) AppArmorProfile {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x AppArmorProfile) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x AppArmorProfile) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x AppArmorProfile) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// AppArmorProfileRaw is a plain Go struct representation of AppArmorProfile.
// Zero values are not set (sparse encoding).
type AppArmorProfileRaw struct {
    Type AppArmorProfileType
    LocalhostProfile string
}

// NewAppArmorProfileFromRaw creates a new AppArmorProfile from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewAppArmorProfileFromRaw(ctx context.Context, raw AppArmorProfileRaw) AppArmorProfile {
    x := NewAppArmorProfile(ctx)
    if raw.Type != 0 {
        x.SetType(raw.Type)
    }
    if raw.LocalhostProfile != "" {
        x.SetLocalhostProfile(raw.LocalhostProfile)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x AppArmorProfile) ToRaw(ctx context.Context) AppArmorProfileRaw {
    raw := AppArmorProfileRaw{}
    raw.Type = x.Type()
    raw.LocalhostProfile = x.LocalhostProfile()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x AppArmorProfile) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(2)
}

// CSIVolumeSource represents a CSI volume.
type CSIVolumeSource struct {
   s *segment.Struct
}

// NewCSIVolumeSource creates a new pooled instance of CSIVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewCSIVolumeSource(ctx context.Context) CSIVolumeSource {
    s := segment.New(ctx, XXXMappingCSIVolumeSource)
    s.SetIsSetEnabled(true)
    return CSIVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x CSIVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewCSIVolumeSourceFrom creates a new CSIVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewCSIVolumeSourceFrom(s *segment.Struct) CSIVolumeSource {
    return CSIVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x CSIVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x CSIVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x CSIVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x CSIVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x CSIVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x CSIVolumeSource) Driver() string {
    return segment.GetString(x.s, 0)
}

func (x CSIVolumeSource) SetDriver(value string) CSIVolumeSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x CSIVolumeSource) IsSetDriver() bool{
    return x.s.HasField(0)
}

func (x CSIVolumeSource) ReadOnly() bool {
    return segment.GetBool(x.s, 1)
}

func (x CSIVolumeSource) SetReadOnly(value bool) CSIVolumeSource {
    segment.SetBool(x.s, 1, value)
    return x
}
func (x CSIVolumeSource) IsSetReadOnly() bool{
    return x.s.HasField(1)
}

func (x CSIVolumeSource) FsType() string {
    return segment.GetString(x.s, 2)
}

func (x CSIVolumeSource) SetFsType(value string) CSIVolumeSource {
    segment.SetString(x.s, 2, value)
    return x
}
func (x CSIVolumeSource) IsSetFsType() bool{
    return x.s.HasField(2)
}

// VolumeAttributesList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x CSIVolumeSource) VolumeAttributesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 3, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 3, XXXMappingKeyValue)
    return structs
}

// VolumeAttributesLen returns the number of items in the list.
func (x CSIVolumeSource) VolumeAttributesLen(ctx context.Context) int {
    return x.VolumeAttributesList(ctx).Len()
}

// VolumeAttributesGet returns the item at the given index.
func (x CSIVolumeSource) VolumeAttributesGet(ctx context.Context, index int) KeyValue {
    s := x.VolumeAttributesList(ctx).Get(index)
    return KeyValue{s: s}
}

// VolumeAttributesAppend appends items to the list.
func (x CSIVolumeSource) VolumeAttributesAppend(ctx context.Context, values ...KeyValue) {
    list := x.VolumeAttributesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// VolumeAttributesAppendRaw appends items to the list using Raw struct representations.
func (x CSIVolumeSource) VolumeAttributesAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.VolumeAttributesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x CSIVolumeSource) IsSetVolumeAttributes() bool{
    return x.s.HasField(3)
}

func (x CSIVolumeSource) NodePublishSecretRef() LocalObjectReference {
    s := segment.GetNestedStruct(x.s, 4, XXXMappingLocalObjectReference)
    return LocalObjectReference{s: s}
}

func (x CSIVolumeSource) SetNodePublishSecretRef(value LocalObjectReference) CSIVolumeSource {
    segment.SetNestedStruct(x.s, 4, value.XXXGetStruct())
    return x
}
func (x CSIVolumeSource) IsSetNodePublishSecretRef() bool{
    return x.s.HasField(4)
}



// ClawStruct returns a reflection type representing the Struct.
func (x CSIVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x CSIVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x CSIVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashCSIVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x CSIVolumeSource) SetRecording(enabled bool) CSIVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x CSIVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x CSIVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x CSIVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// CSIVolumeSourceRaw is a plain Go struct representation of CSIVolumeSource.
// Zero values are not set (sparse encoding).
type CSIVolumeSourceRaw struct {
    Driver string
    ReadOnly bool
    FsType string
    VolumeAttributes []*KeyValueRaw
    NodePublishSecretRef *LocalObjectReferenceRaw
}

// NewCSIVolumeSourceFromRaw creates a new CSIVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewCSIVolumeSourceFromRaw(ctx context.Context, raw CSIVolumeSourceRaw) CSIVolumeSource {
    x := NewCSIVolumeSource(ctx)
    if raw.Driver != "" {
        x.SetDriver(raw.Driver)
    }
    if raw.ReadOnly {
        x.SetReadOnly(raw.ReadOnly)
    }
    if raw.FsType != "" {
        x.SetFsType(raw.FsType)
    }
    if raw.VolumeAttributes != nil {
        list := x.VolumeAttributesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.VolumeAttributes))
        for _, r := range raw.VolumeAttributes {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.NodePublishSecretRef != nil {
        x.SetNodePublishSecretRef(NewLocalObjectReferenceFromRaw(ctx, *raw.NodePublishSecretRef))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x CSIVolumeSource) ToRaw(ctx context.Context) CSIVolumeSourceRaw {
    raw := CSIVolumeSourceRaw{}
    raw.Driver = x.Driver()
    raw.ReadOnly = x.ReadOnly()
    raw.FsType = x.FsType()
    if l := x.s.GetList(3); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.VolumeAttributes = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeAttributes[i] = &itemRaw
        }
    } else if x.s.HasField(3) {
        list := x.VolumeAttributesList(ctx)
        raw.VolumeAttributes = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeAttributes[i] = &itemRaw
        }
    }
    if x.s.HasField(4) {
        nestedRaw := x.NodePublishSecretRef().ToRaw(ctx)
        raw.NodePublishSecretRef = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x CSIVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(3)
}

// Capabilities represent POSIX capabilities to add/drop.
type Capabilities struct {
   s *segment.Struct
}

// NewCapabilities creates a new pooled instance of Capabilities.
// Call Release() when done to return it to the pool for reuse.
func NewCapabilities(ctx context.Context) Capabilities {
    s := segment.New(ctx, XXXMappingCapabilities)
    s.SetIsSetEnabled(true)
    return Capabilities{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Capabilities) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewCapabilitiesFrom creates a new Capabilities from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewCapabilitiesFrom(s *segment.Struct) Capabilities {
    return Capabilities{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Capabilities) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Capabilities) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Capabilities) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Capabilities) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Capabilities) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Capabilities) Add() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 0); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 0)
    return strs
}

// SetAdd replaces all values in the string list.
func (x Capabilities) SetAdd(v ...string) Capabilities {
    strs := x.Add()
    strs.SetAll(v)
    return x
}
func (x Capabilities) IsSetAdd() bool{
    return x.s.HasField(0)
}

func (x Capabilities) Drop() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 1); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 1)
    return strs
}

// SetDrop replaces all values in the string list.
func (x Capabilities) SetDrop(v ...string) Capabilities {
    strs := x.Drop()
    strs.SetAll(v)
    return x
}
func (x Capabilities) IsSetDrop() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Capabilities) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Capabilities) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Capabilities) XXXTypeHash() [16]byte {
    return XXXTypeHashCapabilities
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Capabilities) SetRecording(enabled bool) Capabilities {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Capabilities) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Capabilities) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Capabilities) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// CapabilitiesRaw is a plain Go struct representation of Capabilities.
// Zero values are not set (sparse encoding).
type CapabilitiesRaw struct {
    Add []string
    Drop []string
}

// NewCapabilitiesFromRaw creates a new Capabilities from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewCapabilitiesFromRaw(ctx context.Context, raw CapabilitiesRaw) Capabilities {
    x := NewCapabilities(ctx)
    if raw.Add != nil {
        x.SetAdd(raw.Add...)
    }
    if raw.Drop != nil {
        x.SetDrop(raw.Drop...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Capabilities) ToRaw(ctx context.Context) CapabilitiesRaw {
    raw := CapabilitiesRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Add = l.(*segment.Strings).Slice()
    } else if x.s.HasField(0) {
        raw.Add = x.Add().Slice()
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Drop = l.(*segment.Strings).Slice()
    } else if x.s.HasField(1) {
        raw.Drop = x.Drop().Slice()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Capabilities) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(4)
}

// ClusterTrustBundleProjection describes how to select ClusterTrustBundle objects.
type ClusterTrustBundleProjection struct {
   s *segment.Struct
}

// NewClusterTrustBundleProjection creates a new pooled instance of ClusterTrustBundleProjection.
// Call Release() when done to return it to the pool for reuse.
func NewClusterTrustBundleProjection(ctx context.Context) ClusterTrustBundleProjection {
    s := segment.New(ctx, XXXMappingClusterTrustBundleProjection)
    s.SetIsSetEnabled(true)
    return ClusterTrustBundleProjection{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ClusterTrustBundleProjection) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewClusterTrustBundleProjectionFrom creates a new ClusterTrustBundleProjection from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewClusterTrustBundleProjectionFrom(s *segment.Struct) ClusterTrustBundleProjection {
    return ClusterTrustBundleProjection{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ClusterTrustBundleProjection) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ClusterTrustBundleProjection) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ClusterTrustBundleProjection) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ClusterTrustBundleProjection) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ClusterTrustBundleProjection) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ClusterTrustBundleProjection) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ClusterTrustBundleProjection) SetName(value string) ClusterTrustBundleProjection {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ClusterTrustBundleProjection) IsSetName() bool{
    return x.s.HasField(0)
}

func (x ClusterTrustBundleProjection) SignerName() string {
    return segment.GetString(x.s, 1)
}

func (x ClusterTrustBundleProjection) SetSignerName(value string) ClusterTrustBundleProjection {
    segment.SetString(x.s, 1, value)
    return x
}
func (x ClusterTrustBundleProjection) IsSetSignerName() bool{
    return x.s.HasField(1)
}

func (x ClusterTrustBundleProjection) LabelSelector() LabelSelector {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingLabelSelector)
    return LabelSelector{s: s}
}

func (x ClusterTrustBundleProjection) SetLabelSelector(value LabelSelector) ClusterTrustBundleProjection {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x ClusterTrustBundleProjection) IsSetLabelSelector() bool{
    return x.s.HasField(2)
}

func (x ClusterTrustBundleProjection) Optional() bool {
    return segment.GetBool(x.s, 3)
}

func (x ClusterTrustBundleProjection) SetOptional(value bool) ClusterTrustBundleProjection {
    segment.SetBool(x.s, 3, value)
    return x
}
func (x ClusterTrustBundleProjection) IsSetOptional() bool{
    return x.s.HasField(3)
}

func (x ClusterTrustBundleProjection) Path() string {
    return segment.GetString(x.s, 4)
}

func (x ClusterTrustBundleProjection) SetPath(value string) ClusterTrustBundleProjection {
    segment.SetString(x.s, 4, value)
    return x
}
func (x ClusterTrustBundleProjection) IsSetPath() bool{
    return x.s.HasField(4)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ClusterTrustBundleProjection) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ClusterTrustBundleProjection) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ClusterTrustBundleProjection) XXXTypeHash() [16]byte {
    return XXXTypeHashClusterTrustBundleProjection
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ClusterTrustBundleProjection) SetRecording(enabled bool) ClusterTrustBundleProjection {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ClusterTrustBundleProjection) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ClusterTrustBundleProjection) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ClusterTrustBundleProjection) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ClusterTrustBundleProjectionRaw is a plain Go struct representation of ClusterTrustBundleProjection.
// Zero values are not set (sparse encoding).
type ClusterTrustBundleProjectionRaw struct {
    Name string
    SignerName string
    LabelSelector *LabelSelectorRaw
    Optional bool
    Path string
}

// NewClusterTrustBundleProjectionFromRaw creates a new ClusterTrustBundleProjection from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewClusterTrustBundleProjectionFromRaw(ctx context.Context, raw ClusterTrustBundleProjectionRaw) ClusterTrustBundleProjection {
    x := NewClusterTrustBundleProjection(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.SignerName != "" {
        x.SetSignerName(raw.SignerName)
    }
    if raw.LabelSelector != nil {
        x.SetLabelSelector(NewLabelSelectorFromRaw(ctx, *raw.LabelSelector))
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    if raw.Path != "" {
        x.SetPath(raw.Path)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ClusterTrustBundleProjection) ToRaw(ctx context.Context) ClusterTrustBundleProjectionRaw {
    raw := ClusterTrustBundleProjectionRaw{}
    raw.Name = x.Name()
    raw.SignerName = x.SignerName()
    if x.s.HasField(2) {
        nestedRaw := x.LabelSelector().ToRaw(ctx)
        raw.LabelSelector = &nestedRaw
    }
    raw.Optional = x.Optional()
    raw.Path = x.Path()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ClusterTrustBundleProjection) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(5)
}

// ConfigMapEnvSource selects a ConfigMap to populate the environment.
type ConfigMapEnvSource struct {
   s *segment.Struct
}

// NewConfigMapEnvSource creates a new pooled instance of ConfigMapEnvSource.
// Call Release() when done to return it to the pool for reuse.
func NewConfigMapEnvSource(ctx context.Context) ConfigMapEnvSource {
    s := segment.New(ctx, XXXMappingConfigMapEnvSource)
    s.SetIsSetEnabled(true)
    return ConfigMapEnvSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ConfigMapEnvSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewConfigMapEnvSourceFrom creates a new ConfigMapEnvSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewConfigMapEnvSourceFrom(s *segment.Struct) ConfigMapEnvSource {
    return ConfigMapEnvSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ConfigMapEnvSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ConfigMapEnvSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ConfigMapEnvSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ConfigMapEnvSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ConfigMapEnvSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ConfigMapEnvSource) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ConfigMapEnvSource) SetName(value string) ConfigMapEnvSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ConfigMapEnvSource) IsSetName() bool{
    return x.s.HasField(0)
}

func (x ConfigMapEnvSource) Optional() bool {
    return segment.GetBool(x.s, 1)
}

func (x ConfigMapEnvSource) SetOptional(value bool) ConfigMapEnvSource {
    segment.SetBool(x.s, 1, value)
    return x
}
func (x ConfigMapEnvSource) IsSetOptional() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ConfigMapEnvSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ConfigMapEnvSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ConfigMapEnvSource) XXXTypeHash() [16]byte {
    return XXXTypeHashConfigMapEnvSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ConfigMapEnvSource) SetRecording(enabled bool) ConfigMapEnvSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ConfigMapEnvSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ConfigMapEnvSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ConfigMapEnvSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ConfigMapEnvSourceRaw is a plain Go struct representation of ConfigMapEnvSource.
// Zero values are not set (sparse encoding).
type ConfigMapEnvSourceRaw struct {
    Name string
    Optional bool
}

// NewConfigMapEnvSourceFromRaw creates a new ConfigMapEnvSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewConfigMapEnvSourceFromRaw(ctx context.Context, raw ConfigMapEnvSourceRaw) ConfigMapEnvSource {
    x := NewConfigMapEnvSource(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ConfigMapEnvSource) ToRaw(ctx context.Context) ConfigMapEnvSourceRaw {
    raw := ConfigMapEnvSourceRaw{}
    raw.Name = x.Name()
    raw.Optional = x.Optional()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ConfigMapEnvSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(6)
}

// ConfigMapKeySelector selects a key of a ConfigMap.
type ConfigMapKeySelector struct {
   s *segment.Struct
}

// NewConfigMapKeySelector creates a new pooled instance of ConfigMapKeySelector.
// Call Release() when done to return it to the pool for reuse.
func NewConfigMapKeySelector(ctx context.Context) ConfigMapKeySelector {
    s := segment.New(ctx, XXXMappingConfigMapKeySelector)
    s.SetIsSetEnabled(true)
    return ConfigMapKeySelector{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ConfigMapKeySelector) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewConfigMapKeySelectorFrom creates a new ConfigMapKeySelector from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewConfigMapKeySelectorFrom(s *segment.Struct) ConfigMapKeySelector {
    return ConfigMapKeySelector{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ConfigMapKeySelector) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ConfigMapKeySelector) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ConfigMapKeySelector) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ConfigMapKeySelector) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ConfigMapKeySelector) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ConfigMapKeySelector) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ConfigMapKeySelector) SetName(value string) ConfigMapKeySelector {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ConfigMapKeySelector) IsSetName() bool{
    return x.s.HasField(0)
}

func (x ConfigMapKeySelector) Key() string {
    return segment.GetString(x.s, 1)
}

func (x ConfigMapKeySelector) SetKey(value string) ConfigMapKeySelector {
    segment.SetString(x.s, 1, value)
    return x
}
func (x ConfigMapKeySelector) IsSetKey() bool{
    return x.s.HasField(1)
}

func (x ConfigMapKeySelector) Optional() bool {
    return segment.GetBool(x.s, 2)
}

func (x ConfigMapKeySelector) SetOptional(value bool) ConfigMapKeySelector {
    segment.SetBool(x.s, 2, value)
    return x
}
func (x ConfigMapKeySelector) IsSetOptional() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ConfigMapKeySelector) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ConfigMapKeySelector) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ConfigMapKeySelector) XXXTypeHash() [16]byte {
    return XXXTypeHashConfigMapKeySelector
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ConfigMapKeySelector) SetRecording(enabled bool) ConfigMapKeySelector {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ConfigMapKeySelector) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ConfigMapKeySelector) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ConfigMapKeySelector) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ConfigMapKeySelectorRaw is a plain Go struct representation of ConfigMapKeySelector.
// Zero values are not set (sparse encoding).
type ConfigMapKeySelectorRaw struct {
    Name string
    Key string
    Optional bool
}

// NewConfigMapKeySelectorFromRaw creates a new ConfigMapKeySelector from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewConfigMapKeySelectorFromRaw(ctx context.Context, raw ConfigMapKeySelectorRaw) ConfigMapKeySelector {
    x := NewConfigMapKeySelector(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Key != "" {
        x.SetKey(raw.Key)
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ConfigMapKeySelector) ToRaw(ctx context.Context) ConfigMapKeySelectorRaw {
    raw := ConfigMapKeySelectorRaw{}
    raw.Name = x.Name()
    raw.Key = x.Key()
    raw.Optional = x.Optional()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ConfigMapKeySelector) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(7)
}

// ConfigMapProjection adapts a ConfigMap into a projected volume.
type ConfigMapProjection struct {
   s *segment.Struct
}

// NewConfigMapProjection creates a new pooled instance of ConfigMapProjection.
// Call Release() when done to return it to the pool for reuse.
func NewConfigMapProjection(ctx context.Context) ConfigMapProjection {
    s := segment.New(ctx, XXXMappingConfigMapProjection)
    s.SetIsSetEnabled(true)
    return ConfigMapProjection{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ConfigMapProjection) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewConfigMapProjectionFrom creates a new ConfigMapProjection from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewConfigMapProjectionFrom(s *segment.Struct) ConfigMapProjection {
    return ConfigMapProjection{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ConfigMapProjection) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ConfigMapProjection) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ConfigMapProjection) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ConfigMapProjection) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ConfigMapProjection) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ConfigMapProjection) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ConfigMapProjection) SetName(value string) ConfigMapProjection {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ConfigMapProjection) IsSetName() bool{
    return x.s.HasField(0)
}

// ItemsList returns the underlying Structs list for iteration.
// Use NewKeyToPath() to create items and Append to add them.
func (x ConfigMapProjection) ItemsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingKeyToPath); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingKeyToPath)
    return structs
}

// ItemsLen returns the number of items in the list.
func (x ConfigMapProjection) ItemsLen(ctx context.Context) int {
    return x.ItemsList(ctx).Len()
}

// ItemsGet returns the item at the given index.
func (x ConfigMapProjection) ItemsGet(ctx context.Context, index int) KeyToPath {
    s := x.ItemsList(ctx).Get(index)
    return KeyToPath{s: s}
}

// ItemsAppend appends items to the list.
func (x ConfigMapProjection) ItemsAppend(ctx context.Context, values ...KeyToPath) {
    list := x.ItemsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ItemsAppendRaw appends items to the list using Raw struct representations.
func (x ConfigMapProjection) ItemsAppendRaw(ctx context.Context, values ...*KeyToPathRaw) {
    list := x.ItemsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyToPathFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ConfigMapProjection) IsSetItems() bool{
    return x.s.HasField(1)
}

func (x ConfigMapProjection) Optional() bool {
    return segment.GetBool(x.s, 2)
}

func (x ConfigMapProjection) SetOptional(value bool) ConfigMapProjection {
    segment.SetBool(x.s, 2, value)
    return x
}
func (x ConfigMapProjection) IsSetOptional() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ConfigMapProjection) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ConfigMapProjection) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ConfigMapProjection) XXXTypeHash() [16]byte {
    return XXXTypeHashConfigMapProjection
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ConfigMapProjection) SetRecording(enabled bool) ConfigMapProjection {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ConfigMapProjection) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ConfigMapProjection) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ConfigMapProjection) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ConfigMapProjectionRaw is a plain Go struct representation of ConfigMapProjection.
// Zero values are not set (sparse encoding).
type ConfigMapProjectionRaw struct {
    Name string
    Items []*KeyToPathRaw
    Optional bool
}

// NewConfigMapProjectionFromRaw creates a new ConfigMapProjection from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewConfigMapProjectionFromRaw(ctx context.Context, raw ConfigMapProjectionRaw) ConfigMapProjection {
    x := NewConfigMapProjection(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Items != nil {
        list := x.ItemsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Items))
        for _, r := range raw.Items {
            if r != nil {
                items = append(items, NewKeyToPathFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ConfigMapProjection) ToRaw(ctx context.Context) ConfigMapProjectionRaw {
    raw := ConfigMapProjectionRaw{}
    raw.Name = x.Name()
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Items = make([]*KeyToPathRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyToPath{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.ItemsList(ctx)
        raw.Items = make([]*KeyToPathRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyToPath{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    }
    raw.Optional = x.Optional()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ConfigMapProjection) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(8)
}

// ConfigMapVolumeSource adapts a ConfigMap into a volume.
type ConfigMapVolumeSource struct {
   s *segment.Struct
}

// NewConfigMapVolumeSource creates a new pooled instance of ConfigMapVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewConfigMapVolumeSource(ctx context.Context) ConfigMapVolumeSource {
    s := segment.New(ctx, XXXMappingConfigMapVolumeSource)
    s.SetIsSetEnabled(true)
    return ConfigMapVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ConfigMapVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewConfigMapVolumeSourceFrom creates a new ConfigMapVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewConfigMapVolumeSourceFrom(s *segment.Struct) ConfigMapVolumeSource {
    return ConfigMapVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ConfigMapVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ConfigMapVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ConfigMapVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ConfigMapVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ConfigMapVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ConfigMapVolumeSource) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ConfigMapVolumeSource) SetName(value string) ConfigMapVolumeSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ConfigMapVolumeSource) IsSetName() bool{
    return x.s.HasField(0)
}

// ItemsList returns the underlying Structs list for iteration.
// Use NewKeyToPath() to create items and Append to add them.
func (x ConfigMapVolumeSource) ItemsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingKeyToPath); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingKeyToPath)
    return structs
}

// ItemsLen returns the number of items in the list.
func (x ConfigMapVolumeSource) ItemsLen(ctx context.Context) int {
    return x.ItemsList(ctx).Len()
}

// ItemsGet returns the item at the given index.
func (x ConfigMapVolumeSource) ItemsGet(ctx context.Context, index int) KeyToPath {
    s := x.ItemsList(ctx).Get(index)
    return KeyToPath{s: s}
}

// ItemsAppend appends items to the list.
func (x ConfigMapVolumeSource) ItemsAppend(ctx context.Context, values ...KeyToPath) {
    list := x.ItemsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ItemsAppendRaw appends items to the list using Raw struct representations.
func (x ConfigMapVolumeSource) ItemsAppendRaw(ctx context.Context, values ...*KeyToPathRaw) {
    list := x.ItemsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyToPathFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ConfigMapVolumeSource) IsSetItems() bool{
    return x.s.HasField(1)
}

func (x ConfigMapVolumeSource) DefaultMode() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x ConfigMapVolumeSource) SetDefaultMode(value int32) ConfigMapVolumeSource {
    segment.SetInt32(x.s, 2, value)
    return x
}
func (x ConfigMapVolumeSource) IsSetDefaultMode() bool{
    return x.s.HasField(2)
}

func (x ConfigMapVolumeSource) Optional() bool {
    return segment.GetBool(x.s, 3)
}

func (x ConfigMapVolumeSource) SetOptional(value bool) ConfigMapVolumeSource {
    segment.SetBool(x.s, 3, value)
    return x
}
func (x ConfigMapVolumeSource) IsSetOptional() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ConfigMapVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ConfigMapVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ConfigMapVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashConfigMapVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ConfigMapVolumeSource) SetRecording(enabled bool) ConfigMapVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ConfigMapVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ConfigMapVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ConfigMapVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ConfigMapVolumeSourceRaw is a plain Go struct representation of ConfigMapVolumeSource.
// Zero values are not set (sparse encoding).
type ConfigMapVolumeSourceRaw struct {
    Name string
    Items []*KeyToPathRaw
    DefaultMode int32
    Optional bool
}

// NewConfigMapVolumeSourceFromRaw creates a new ConfigMapVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewConfigMapVolumeSourceFromRaw(ctx context.Context, raw ConfigMapVolumeSourceRaw) ConfigMapVolumeSource {
    x := NewConfigMapVolumeSource(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Items != nil {
        list := x.ItemsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Items))
        for _, r := range raw.Items {
            if r != nil {
                items = append(items, NewKeyToPathFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.DefaultMode != 0 {
        x.SetDefaultMode(raw.DefaultMode)
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ConfigMapVolumeSource) ToRaw(ctx context.Context) ConfigMapVolumeSourceRaw {
    raw := ConfigMapVolumeSourceRaw{}
    raw.Name = x.Name()
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Items = make([]*KeyToPathRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyToPath{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.ItemsList(ctx)
        raw.Items = make([]*KeyToPathRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyToPath{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    }
    raw.DefaultMode = x.DefaultMode()
    raw.Optional = x.Optional()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ConfigMapVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(9)
}

// Container represents a single container that is expected to be run on the host.
type Container struct {
   s *segment.Struct
}

// NewContainer creates a new pooled instance of Container.
// Call Release() when done to return it to the pool for reuse.
func NewContainer(ctx context.Context) Container {
    s := segment.New(ctx, XXXMappingContainer)
    s.SetIsSetEnabled(true)
    return Container{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Container) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewContainerFrom creates a new Container from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewContainerFrom(s *segment.Struct) Container {
    return Container{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Container) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Container) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Container) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Container) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Container) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Container) Name() string {
    return segment.GetString(x.s, 0)
}

func (x Container) SetName(value string) Container {
    segment.SetString(x.s, 0, value)
    return x
}
func (x Container) IsSetName() bool{
    return x.s.HasField(0)
}

func (x Container) Image() string {
    return segment.GetString(x.s, 1)
}

func (x Container) SetImage(value string) Container {
    segment.SetString(x.s, 1, value)
    return x
}
func (x Container) IsSetImage() bool{
    return x.s.HasField(1)
}

func (x Container) Command() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 2); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 2)
    return strs
}

// SetCommand replaces all values in the string list.
func (x Container) SetCommand(v ...string) Container {
    strs := x.Command()
    strs.SetAll(v)
    return x
}
func (x Container) IsSetCommand() bool{
    return x.s.HasField(2)
}

func (x Container) Args() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 3); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 3)
    return strs
}

// SetArgs replaces all values in the string list.
func (x Container) SetArgs(v ...string) Container {
    strs := x.Args()
    strs.SetAll(v)
    return x
}
func (x Container) IsSetArgs() bool{
    return x.s.HasField(3)
}

func (x Container) WorkingDir() string {
    return segment.GetString(x.s, 4)
}

func (x Container) SetWorkingDir(value string) Container {
    segment.SetString(x.s, 4, value)
    return x
}
func (x Container) IsSetWorkingDir() bool{
    return x.s.HasField(4)
}

// PortsList returns the underlying Structs list for iteration.
// Use NewContainerPort() to create items and Append to add them.
func (x Container) PortsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 5, XXXMappingContainerPort); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 5, XXXMappingContainerPort)
    return structs
}

// PortsLen returns the number of items in the list.
func (x Container) PortsLen(ctx context.Context) int {
    return x.PortsList(ctx).Len()
}

// PortsGet returns the item at the given index.
func (x Container) PortsGet(ctx context.Context, index int) ContainerPort {
    s := x.PortsList(ctx).Get(index)
    return ContainerPort{s: s}
}

// PortsAppend appends items to the list.
func (x Container) PortsAppend(ctx context.Context, values ...ContainerPort) {
    list := x.PortsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// PortsAppendRaw appends items to the list using Raw struct representations.
func (x Container) PortsAppendRaw(ctx context.Context, values ...*ContainerPortRaw) {
    list := x.PortsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewContainerPortFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Container) IsSetPorts() bool{
    return x.s.HasField(5)
}

// EnvFromList returns the underlying Structs list for iteration.
// Use NewEnvFromSource() to create items and Append to add them.
func (x Container) EnvFromList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 6, XXXMappingEnvFromSource); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 6, XXXMappingEnvFromSource)
    return structs
}

// EnvFromLen returns the number of items in the list.
func (x Container) EnvFromLen(ctx context.Context) int {
    return x.EnvFromList(ctx).Len()
}

// EnvFromGet returns the item at the given index.
func (x Container) EnvFromGet(ctx context.Context, index int) EnvFromSource {
    s := x.EnvFromList(ctx).Get(index)
    return EnvFromSource{s: s}
}

// EnvFromAppend appends items to the list.
func (x Container) EnvFromAppend(ctx context.Context, values ...EnvFromSource) {
    list := x.EnvFromList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// EnvFromAppendRaw appends items to the list using Raw struct representations.
func (x Container) EnvFromAppendRaw(ctx context.Context, values ...*EnvFromSourceRaw) {
    list := x.EnvFromList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewEnvFromSourceFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Container) IsSetEnvFrom() bool{
    return x.s.HasField(6)
}

// EnvList returns the underlying Structs list for iteration.
// Use NewEnvVar() to create items and Append to add them.
func (x Container) EnvList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 7, XXXMappingEnvVar); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 7, XXXMappingEnvVar)
    return structs
}

// EnvLen returns the number of items in the list.
func (x Container) EnvLen(ctx context.Context) int {
    return x.EnvList(ctx).Len()
}

// EnvGet returns the item at the given index.
func (x Container) EnvGet(ctx context.Context, index int) EnvVar {
    s := x.EnvList(ctx).Get(index)
    return EnvVar{s: s}
}

// EnvAppend appends items to the list.
func (x Container) EnvAppend(ctx context.Context, values ...EnvVar) {
    list := x.EnvList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// EnvAppendRaw appends items to the list using Raw struct representations.
func (x Container) EnvAppendRaw(ctx context.Context, values ...*EnvVarRaw) {
    list := x.EnvList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewEnvVarFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Container) IsSetEnv() bool{
    return x.s.HasField(7)
}

func (x Container) Resources() ResourceRequirements {
    s := segment.GetNestedStruct(x.s, 8, XXXMappingResourceRequirements)
    return ResourceRequirements{s: s}
}

func (x Container) SetResources(value ResourceRequirements) Container {
    segment.SetNestedStruct(x.s, 8, value.XXXGetStruct())
    return x
}
func (x Container) IsSetResources() bool{
    return x.s.HasField(8)
}

// ResizePolicyList returns the underlying Structs list for iteration.
// Use NewContainerResizePolicy() to create items and Append to add them.
func (x Container) ResizePolicyList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 9, XXXMappingContainerResizePolicy); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 9, XXXMappingContainerResizePolicy)
    return structs
}

// ResizePolicyLen returns the number of items in the list.
func (x Container) ResizePolicyLen(ctx context.Context) int {
    return x.ResizePolicyList(ctx).Len()
}

// ResizePolicyGet returns the item at the given index.
func (x Container) ResizePolicyGet(ctx context.Context, index int) ContainerResizePolicy {
    s := x.ResizePolicyList(ctx).Get(index)
    return ContainerResizePolicy{s: s}
}

// ResizePolicyAppend appends items to the list.
func (x Container) ResizePolicyAppend(ctx context.Context, values ...ContainerResizePolicy) {
    list := x.ResizePolicyList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ResizePolicyAppendRaw appends items to the list using Raw struct representations.
func (x Container) ResizePolicyAppendRaw(ctx context.Context, values ...*ContainerResizePolicyRaw) {
    list := x.ResizePolicyList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewContainerResizePolicyFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Container) IsSetResizePolicy() bool{
    return x.s.HasField(9)
}

func (x Container) RestartPolicy() ContainerRestartPolicy {
    return ContainerRestartPolicy(segment.GetUint8(x.s, 10))
}

func (x Container) SetRestartPolicy(value ContainerRestartPolicy) Container {
    segment.SetUint8(x.s, 10, uint8(value))
    return x
}
func (x Container) IsSetRestartPolicy() bool{
    return x.s.HasField(10)
}

// VolumeMountsList returns the underlying Structs list for iteration.
// Use NewVolumeMount() to create items and Append to add them.
func (x Container) VolumeMountsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 11, XXXMappingVolumeMount); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 11, XXXMappingVolumeMount)
    return structs
}

// VolumeMountsLen returns the number of items in the list.
func (x Container) VolumeMountsLen(ctx context.Context) int {
    return x.VolumeMountsList(ctx).Len()
}

// VolumeMountsGet returns the item at the given index.
func (x Container) VolumeMountsGet(ctx context.Context, index int) VolumeMount {
    s := x.VolumeMountsList(ctx).Get(index)
    return VolumeMount{s: s}
}

// VolumeMountsAppend appends items to the list.
func (x Container) VolumeMountsAppend(ctx context.Context, values ...VolumeMount) {
    list := x.VolumeMountsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// VolumeMountsAppendRaw appends items to the list using Raw struct representations.
func (x Container) VolumeMountsAppendRaw(ctx context.Context, values ...*VolumeMountRaw) {
    list := x.VolumeMountsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewVolumeMountFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Container) IsSetVolumeMounts() bool{
    return x.s.HasField(11)
}

// VolumeDevicesList returns the underlying Structs list for iteration.
// Use NewVolumeDevice() to create items and Append to add them.
func (x Container) VolumeDevicesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 12, XXXMappingVolumeDevice); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 12, XXXMappingVolumeDevice)
    return structs
}

// VolumeDevicesLen returns the number of items in the list.
func (x Container) VolumeDevicesLen(ctx context.Context) int {
    return x.VolumeDevicesList(ctx).Len()
}

// VolumeDevicesGet returns the item at the given index.
func (x Container) VolumeDevicesGet(ctx context.Context, index int) VolumeDevice {
    s := x.VolumeDevicesList(ctx).Get(index)
    return VolumeDevice{s: s}
}

// VolumeDevicesAppend appends items to the list.
func (x Container) VolumeDevicesAppend(ctx context.Context, values ...VolumeDevice) {
    list := x.VolumeDevicesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// VolumeDevicesAppendRaw appends items to the list using Raw struct representations.
func (x Container) VolumeDevicesAppendRaw(ctx context.Context, values ...*VolumeDeviceRaw) {
    list := x.VolumeDevicesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewVolumeDeviceFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x Container) IsSetVolumeDevices() bool{
    return x.s.HasField(12)
}

func (x Container) LivenessProbe() Probe {
    s := segment.GetNestedStruct(x.s, 13, XXXMappingProbe)
    return Probe{s: s}
}

func (x Container) SetLivenessProbe(value Probe) Container {
    segment.SetNestedStruct(x.s, 13, value.XXXGetStruct())
    return x
}
func (x Container) IsSetLivenessProbe() bool{
    return x.s.HasField(13)
}

func (x Container) ReadinessProbe() Probe {
    s := segment.GetNestedStruct(x.s, 14, XXXMappingProbe)
    return Probe{s: s}
}

func (x Container) SetReadinessProbe(value Probe) Container {
    segment.SetNestedStruct(x.s, 14, value.XXXGetStruct())
    return x
}
func (x Container) IsSetReadinessProbe() bool{
    return x.s.HasField(14)
}

func (x Container) StartupProbe() Probe {
    s := segment.GetNestedStruct(x.s, 15, XXXMappingProbe)
    return Probe{s: s}
}

func (x Container) SetStartupProbe(value Probe) Container {
    segment.SetNestedStruct(x.s, 15, value.XXXGetStruct())
    return x
}
func (x Container) IsSetStartupProbe() bool{
    return x.s.HasField(15)
}

func (x Container) Lifecycle() Lifecycle {
    s := segment.GetNestedStruct(x.s, 16, XXXMappingLifecycle)
    return Lifecycle{s: s}
}

func (x Container) SetLifecycle(value Lifecycle) Container {
    segment.SetNestedStruct(x.s, 16, value.XXXGetStruct())
    return x
}
func (x Container) IsSetLifecycle() bool{
    return x.s.HasField(16)
}

func (x Container) TerminationMessagePath() string {
    return segment.GetString(x.s, 17)
}

func (x Container) SetTerminationMessagePath(value string) Container {
    segment.SetString(x.s, 17, value)
    return x
}
func (x Container) IsSetTerminationMessagePath() bool{
    return x.s.HasField(17)
}

func (x Container) TerminationMessagePolicy() TerminationMessagePolicy {
    return TerminationMessagePolicy(segment.GetUint8(x.s, 18))
}

func (x Container) SetTerminationMessagePolicy(value TerminationMessagePolicy) Container {
    segment.SetUint8(x.s, 18, uint8(value))
    return x
}
func (x Container) IsSetTerminationMessagePolicy() bool{
    return x.s.HasField(18)
}

func (x Container) ImagePullPolicy() PullPolicy {
    return PullPolicy(segment.GetUint8(x.s, 19))
}

func (x Container) SetImagePullPolicy(value PullPolicy) Container {
    segment.SetUint8(x.s, 19, uint8(value))
    return x
}
func (x Container) IsSetImagePullPolicy() bool{
    return x.s.HasField(19)
}

func (x Container) SecurityContext() SecurityContext {
    s := segment.GetNestedStruct(x.s, 20, XXXMappingSecurityContext)
    return SecurityContext{s: s}
}

func (x Container) SetSecurityContext(value SecurityContext) Container {
    segment.SetNestedStruct(x.s, 20, value.XXXGetStruct())
    return x
}
func (x Container) IsSetSecurityContext() bool{
    return x.s.HasField(20)
}

func (x Container) Stdin() bool {
    return segment.GetBool(x.s, 21)
}

func (x Container) SetStdin(value bool) Container {
    segment.SetBool(x.s, 21, value)
    return x
}
func (x Container) IsSetStdin() bool{
    return x.s.HasField(21)
}

func (x Container) StdinOnce() bool {
    return segment.GetBool(x.s, 22)
}

func (x Container) SetStdinOnce(value bool) Container {
    segment.SetBool(x.s, 22, value)
    return x
}
func (x Container) IsSetStdinOnce() bool{
    return x.s.HasField(22)
}

func (x Container) Tty() bool {
    return segment.GetBool(x.s, 23)
}

func (x Container) SetTty(value bool) Container {
    segment.SetBool(x.s, 23, value)
    return x
}
func (x Container) IsSetTty() bool{
    return x.s.HasField(23)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Container) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Container) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Container) XXXTypeHash() [16]byte {
    return XXXTypeHashContainer
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Container) SetRecording(enabled bool) Container {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Container) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Container) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Container) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ContainerRaw is a plain Go struct representation of Container.
// Zero values are not set (sparse encoding).
type ContainerRaw struct {
    Name string
    Image string
    Command []string
    Args []string
    WorkingDir string
    Ports []*ContainerPortRaw
    EnvFrom []*EnvFromSourceRaw
    Env []*EnvVarRaw
    Resources *ResourceRequirementsRaw
    ResizePolicy []*ContainerResizePolicyRaw
    RestartPolicy ContainerRestartPolicy
    VolumeMounts []*VolumeMountRaw
    VolumeDevices []*VolumeDeviceRaw
    LivenessProbe *ProbeRaw
    ReadinessProbe *ProbeRaw
    StartupProbe *ProbeRaw
    Lifecycle *LifecycleRaw
    TerminationMessagePath string
    TerminationMessagePolicy TerminationMessagePolicy
    ImagePullPolicy PullPolicy
    SecurityContext *SecurityContextRaw
    Stdin bool
    StdinOnce bool
    Tty bool
}

// NewContainerFromRaw creates a new Container from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewContainerFromRaw(ctx context.Context, raw ContainerRaw) Container {
    x := NewContainer(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Image != "" {
        x.SetImage(raw.Image)
    }
    if raw.Command != nil {
        x.SetCommand(raw.Command...)
    }
    if raw.Args != nil {
        x.SetArgs(raw.Args...)
    }
    if raw.WorkingDir != "" {
        x.SetWorkingDir(raw.WorkingDir)
    }
    if raw.Ports != nil {
        list := x.PortsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Ports))
        for _, r := range raw.Ports {
            if r != nil {
                items = append(items, NewContainerPortFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.EnvFrom != nil {
        list := x.EnvFromList(ctx)
        items := make([]*segment.Struct, 0, len(raw.EnvFrom))
        for _, r := range raw.EnvFrom {
            if r != nil {
                items = append(items, NewEnvFromSourceFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Env != nil {
        list := x.EnvList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Env))
        for _, r := range raw.Env {
            if r != nil {
                items = append(items, NewEnvVarFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Resources != nil {
        x.SetResources(NewResourceRequirementsFromRaw(ctx, *raw.Resources))
    }
    if raw.ResizePolicy != nil {
        list := x.ResizePolicyList(ctx)
        items := make([]*segment.Struct, 0, len(raw.ResizePolicy))
        for _, r := range raw.ResizePolicy {
            if r != nil {
                items = append(items, NewContainerResizePolicyFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.RestartPolicy != 0 {
        x.SetRestartPolicy(raw.RestartPolicy)
    }
    if raw.VolumeMounts != nil {
        list := x.VolumeMountsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.VolumeMounts))
        for _, r := range raw.VolumeMounts {
            if r != nil {
                items = append(items, NewVolumeMountFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.VolumeDevices != nil {
        list := x.VolumeDevicesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.VolumeDevices))
        for _, r := range raw.VolumeDevices {
            if r != nil {
                items = append(items, NewVolumeDeviceFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.LivenessProbe != nil {
        x.SetLivenessProbe(NewProbeFromRaw(ctx, *raw.LivenessProbe))
    }
    if raw.ReadinessProbe != nil {
        x.SetReadinessProbe(NewProbeFromRaw(ctx, *raw.ReadinessProbe))
    }
    if raw.StartupProbe != nil {
        x.SetStartupProbe(NewProbeFromRaw(ctx, *raw.StartupProbe))
    }
    if raw.Lifecycle != nil {
        x.SetLifecycle(NewLifecycleFromRaw(ctx, *raw.Lifecycle))
    }
    if raw.TerminationMessagePath != "" {
        x.SetTerminationMessagePath(raw.TerminationMessagePath)
    }
    if raw.TerminationMessagePolicy != 0 {
        x.SetTerminationMessagePolicy(raw.TerminationMessagePolicy)
    }
    if raw.ImagePullPolicy != 0 {
        x.SetImagePullPolicy(raw.ImagePullPolicy)
    }
    if raw.SecurityContext != nil {
        x.SetSecurityContext(NewSecurityContextFromRaw(ctx, *raw.SecurityContext))
    }
    if raw.Stdin {
        x.SetStdin(raw.Stdin)
    }
    if raw.StdinOnce {
        x.SetStdinOnce(raw.StdinOnce)
    }
    if raw.Tty {
        x.SetTty(raw.Tty)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Container) ToRaw(ctx context.Context) ContainerRaw {
    raw := ContainerRaw{}
    raw.Name = x.Name()
    raw.Image = x.Image()
    if l := x.s.GetList(2); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Command = l.(*segment.Strings).Slice()
    } else if x.s.HasField(2) {
        raw.Command = x.Command().Slice()
    }
    if l := x.s.GetList(3); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Args = l.(*segment.Strings).Slice()
    } else if x.s.HasField(3) {
        raw.Args = x.Args().Slice()
    }
    raw.WorkingDir = x.WorkingDir()
    if l := x.s.GetList(5); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Ports = make([]*ContainerPortRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerPort{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Ports[i] = &itemRaw
        }
    } else if x.s.HasField(5) {
        list := x.PortsList(ctx)
        raw.Ports = make([]*ContainerPortRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerPort{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Ports[i] = &itemRaw
        }
    }
    if l := x.s.GetList(6); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.EnvFrom = make([]*EnvFromSourceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EnvFromSource{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.EnvFrom[i] = &itemRaw
        }
    } else if x.s.HasField(6) {
        list := x.EnvFromList(ctx)
        raw.EnvFrom = make([]*EnvFromSourceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EnvFromSource{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.EnvFrom[i] = &itemRaw
        }
    }
    if l := x.s.GetList(7); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Env = make([]*EnvVarRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EnvVar{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Env[i] = &itemRaw
        }
    } else if x.s.HasField(7) {
        list := x.EnvList(ctx)
        raw.Env = make([]*EnvVarRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EnvVar{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Env[i] = &itemRaw
        }
    }
    if x.s.HasField(8) {
        nestedRaw := x.Resources().ToRaw(ctx)
        raw.Resources = &nestedRaw
    }
    if l := x.s.GetList(9); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.ResizePolicy = make([]*ContainerResizePolicyRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerResizePolicy{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ResizePolicy[i] = &itemRaw
        }
    } else if x.s.HasField(9) {
        list := x.ResizePolicyList(ctx)
        raw.ResizePolicy = make([]*ContainerResizePolicyRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerResizePolicy{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ResizePolicy[i] = &itemRaw
        }
    }
    raw.RestartPolicy = x.RestartPolicy()
    if l := x.s.GetList(11); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.VolumeMounts = make([]*VolumeMountRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeMount{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeMounts[i] = &itemRaw
        }
    } else if x.s.HasField(11) {
        list := x.VolumeMountsList(ctx)
        raw.VolumeMounts = make([]*VolumeMountRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeMount{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeMounts[i] = &itemRaw
        }
    }
    if l := x.s.GetList(12); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.VolumeDevices = make([]*VolumeDeviceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeDevice{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeDevices[i] = &itemRaw
        }
    } else if x.s.HasField(12) {
        list := x.VolumeDevicesList(ctx)
        raw.VolumeDevices = make([]*VolumeDeviceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeDevice{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeDevices[i] = &itemRaw
        }
    }
    if x.s.HasField(13) {
        nestedRaw := x.LivenessProbe().ToRaw(ctx)
        raw.LivenessProbe = &nestedRaw
    }
    if x.s.HasField(14) {
        nestedRaw := x.ReadinessProbe().ToRaw(ctx)
        raw.ReadinessProbe = &nestedRaw
    }
    if x.s.HasField(15) {
        nestedRaw := x.StartupProbe().ToRaw(ctx)
        raw.StartupProbe = &nestedRaw
    }
    if x.s.HasField(16) {
        nestedRaw := x.Lifecycle().ToRaw(ctx)
        raw.Lifecycle = &nestedRaw
    }
    raw.TerminationMessagePath = x.TerminationMessagePath()
    raw.TerminationMessagePolicy = x.TerminationMessagePolicy()
    raw.ImagePullPolicy = x.ImagePullPolicy()
    if x.s.HasField(20) {
        nestedRaw := x.SecurityContext().ToRaw(ctx)
        raw.SecurityContext = &nestedRaw
    }
    raw.Stdin = x.Stdin()
    raw.StdinOnce = x.StdinOnce()
    raw.Tty = x.Tty()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Container) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(10)
}

// ContainerPort represents a network port in a single container.
type ContainerPort struct {
   s *segment.Struct
}

// NewContainerPort creates a new pooled instance of ContainerPort.
// Call Release() when done to return it to the pool for reuse.
func NewContainerPort(ctx context.Context) ContainerPort {
    s := segment.New(ctx, XXXMappingContainerPort)
    s.SetIsSetEnabled(true)
    return ContainerPort{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ContainerPort) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewContainerPortFrom creates a new ContainerPort from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewContainerPortFrom(s *segment.Struct) ContainerPort {
    return ContainerPort{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ContainerPort) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ContainerPort) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ContainerPort) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ContainerPort) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ContainerPort) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ContainerPort) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ContainerPort) SetName(value string) ContainerPort {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ContainerPort) IsSetName() bool{
    return x.s.HasField(0)
}

func (x ContainerPort) HostPort() int32 {
    return segment.GetInt32(x.s, 1)
}

func (x ContainerPort) SetHostPort(value int32) ContainerPort {
    segment.SetInt32(x.s, 1, value)
    return x
}
func (x ContainerPort) IsSetHostPort() bool{
    return x.s.HasField(1)
}

func (x ContainerPort) ContainerPort() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x ContainerPort) SetContainerPort(value int32) ContainerPort {
    segment.SetInt32(x.s, 2, value)
    return x
}
func (x ContainerPort) IsSetContainerPort() bool{
    return x.s.HasField(2)
}

func (x ContainerPort) Protocol() Protocol {
    return Protocol(segment.GetUint8(x.s, 3))
}

func (x ContainerPort) SetProtocol(value Protocol) ContainerPort {
    segment.SetUint8(x.s, 3, uint8(value))
    return x
}
func (x ContainerPort) IsSetProtocol() bool{
    return x.s.HasField(3)
}

func (x ContainerPort) HostIp() string {
    return segment.GetString(x.s, 4)
}

func (x ContainerPort) SetHostIp(value string) ContainerPort {
    segment.SetString(x.s, 4, value)
    return x
}
func (x ContainerPort) IsSetHostIp() bool{
    return x.s.HasField(4)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ContainerPort) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ContainerPort) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ContainerPort) XXXTypeHash() [16]byte {
    return XXXTypeHashContainerPort
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ContainerPort) SetRecording(enabled bool) ContainerPort {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ContainerPort) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ContainerPort) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ContainerPort) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ContainerPortRaw is a plain Go struct representation of ContainerPort.
// Zero values are not set (sparse encoding).
type ContainerPortRaw struct {
    Name string
    HostPort int32
    ContainerPort int32
    Protocol Protocol
    HostIp string
}

// NewContainerPortFromRaw creates a new ContainerPort from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewContainerPortFromRaw(ctx context.Context, raw ContainerPortRaw) ContainerPort {
    x := NewContainerPort(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.HostPort != 0 {
        x.SetHostPort(raw.HostPort)
    }
    if raw.ContainerPort != 0 {
        x.SetContainerPort(raw.ContainerPort)
    }
    if raw.Protocol != 0 {
        x.SetProtocol(raw.Protocol)
    }
    if raw.HostIp != "" {
        x.SetHostIp(raw.HostIp)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ContainerPort) ToRaw(ctx context.Context) ContainerPortRaw {
    raw := ContainerPortRaw{}
    raw.Name = x.Name()
    raw.HostPort = x.HostPort()
    raw.ContainerPort = x.ContainerPort()
    raw.Protocol = x.Protocol()
    raw.HostIp = x.HostIp()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ContainerPort) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(11)
}

// ContainerResizePolicy represents resource resize policy for a container.
type ContainerResizePolicy struct {
   s *segment.Struct
}

// NewContainerResizePolicy creates a new pooled instance of ContainerResizePolicy.
// Call Release() when done to return it to the pool for reuse.
func NewContainerResizePolicy(ctx context.Context) ContainerResizePolicy {
    s := segment.New(ctx, XXXMappingContainerResizePolicy)
    s.SetIsSetEnabled(true)
    return ContainerResizePolicy{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ContainerResizePolicy) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewContainerResizePolicyFrom creates a new ContainerResizePolicy from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewContainerResizePolicyFrom(s *segment.Struct) ContainerResizePolicy {
    return ContainerResizePolicy{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ContainerResizePolicy) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ContainerResizePolicy) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ContainerResizePolicy) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ContainerResizePolicy) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ContainerResizePolicy) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ContainerResizePolicy) ResourceName() string {
    return segment.GetString(x.s, 0)
}

func (x ContainerResizePolicy) SetResourceName(value string) ContainerResizePolicy {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ContainerResizePolicy) IsSetResourceName() bool{
    return x.s.HasField(0)
}

func (x ContainerResizePolicy) RestartPolicy() ResourceResizeRestartPolicy {
    return ResourceResizeRestartPolicy(segment.GetUint8(x.s, 1))
}

func (x ContainerResizePolicy) SetRestartPolicy(value ResourceResizeRestartPolicy) ContainerResizePolicy {
    segment.SetUint8(x.s, 1, uint8(value))
    return x
}
func (x ContainerResizePolicy) IsSetRestartPolicy() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ContainerResizePolicy) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ContainerResizePolicy) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ContainerResizePolicy) XXXTypeHash() [16]byte {
    return XXXTypeHashContainerResizePolicy
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ContainerResizePolicy) SetRecording(enabled bool) ContainerResizePolicy {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ContainerResizePolicy) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ContainerResizePolicy) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ContainerResizePolicy) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ContainerResizePolicyRaw is a plain Go struct representation of ContainerResizePolicy.
// Zero values are not set (sparse encoding).
type ContainerResizePolicyRaw struct {
    ResourceName string
    RestartPolicy ResourceResizeRestartPolicy
}

// NewContainerResizePolicyFromRaw creates a new ContainerResizePolicy from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewContainerResizePolicyFromRaw(ctx context.Context, raw ContainerResizePolicyRaw) ContainerResizePolicy {
    x := NewContainerResizePolicy(ctx)
    if raw.ResourceName != "" {
        x.SetResourceName(raw.ResourceName)
    }
    if raw.RestartPolicy != 0 {
        x.SetRestartPolicy(raw.RestartPolicy)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ContainerResizePolicy) ToRaw(ctx context.Context) ContainerResizePolicyRaw {
    raw := ContainerResizePolicyRaw{}
    raw.ResourceName = x.ResourceName()
    raw.RestartPolicy = x.RestartPolicy()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ContainerResizePolicy) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(12)
}

// ContainerState holds a possible state of container.
type ContainerState struct {
   s *segment.Struct
}

// NewContainerState creates a new pooled instance of ContainerState.
// Call Release() when done to return it to the pool for reuse.
func NewContainerState(ctx context.Context) ContainerState {
    s := segment.New(ctx, XXXMappingContainerState)
    s.SetIsSetEnabled(true)
    return ContainerState{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ContainerState) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewContainerStateFrom creates a new ContainerState from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewContainerStateFrom(s *segment.Struct) ContainerState {
    return ContainerState{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ContainerState) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ContainerState) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ContainerState) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ContainerState) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ContainerState) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ContainerState) Waiting() ContainerStateWaiting {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingContainerStateWaiting)
    return ContainerStateWaiting{s: s}
}

func (x ContainerState) SetWaiting(value ContainerStateWaiting) ContainerState {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x ContainerState) IsSetWaiting() bool{
    return x.s.HasField(0)
}

func (x ContainerState) Running() ContainerStateRunning {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingContainerStateRunning)
    return ContainerStateRunning{s: s}
}

func (x ContainerState) SetRunning(value ContainerStateRunning) ContainerState {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x ContainerState) IsSetRunning() bool{
    return x.s.HasField(1)
}

func (x ContainerState) Terminated() ContainerStateTerminated {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingContainerStateTerminated)
    return ContainerStateTerminated{s: s}
}

func (x ContainerState) SetTerminated(value ContainerStateTerminated) ContainerState {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x ContainerState) IsSetTerminated() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ContainerState) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ContainerState) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ContainerState) XXXTypeHash() [16]byte {
    return XXXTypeHashContainerState
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ContainerState) SetRecording(enabled bool) ContainerState {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ContainerState) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ContainerState) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ContainerState) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ContainerStateRaw is a plain Go struct representation of ContainerState.
// Zero values are not set (sparse encoding).
type ContainerStateRaw struct {
    Waiting *ContainerStateWaitingRaw
    Running *ContainerStateRunningRaw
    Terminated *ContainerStateTerminatedRaw
}

// NewContainerStateFromRaw creates a new ContainerState from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewContainerStateFromRaw(ctx context.Context, raw ContainerStateRaw) ContainerState {
    x := NewContainerState(ctx)
    if raw.Waiting != nil {
        x.SetWaiting(NewContainerStateWaitingFromRaw(ctx, *raw.Waiting))
    }
    if raw.Running != nil {
        x.SetRunning(NewContainerStateRunningFromRaw(ctx, *raw.Running))
    }
    if raw.Terminated != nil {
        x.SetTerminated(NewContainerStateTerminatedFromRaw(ctx, *raw.Terminated))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ContainerState) ToRaw(ctx context.Context) ContainerStateRaw {
    raw := ContainerStateRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.Waiting().ToRaw(ctx)
        raw.Waiting = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.Running().ToRaw(ctx)
        raw.Running = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.Terminated().ToRaw(ctx)
        raw.Terminated = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ContainerState) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(13)
}

// ContainerStateRunning is a running state of a container.
type ContainerStateRunning struct {
   s *segment.Struct
}

// NewContainerStateRunning creates a new pooled instance of ContainerStateRunning.
// Call Release() when done to return it to the pool for reuse.
func NewContainerStateRunning(ctx context.Context) ContainerStateRunning {
    s := segment.New(ctx, XXXMappingContainerStateRunning)
    s.SetIsSetEnabled(true)
    return ContainerStateRunning{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ContainerStateRunning) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewContainerStateRunningFrom creates a new ContainerStateRunning from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewContainerStateRunningFrom(s *segment.Struct) ContainerStateRunning {
    return ContainerStateRunning{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ContainerStateRunning) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ContainerStateRunning) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ContainerStateRunning) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ContainerStateRunning) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ContainerStateRunning) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ContainerStateRunning) StartedAt() Time {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingTime)
    return Time{s: s}
}

func (x ContainerStateRunning) SetStartedAt(value Time) ContainerStateRunning {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x ContainerStateRunning) IsSetStartedAt() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ContainerStateRunning) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ContainerStateRunning) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ContainerStateRunning) XXXTypeHash() [16]byte {
    return XXXTypeHashContainerStateRunning
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ContainerStateRunning) SetRecording(enabled bool) ContainerStateRunning {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ContainerStateRunning) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ContainerStateRunning) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ContainerStateRunning) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ContainerStateRunningRaw is a plain Go struct representation of ContainerStateRunning.
// Zero values are not set (sparse encoding).
type ContainerStateRunningRaw struct {
    StartedAt *TimeRaw
}

// NewContainerStateRunningFromRaw creates a new ContainerStateRunning from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewContainerStateRunningFromRaw(ctx context.Context, raw ContainerStateRunningRaw) ContainerStateRunning {
    x := NewContainerStateRunning(ctx)
    if raw.StartedAt != nil {
        x.SetStartedAt(NewTimeFromRaw(ctx, *raw.StartedAt))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ContainerStateRunning) ToRaw(ctx context.Context) ContainerStateRunningRaw {
    raw := ContainerStateRunningRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.StartedAt().ToRaw(ctx)
        raw.StartedAt = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ContainerStateRunning) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(14)
}

// ContainerStateTerminated is a terminated state of a container.
type ContainerStateTerminated struct {
   s *segment.Struct
}

// NewContainerStateTerminated creates a new pooled instance of ContainerStateTerminated.
// Call Release() when done to return it to the pool for reuse.
func NewContainerStateTerminated(ctx context.Context) ContainerStateTerminated {
    s := segment.New(ctx, XXXMappingContainerStateTerminated)
    s.SetIsSetEnabled(true)
    return ContainerStateTerminated{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ContainerStateTerminated) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewContainerStateTerminatedFrom creates a new ContainerStateTerminated from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewContainerStateTerminatedFrom(s *segment.Struct) ContainerStateTerminated {
    return ContainerStateTerminated{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ContainerStateTerminated) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ContainerStateTerminated) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ContainerStateTerminated) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ContainerStateTerminated) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ContainerStateTerminated) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ContainerStateTerminated) ExitCode() int32 {
    return segment.GetInt32(x.s, 0)
}

func (x ContainerStateTerminated) SetExitCode(value int32) ContainerStateTerminated {
    segment.SetInt32(x.s, 0, value)
    return x
}
func (x ContainerStateTerminated) IsSetExitCode() bool{
    return x.s.HasField(0)
}

func (x ContainerStateTerminated) Signal() int32 {
    return segment.GetInt32(x.s, 1)
}

func (x ContainerStateTerminated) SetSignal(value int32) ContainerStateTerminated {
    segment.SetInt32(x.s, 1, value)
    return x
}
func (x ContainerStateTerminated) IsSetSignal() bool{
    return x.s.HasField(1)
}

func (x ContainerStateTerminated) Reason() string {
    return segment.GetString(x.s, 2)
}

func (x ContainerStateTerminated) SetReason(value string) ContainerStateTerminated {
    segment.SetString(x.s, 2, value)
    return x
}
func (x ContainerStateTerminated) IsSetReason() bool{
    return x.s.HasField(2)
}

func (x ContainerStateTerminated) Message() string {
    return segment.GetString(x.s, 3)
}

func (x ContainerStateTerminated) SetMessage(value string) ContainerStateTerminated {
    segment.SetString(x.s, 3, value)
    return x
}
func (x ContainerStateTerminated) IsSetMessage() bool{
    return x.s.HasField(3)
}

func (x ContainerStateTerminated) StartedAt() Time {
    s := segment.GetNestedStruct(x.s, 4, XXXMappingTime)
    return Time{s: s}
}

func (x ContainerStateTerminated) SetStartedAt(value Time) ContainerStateTerminated {
    segment.SetNestedStruct(x.s, 4, value.XXXGetStruct())
    return x
}
func (x ContainerStateTerminated) IsSetStartedAt() bool{
    return x.s.HasField(4)
}

func (x ContainerStateTerminated) FinishedAt() Time {
    s := segment.GetNestedStruct(x.s, 5, XXXMappingTime)
    return Time{s: s}
}

func (x ContainerStateTerminated) SetFinishedAt(value Time) ContainerStateTerminated {
    segment.SetNestedStruct(x.s, 5, value.XXXGetStruct())
    return x
}
func (x ContainerStateTerminated) IsSetFinishedAt() bool{
    return x.s.HasField(5)
}

func (x ContainerStateTerminated) ContainerId() string {
    return segment.GetString(x.s, 6)
}

func (x ContainerStateTerminated) SetContainerId(value string) ContainerStateTerminated {
    segment.SetString(x.s, 6, value)
    return x
}
func (x ContainerStateTerminated) IsSetContainerId() bool{
    return x.s.HasField(6)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ContainerStateTerminated) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ContainerStateTerminated) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ContainerStateTerminated) XXXTypeHash() [16]byte {
    return XXXTypeHashContainerStateTerminated
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ContainerStateTerminated) SetRecording(enabled bool) ContainerStateTerminated {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ContainerStateTerminated) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ContainerStateTerminated) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ContainerStateTerminated) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ContainerStateTerminatedRaw is a plain Go struct representation of ContainerStateTerminated.
// Zero values are not set (sparse encoding).
type ContainerStateTerminatedRaw struct {
    ExitCode int32
    Signal int32
    Reason string
    Message string
    StartedAt *TimeRaw
    FinishedAt *TimeRaw
    ContainerId string
}

// NewContainerStateTerminatedFromRaw creates a new ContainerStateTerminated from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewContainerStateTerminatedFromRaw(ctx context.Context, raw ContainerStateTerminatedRaw) ContainerStateTerminated {
    x := NewContainerStateTerminated(ctx)
    if raw.ExitCode != 0 {
        x.SetExitCode(raw.ExitCode)
    }
    if raw.Signal != 0 {
        x.SetSignal(raw.Signal)
    }
    if raw.Reason != "" {
        x.SetReason(raw.Reason)
    }
    if raw.Message != "" {
        x.SetMessage(raw.Message)
    }
    if raw.StartedAt != nil {
        x.SetStartedAt(NewTimeFromRaw(ctx, *raw.StartedAt))
    }
    if raw.FinishedAt != nil {
        x.SetFinishedAt(NewTimeFromRaw(ctx, *raw.FinishedAt))
    }
    if raw.ContainerId != "" {
        x.SetContainerId(raw.ContainerId)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ContainerStateTerminated) ToRaw(ctx context.Context) ContainerStateTerminatedRaw {
    raw := ContainerStateTerminatedRaw{}
    raw.ExitCode = x.ExitCode()
    raw.Signal = x.Signal()
    raw.Reason = x.Reason()
    raw.Message = x.Message()
    if x.s.HasField(4) {
        nestedRaw := x.StartedAt().ToRaw(ctx)
        raw.StartedAt = &nestedRaw
    }
    if x.s.HasField(5) {
        nestedRaw := x.FinishedAt().ToRaw(ctx)
        raw.FinishedAt = &nestedRaw
    }
    raw.ContainerId = x.ContainerId()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ContainerStateTerminated) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(15)
}

// ContainerStateWaiting is a waiting state of a container.
type ContainerStateWaiting struct {
   s *segment.Struct
}

// NewContainerStateWaiting creates a new pooled instance of ContainerStateWaiting.
// Call Release() when done to return it to the pool for reuse.
func NewContainerStateWaiting(ctx context.Context) ContainerStateWaiting {
    s := segment.New(ctx, XXXMappingContainerStateWaiting)
    s.SetIsSetEnabled(true)
    return ContainerStateWaiting{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ContainerStateWaiting) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewContainerStateWaitingFrom creates a new ContainerStateWaiting from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewContainerStateWaitingFrom(s *segment.Struct) ContainerStateWaiting {
    return ContainerStateWaiting{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ContainerStateWaiting) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ContainerStateWaiting) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ContainerStateWaiting) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ContainerStateWaiting) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ContainerStateWaiting) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ContainerStateWaiting) Reason() string {
    return segment.GetString(x.s, 0)
}

func (x ContainerStateWaiting) SetReason(value string) ContainerStateWaiting {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ContainerStateWaiting) IsSetReason() bool{
    return x.s.HasField(0)
}

func (x ContainerStateWaiting) Message() string {
    return segment.GetString(x.s, 1)
}

func (x ContainerStateWaiting) SetMessage(value string) ContainerStateWaiting {
    segment.SetString(x.s, 1, value)
    return x
}
func (x ContainerStateWaiting) IsSetMessage() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ContainerStateWaiting) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ContainerStateWaiting) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ContainerStateWaiting) XXXTypeHash() [16]byte {
    return XXXTypeHashContainerStateWaiting
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ContainerStateWaiting) SetRecording(enabled bool) ContainerStateWaiting {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ContainerStateWaiting) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ContainerStateWaiting) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ContainerStateWaiting) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ContainerStateWaitingRaw is a plain Go struct representation of ContainerStateWaiting.
// Zero values are not set (sparse encoding).
type ContainerStateWaitingRaw struct {
    Reason string
    Message string
}

// NewContainerStateWaitingFromRaw creates a new ContainerStateWaiting from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewContainerStateWaitingFromRaw(ctx context.Context, raw ContainerStateWaitingRaw) ContainerStateWaiting {
    x := NewContainerStateWaiting(ctx)
    if raw.Reason != "" {
        x.SetReason(raw.Reason)
    }
    if raw.Message != "" {
        x.SetMessage(raw.Message)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ContainerStateWaiting) ToRaw(ctx context.Context) ContainerStateWaitingRaw {
    raw := ContainerStateWaitingRaw{}
    raw.Reason = x.Reason()
    raw.Message = x.Message()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ContainerStateWaiting) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(16)
}

// ContainerStatus contains the status of a container.
type ContainerStatus struct {
   s *segment.Struct
}

// NewContainerStatus creates a new pooled instance of ContainerStatus.
// Call Release() when done to return it to the pool for reuse.
func NewContainerStatus(ctx context.Context) ContainerStatus {
    s := segment.New(ctx, XXXMappingContainerStatus)
    s.SetIsSetEnabled(true)
    return ContainerStatus{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ContainerStatus) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewContainerStatusFrom creates a new ContainerStatus from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewContainerStatusFrom(s *segment.Struct) ContainerStatus {
    return ContainerStatus{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ContainerStatus) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ContainerStatus) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ContainerStatus) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ContainerStatus) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ContainerStatus) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ContainerStatus) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ContainerStatus) SetName(value string) ContainerStatus {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ContainerStatus) IsSetName() bool{
    return x.s.HasField(0)
}

func (x ContainerStatus) State() ContainerState {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingContainerState)
    return ContainerState{s: s}
}

func (x ContainerStatus) SetState(value ContainerState) ContainerStatus {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x ContainerStatus) IsSetState() bool{
    return x.s.HasField(1)
}

func (x ContainerStatus) LastTerminationState() ContainerState {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingContainerState)
    return ContainerState{s: s}
}

func (x ContainerStatus) SetLastTerminationState(value ContainerState) ContainerStatus {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x ContainerStatus) IsSetLastTerminationState() bool{
    return x.s.HasField(2)
}

func (x ContainerStatus) Ready() bool {
    return segment.GetBool(x.s, 3)
}

func (x ContainerStatus) SetReady(value bool) ContainerStatus {
    segment.SetBool(x.s, 3, value)
    return x
}
func (x ContainerStatus) IsSetReady() bool{
    return x.s.HasField(3)
}

func (x ContainerStatus) RestartCount() int32 {
    return segment.GetInt32(x.s, 4)
}

func (x ContainerStatus) SetRestartCount(value int32) ContainerStatus {
    segment.SetInt32(x.s, 4, value)
    return x
}
func (x ContainerStatus) IsSetRestartCount() bool{
    return x.s.HasField(4)
}

func (x ContainerStatus) Image() string {
    return segment.GetString(x.s, 5)
}

func (x ContainerStatus) SetImage(value string) ContainerStatus {
    segment.SetString(x.s, 5, value)
    return x
}
func (x ContainerStatus) IsSetImage() bool{
    return x.s.HasField(5)
}

func (x ContainerStatus) ImageId() string {
    return segment.GetString(x.s, 6)
}

func (x ContainerStatus) SetImageId(value string) ContainerStatus {
    segment.SetString(x.s, 6, value)
    return x
}
func (x ContainerStatus) IsSetImageId() bool{
    return x.s.HasField(6)
}

func (x ContainerStatus) ContainerId() string {
    return segment.GetString(x.s, 7)
}

func (x ContainerStatus) SetContainerId(value string) ContainerStatus {
    segment.SetString(x.s, 7, value)
    return x
}
func (x ContainerStatus) IsSetContainerId() bool{
    return x.s.HasField(7)
}

func (x ContainerStatus) Started() bool {
    return segment.GetBool(x.s, 8)
}

func (x ContainerStatus) SetStarted(value bool) ContainerStatus {
    segment.SetBool(x.s, 8, value)
    return x
}
func (x ContainerStatus) IsSetStarted() bool{
    return x.s.HasField(8)
}

// AllocatedResourcesList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x ContainerStatus) AllocatedResourcesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 9, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 9, XXXMappingKeyValue)
    return structs
}

// AllocatedResourcesLen returns the number of items in the list.
func (x ContainerStatus) AllocatedResourcesLen(ctx context.Context) int {
    return x.AllocatedResourcesList(ctx).Len()
}

// AllocatedResourcesGet returns the item at the given index.
func (x ContainerStatus) AllocatedResourcesGet(ctx context.Context, index int) KeyValue {
    s := x.AllocatedResourcesList(ctx).Get(index)
    return KeyValue{s: s}
}

// AllocatedResourcesAppend appends items to the list.
func (x ContainerStatus) AllocatedResourcesAppend(ctx context.Context, values ...KeyValue) {
    list := x.AllocatedResourcesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// AllocatedResourcesAppendRaw appends items to the list using Raw struct representations.
func (x ContainerStatus) AllocatedResourcesAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.AllocatedResourcesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ContainerStatus) IsSetAllocatedResources() bool{
    return x.s.HasField(9)
}

func (x ContainerStatus) Resources() ResourceRequirements {
    s := segment.GetNestedStruct(x.s, 10, XXXMappingResourceRequirements)
    return ResourceRequirements{s: s}
}

func (x ContainerStatus) SetResources(value ResourceRequirements) ContainerStatus {
    segment.SetNestedStruct(x.s, 10, value.XXXGetStruct())
    return x
}
func (x ContainerStatus) IsSetResources() bool{
    return x.s.HasField(10)
}

// VolumeMountsList returns the underlying Structs list for iteration.
// Use NewVolumeMountStatus() to create items and Append to add them.
func (x ContainerStatus) VolumeMountsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 11, XXXMappingVolumeMountStatus); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 11, XXXMappingVolumeMountStatus)
    return structs
}

// VolumeMountsLen returns the number of items in the list.
func (x ContainerStatus) VolumeMountsLen(ctx context.Context) int {
    return x.VolumeMountsList(ctx).Len()
}

// VolumeMountsGet returns the item at the given index.
func (x ContainerStatus) VolumeMountsGet(ctx context.Context, index int) VolumeMountStatus {
    s := x.VolumeMountsList(ctx).Get(index)
    return VolumeMountStatus{s: s}
}

// VolumeMountsAppend appends items to the list.
func (x ContainerStatus) VolumeMountsAppend(ctx context.Context, values ...VolumeMountStatus) {
    list := x.VolumeMountsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// VolumeMountsAppendRaw appends items to the list using Raw struct representations.
func (x ContainerStatus) VolumeMountsAppendRaw(ctx context.Context, values ...*VolumeMountStatusRaw) {
    list := x.VolumeMountsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewVolumeMountStatusFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ContainerStatus) IsSetVolumeMounts() bool{
    return x.s.HasField(11)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ContainerStatus) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ContainerStatus) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ContainerStatus) XXXTypeHash() [16]byte {
    return XXXTypeHashContainerStatus
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ContainerStatus) SetRecording(enabled bool) ContainerStatus {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ContainerStatus) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ContainerStatus) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ContainerStatus) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ContainerStatusRaw is a plain Go struct representation of ContainerStatus.
// Zero values are not set (sparse encoding).
type ContainerStatusRaw struct {
    Name string
    State *ContainerStateRaw
    LastTerminationState *ContainerStateRaw
    Ready bool
    RestartCount int32
    Image string
    ImageId string
    ContainerId string
    Started bool
    AllocatedResources []*KeyValueRaw
    Resources *ResourceRequirementsRaw
    VolumeMounts []*VolumeMountStatusRaw
}

// NewContainerStatusFromRaw creates a new ContainerStatus from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewContainerStatusFromRaw(ctx context.Context, raw ContainerStatusRaw) ContainerStatus {
    x := NewContainerStatus(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.State != nil {
        x.SetState(NewContainerStateFromRaw(ctx, *raw.State))
    }
    if raw.LastTerminationState != nil {
        x.SetLastTerminationState(NewContainerStateFromRaw(ctx, *raw.LastTerminationState))
    }
    if raw.Ready {
        x.SetReady(raw.Ready)
    }
    if raw.RestartCount != 0 {
        x.SetRestartCount(raw.RestartCount)
    }
    if raw.Image != "" {
        x.SetImage(raw.Image)
    }
    if raw.ImageId != "" {
        x.SetImageId(raw.ImageId)
    }
    if raw.ContainerId != "" {
        x.SetContainerId(raw.ContainerId)
    }
    if raw.Started {
        x.SetStarted(raw.Started)
    }
    if raw.AllocatedResources != nil {
        list := x.AllocatedResourcesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.AllocatedResources))
        for _, r := range raw.AllocatedResources {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Resources != nil {
        x.SetResources(NewResourceRequirementsFromRaw(ctx, *raw.Resources))
    }
    if raw.VolumeMounts != nil {
        list := x.VolumeMountsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.VolumeMounts))
        for _, r := range raw.VolumeMounts {
            if r != nil {
                items = append(items, NewVolumeMountStatusFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ContainerStatus) ToRaw(ctx context.Context) ContainerStatusRaw {
    raw := ContainerStatusRaw{}
    raw.Name = x.Name()
    if x.s.HasField(1) {
        nestedRaw := x.State().ToRaw(ctx)
        raw.State = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.LastTerminationState().ToRaw(ctx)
        raw.LastTerminationState = &nestedRaw
    }
    raw.Ready = x.Ready()
    raw.RestartCount = x.RestartCount()
    raw.Image = x.Image()
    raw.ImageId = x.ImageId()
    raw.ContainerId = x.ContainerId()
    raw.Started = x.Started()
    if l := x.s.GetList(9); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.AllocatedResources = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.AllocatedResources[i] = &itemRaw
        }
    } else if x.s.HasField(9) {
        list := x.AllocatedResourcesList(ctx)
        raw.AllocatedResources = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.AllocatedResources[i] = &itemRaw
        }
    }
    if x.s.HasField(10) {
        nestedRaw := x.Resources().ToRaw(ctx)
        raw.Resources = &nestedRaw
    }
    if l := x.s.GetList(11); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.VolumeMounts = make([]*VolumeMountStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeMountStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeMounts[i] = &itemRaw
        }
    } else if x.s.HasField(11) {
        list := x.VolumeMountsList(ctx)
        raw.VolumeMounts = make([]*VolumeMountStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeMountStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeMounts[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ContainerStatus) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(17)
}

// DownwardAPIProjection projects downward API info.
type DownwardAPIProjection struct {
   s *segment.Struct
}

// NewDownwardAPIProjection creates a new pooled instance of DownwardAPIProjection.
// Call Release() when done to return it to the pool for reuse.
func NewDownwardAPIProjection(ctx context.Context) DownwardAPIProjection {
    s := segment.New(ctx, XXXMappingDownwardAPIProjection)
    s.SetIsSetEnabled(true)
    return DownwardAPIProjection{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x DownwardAPIProjection) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewDownwardAPIProjectionFrom creates a new DownwardAPIProjection from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewDownwardAPIProjectionFrom(s *segment.Struct) DownwardAPIProjection {
    return DownwardAPIProjection{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x DownwardAPIProjection) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x DownwardAPIProjection) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x DownwardAPIProjection) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x DownwardAPIProjection) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x DownwardAPIProjection) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// ItemsList returns the underlying Structs list for iteration.
// Use NewDownwardAPIVolumeFile() to create items and Append to add them.
func (x DownwardAPIProjection) ItemsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingDownwardAPIVolumeFile); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingDownwardAPIVolumeFile)
    return structs
}

// ItemsLen returns the number of items in the list.
func (x DownwardAPIProjection) ItemsLen(ctx context.Context) int {
    return x.ItemsList(ctx).Len()
}

// ItemsGet returns the item at the given index.
func (x DownwardAPIProjection) ItemsGet(ctx context.Context, index int) DownwardAPIVolumeFile {
    s := x.ItemsList(ctx).Get(index)
    return DownwardAPIVolumeFile{s: s}
}

// ItemsAppend appends items to the list.
func (x DownwardAPIProjection) ItemsAppend(ctx context.Context, values ...DownwardAPIVolumeFile) {
    list := x.ItemsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ItemsAppendRaw appends items to the list using Raw struct representations.
func (x DownwardAPIProjection) ItemsAppendRaw(ctx context.Context, values ...*DownwardAPIVolumeFileRaw) {
    list := x.ItemsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewDownwardAPIVolumeFileFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x DownwardAPIProjection) IsSetItems() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x DownwardAPIProjection) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x DownwardAPIProjection) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x DownwardAPIProjection) XXXTypeHash() [16]byte {
    return XXXTypeHashDownwardAPIProjection
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x DownwardAPIProjection) SetRecording(enabled bool) DownwardAPIProjection {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x DownwardAPIProjection) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x DownwardAPIProjection) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x DownwardAPIProjection) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// DownwardAPIProjectionRaw is a plain Go struct representation of DownwardAPIProjection.
// Zero values are not set (sparse encoding).
type DownwardAPIProjectionRaw struct {
    Items []*DownwardAPIVolumeFileRaw
}

// NewDownwardAPIProjectionFromRaw creates a new DownwardAPIProjection from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewDownwardAPIProjectionFromRaw(ctx context.Context, raw DownwardAPIProjectionRaw) DownwardAPIProjection {
    x := NewDownwardAPIProjection(ctx)
    if raw.Items != nil {
        list := x.ItemsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Items))
        for _, r := range raw.Items {
            if r != nil {
                items = append(items, NewDownwardAPIVolumeFileFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x DownwardAPIProjection) ToRaw(ctx context.Context) DownwardAPIProjectionRaw {
    raw := DownwardAPIProjectionRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Items = make([]*DownwardAPIVolumeFileRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := DownwardAPIVolumeFile{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.ItemsList(ctx)
        raw.Items = make([]*DownwardAPIVolumeFileRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := DownwardAPIVolumeFile{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x DownwardAPIProjection) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(18)
}

// DownwardAPIVolumeFile represents info to project into a volume.
type DownwardAPIVolumeFile struct {
   s *segment.Struct
}

// NewDownwardAPIVolumeFile creates a new pooled instance of DownwardAPIVolumeFile.
// Call Release() when done to return it to the pool for reuse.
func NewDownwardAPIVolumeFile(ctx context.Context) DownwardAPIVolumeFile {
    s := segment.New(ctx, XXXMappingDownwardAPIVolumeFile)
    s.SetIsSetEnabled(true)
    return DownwardAPIVolumeFile{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x DownwardAPIVolumeFile) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewDownwardAPIVolumeFileFrom creates a new DownwardAPIVolumeFile from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewDownwardAPIVolumeFileFrom(s *segment.Struct) DownwardAPIVolumeFile {
    return DownwardAPIVolumeFile{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x DownwardAPIVolumeFile) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x DownwardAPIVolumeFile) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x DownwardAPIVolumeFile) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x DownwardAPIVolumeFile) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x DownwardAPIVolumeFile) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x DownwardAPIVolumeFile) Path() string {
    return segment.GetString(x.s, 0)
}

func (x DownwardAPIVolumeFile) SetPath(value string) DownwardAPIVolumeFile {
    segment.SetString(x.s, 0, value)
    return x
}
func (x DownwardAPIVolumeFile) IsSetPath() bool{
    return x.s.HasField(0)
}

func (x DownwardAPIVolumeFile) FieldRef() ObjectFieldSelector {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingObjectFieldSelector)
    return ObjectFieldSelector{s: s}
}

func (x DownwardAPIVolumeFile) SetFieldRef(value ObjectFieldSelector) DownwardAPIVolumeFile {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x DownwardAPIVolumeFile) IsSetFieldRef() bool{
    return x.s.HasField(1)
}

func (x DownwardAPIVolumeFile) ResourceFieldRef() ResourceFieldSelector {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingResourceFieldSelector)
    return ResourceFieldSelector{s: s}
}

func (x DownwardAPIVolumeFile) SetResourceFieldRef(value ResourceFieldSelector) DownwardAPIVolumeFile {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x DownwardAPIVolumeFile) IsSetResourceFieldRef() bool{
    return x.s.HasField(2)
}

func (x DownwardAPIVolumeFile) Mode() int32 {
    return segment.GetInt32(x.s, 3)
}

func (x DownwardAPIVolumeFile) SetMode(value int32) DownwardAPIVolumeFile {
    segment.SetInt32(x.s, 3, value)
    return x
}
func (x DownwardAPIVolumeFile) IsSetMode() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x DownwardAPIVolumeFile) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x DownwardAPIVolumeFile) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x DownwardAPIVolumeFile) XXXTypeHash() [16]byte {
    return XXXTypeHashDownwardAPIVolumeFile
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x DownwardAPIVolumeFile) SetRecording(enabled bool) DownwardAPIVolumeFile {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x DownwardAPIVolumeFile) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x DownwardAPIVolumeFile) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x DownwardAPIVolumeFile) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// DownwardAPIVolumeFileRaw is a plain Go struct representation of DownwardAPIVolumeFile.
// Zero values are not set (sparse encoding).
type DownwardAPIVolumeFileRaw struct {
    Path string
    FieldRef *ObjectFieldSelectorRaw
    ResourceFieldRef *ResourceFieldSelectorRaw
    Mode int32
}

// NewDownwardAPIVolumeFileFromRaw creates a new DownwardAPIVolumeFile from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewDownwardAPIVolumeFileFromRaw(ctx context.Context, raw DownwardAPIVolumeFileRaw) DownwardAPIVolumeFile {
    x := NewDownwardAPIVolumeFile(ctx)
    if raw.Path != "" {
        x.SetPath(raw.Path)
    }
    if raw.FieldRef != nil {
        x.SetFieldRef(NewObjectFieldSelectorFromRaw(ctx, *raw.FieldRef))
    }
    if raw.ResourceFieldRef != nil {
        x.SetResourceFieldRef(NewResourceFieldSelectorFromRaw(ctx, *raw.ResourceFieldRef))
    }
    if raw.Mode != 0 {
        x.SetMode(raw.Mode)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x DownwardAPIVolumeFile) ToRaw(ctx context.Context) DownwardAPIVolumeFileRaw {
    raw := DownwardAPIVolumeFileRaw{}
    raw.Path = x.Path()
    if x.s.HasField(1) {
        nestedRaw := x.FieldRef().ToRaw(ctx)
        raw.FieldRef = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.ResourceFieldRef().ToRaw(ctx)
        raw.ResourceFieldRef = &nestedRaw
    }
    raw.Mode = x.Mode()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x DownwardAPIVolumeFile) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(19)
}

// DownwardAPIVolumeSource represents a volume with downward API info.
type DownwardAPIVolumeSource struct {
   s *segment.Struct
}

// NewDownwardAPIVolumeSource creates a new pooled instance of DownwardAPIVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewDownwardAPIVolumeSource(ctx context.Context) DownwardAPIVolumeSource {
    s := segment.New(ctx, XXXMappingDownwardAPIVolumeSource)
    s.SetIsSetEnabled(true)
    return DownwardAPIVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x DownwardAPIVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewDownwardAPIVolumeSourceFrom creates a new DownwardAPIVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewDownwardAPIVolumeSourceFrom(s *segment.Struct) DownwardAPIVolumeSource {
    return DownwardAPIVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x DownwardAPIVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x DownwardAPIVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x DownwardAPIVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x DownwardAPIVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x DownwardAPIVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// ItemsList returns the underlying Structs list for iteration.
// Use NewDownwardAPIVolumeFile() to create items and Append to add them.
func (x DownwardAPIVolumeSource) ItemsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingDownwardAPIVolumeFile); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingDownwardAPIVolumeFile)
    return structs
}

// ItemsLen returns the number of items in the list.
func (x DownwardAPIVolumeSource) ItemsLen(ctx context.Context) int {
    return x.ItemsList(ctx).Len()
}

// ItemsGet returns the item at the given index.
func (x DownwardAPIVolumeSource) ItemsGet(ctx context.Context, index int) DownwardAPIVolumeFile {
    s := x.ItemsList(ctx).Get(index)
    return DownwardAPIVolumeFile{s: s}
}

// ItemsAppend appends items to the list.
func (x DownwardAPIVolumeSource) ItemsAppend(ctx context.Context, values ...DownwardAPIVolumeFile) {
    list := x.ItemsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ItemsAppendRaw appends items to the list using Raw struct representations.
func (x DownwardAPIVolumeSource) ItemsAppendRaw(ctx context.Context, values ...*DownwardAPIVolumeFileRaw) {
    list := x.ItemsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewDownwardAPIVolumeFileFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x DownwardAPIVolumeSource) IsSetItems() bool{
    return x.s.HasField(0)
}

func (x DownwardAPIVolumeSource) DefaultMode() int32 {
    return segment.GetInt32(x.s, 1)
}

func (x DownwardAPIVolumeSource) SetDefaultMode(value int32) DownwardAPIVolumeSource {
    segment.SetInt32(x.s, 1, value)
    return x
}
func (x DownwardAPIVolumeSource) IsSetDefaultMode() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x DownwardAPIVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x DownwardAPIVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x DownwardAPIVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashDownwardAPIVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x DownwardAPIVolumeSource) SetRecording(enabled bool) DownwardAPIVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x DownwardAPIVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x DownwardAPIVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x DownwardAPIVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// DownwardAPIVolumeSourceRaw is a plain Go struct representation of DownwardAPIVolumeSource.
// Zero values are not set (sparse encoding).
type DownwardAPIVolumeSourceRaw struct {
    Items []*DownwardAPIVolumeFileRaw
    DefaultMode int32
}

// NewDownwardAPIVolumeSourceFromRaw creates a new DownwardAPIVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewDownwardAPIVolumeSourceFromRaw(ctx context.Context, raw DownwardAPIVolumeSourceRaw) DownwardAPIVolumeSource {
    x := NewDownwardAPIVolumeSource(ctx)
    if raw.Items != nil {
        list := x.ItemsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Items))
        for _, r := range raw.Items {
            if r != nil {
                items = append(items, NewDownwardAPIVolumeFileFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.DefaultMode != 0 {
        x.SetDefaultMode(raw.DefaultMode)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x DownwardAPIVolumeSource) ToRaw(ctx context.Context) DownwardAPIVolumeSourceRaw {
    raw := DownwardAPIVolumeSourceRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Items = make([]*DownwardAPIVolumeFileRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := DownwardAPIVolumeFile{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.ItemsList(ctx)
        raw.Items = make([]*DownwardAPIVolumeFileRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := DownwardAPIVolumeFile{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    }
    raw.DefaultMode = x.DefaultMode()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x DownwardAPIVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(20)
}

// EmptyDirVolumeSource represents an empty directory for a pod.
type EmptyDirVolumeSource struct {
   s *segment.Struct
}

// NewEmptyDirVolumeSource creates a new pooled instance of EmptyDirVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewEmptyDirVolumeSource(ctx context.Context) EmptyDirVolumeSource {
    s := segment.New(ctx, XXXMappingEmptyDirVolumeSource)
    s.SetIsSetEnabled(true)
    return EmptyDirVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x EmptyDirVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewEmptyDirVolumeSourceFrom creates a new EmptyDirVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewEmptyDirVolumeSourceFrom(s *segment.Struct) EmptyDirVolumeSource {
    return EmptyDirVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x EmptyDirVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x EmptyDirVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x EmptyDirVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x EmptyDirVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x EmptyDirVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x EmptyDirVolumeSource) Medium() StorageMedium {
    return StorageMedium(segment.GetUint8(x.s, 0))
}

func (x EmptyDirVolumeSource) SetMedium(value StorageMedium) EmptyDirVolumeSource {
    segment.SetUint8(x.s, 0, uint8(value))
    return x
}
func (x EmptyDirVolumeSource) IsSetMedium() bool{
    return x.s.HasField(0)
}

func (x EmptyDirVolumeSource) SizeLimit() string {
    return segment.GetString(x.s, 1)
}

func (x EmptyDirVolumeSource) SetSizeLimit(value string) EmptyDirVolumeSource {
    segment.SetString(x.s, 1, value)
    return x
}
func (x EmptyDirVolumeSource) IsSetSizeLimit() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x EmptyDirVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x EmptyDirVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x EmptyDirVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashEmptyDirVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x EmptyDirVolumeSource) SetRecording(enabled bool) EmptyDirVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x EmptyDirVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x EmptyDirVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x EmptyDirVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// EmptyDirVolumeSourceRaw is a plain Go struct representation of EmptyDirVolumeSource.
// Zero values are not set (sparse encoding).
type EmptyDirVolumeSourceRaw struct {
    Medium StorageMedium
    SizeLimit string
}

// NewEmptyDirVolumeSourceFromRaw creates a new EmptyDirVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewEmptyDirVolumeSourceFromRaw(ctx context.Context, raw EmptyDirVolumeSourceRaw) EmptyDirVolumeSource {
    x := NewEmptyDirVolumeSource(ctx)
    if raw.Medium != 0 {
        x.SetMedium(raw.Medium)
    }
    if raw.SizeLimit != "" {
        x.SetSizeLimit(raw.SizeLimit)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x EmptyDirVolumeSource) ToRaw(ctx context.Context) EmptyDirVolumeSourceRaw {
    raw := EmptyDirVolumeSourceRaw{}
    raw.Medium = x.Medium()
    raw.SizeLimit = x.SizeLimit()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x EmptyDirVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(21)
}

// EnvFromSource represents the source of a set of ConfigMaps.
type EnvFromSource struct {
   s *segment.Struct
}

// NewEnvFromSource creates a new pooled instance of EnvFromSource.
// Call Release() when done to return it to the pool for reuse.
func NewEnvFromSource(ctx context.Context) EnvFromSource {
    s := segment.New(ctx, XXXMappingEnvFromSource)
    s.SetIsSetEnabled(true)
    return EnvFromSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x EnvFromSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewEnvFromSourceFrom creates a new EnvFromSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewEnvFromSourceFrom(s *segment.Struct) EnvFromSource {
    return EnvFromSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x EnvFromSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x EnvFromSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x EnvFromSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x EnvFromSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x EnvFromSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x EnvFromSource) Prefix() string {
    return segment.GetString(x.s, 0)
}

func (x EnvFromSource) SetPrefix(value string) EnvFromSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x EnvFromSource) IsSetPrefix() bool{
    return x.s.HasField(0)
}

func (x EnvFromSource) ConfigMapRef() ConfigMapEnvSource {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingConfigMapEnvSource)
    return ConfigMapEnvSource{s: s}
}

func (x EnvFromSource) SetConfigMapRef(value ConfigMapEnvSource) EnvFromSource {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x EnvFromSource) IsSetConfigMapRef() bool{
    return x.s.HasField(1)
}

func (x EnvFromSource) SecretRef() SecretEnvSource {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingSecretEnvSource)
    return SecretEnvSource{s: s}
}

func (x EnvFromSource) SetSecretRef(value SecretEnvSource) EnvFromSource {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x EnvFromSource) IsSetSecretRef() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x EnvFromSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x EnvFromSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x EnvFromSource) XXXTypeHash() [16]byte {
    return XXXTypeHashEnvFromSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x EnvFromSource) SetRecording(enabled bool) EnvFromSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x EnvFromSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x EnvFromSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x EnvFromSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// EnvFromSourceRaw is a plain Go struct representation of EnvFromSource.
// Zero values are not set (sparse encoding).
type EnvFromSourceRaw struct {
    Prefix string
    ConfigMapRef *ConfigMapEnvSourceRaw
    SecretRef *SecretEnvSourceRaw
}

// NewEnvFromSourceFromRaw creates a new EnvFromSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewEnvFromSourceFromRaw(ctx context.Context, raw EnvFromSourceRaw) EnvFromSource {
    x := NewEnvFromSource(ctx)
    if raw.Prefix != "" {
        x.SetPrefix(raw.Prefix)
    }
    if raw.ConfigMapRef != nil {
        x.SetConfigMapRef(NewConfigMapEnvSourceFromRaw(ctx, *raw.ConfigMapRef))
    }
    if raw.SecretRef != nil {
        x.SetSecretRef(NewSecretEnvSourceFromRaw(ctx, *raw.SecretRef))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x EnvFromSource) ToRaw(ctx context.Context) EnvFromSourceRaw {
    raw := EnvFromSourceRaw{}
    raw.Prefix = x.Prefix()
    if x.s.HasField(1) {
        nestedRaw := x.ConfigMapRef().ToRaw(ctx)
        raw.ConfigMapRef = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.SecretRef().ToRaw(ctx)
        raw.SecretRef = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x EnvFromSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(22)
}

// EnvVar represents an environment variable.
type EnvVar struct {
   s *segment.Struct
}

// NewEnvVar creates a new pooled instance of EnvVar.
// Call Release() when done to return it to the pool for reuse.
func NewEnvVar(ctx context.Context) EnvVar {
    s := segment.New(ctx, XXXMappingEnvVar)
    s.SetIsSetEnabled(true)
    return EnvVar{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x EnvVar) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewEnvVarFrom creates a new EnvVar from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewEnvVarFrom(s *segment.Struct) EnvVar {
    return EnvVar{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x EnvVar) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x EnvVar) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x EnvVar) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x EnvVar) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x EnvVar) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x EnvVar) Name() string {
    return segment.GetString(x.s, 0)
}

func (x EnvVar) SetName(value string) EnvVar {
    segment.SetString(x.s, 0, value)
    return x
}
func (x EnvVar) IsSetName() bool{
    return x.s.HasField(0)
}

func (x EnvVar) Value() string {
    return segment.GetString(x.s, 1)
}

func (x EnvVar) SetValue(value string) EnvVar {
    segment.SetString(x.s, 1, value)
    return x
}
func (x EnvVar) IsSetValue() bool{
    return x.s.HasField(1)
}

func (x EnvVar) ValueFrom() EnvVarSource {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingEnvVarSource)
    return EnvVarSource{s: s}
}

func (x EnvVar) SetValueFrom(value EnvVarSource) EnvVar {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x EnvVar) IsSetValueFrom() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x EnvVar) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x EnvVar) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x EnvVar) XXXTypeHash() [16]byte {
    return XXXTypeHashEnvVar
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x EnvVar) SetRecording(enabled bool) EnvVar {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x EnvVar) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x EnvVar) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x EnvVar) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// EnvVarRaw is a plain Go struct representation of EnvVar.
// Zero values are not set (sparse encoding).
type EnvVarRaw struct {
    Name string
    Value string
    ValueFrom *EnvVarSourceRaw
}

// NewEnvVarFromRaw creates a new EnvVar from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewEnvVarFromRaw(ctx context.Context, raw EnvVarRaw) EnvVar {
    x := NewEnvVar(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Value != "" {
        x.SetValue(raw.Value)
    }
    if raw.ValueFrom != nil {
        x.SetValueFrom(NewEnvVarSourceFromRaw(ctx, *raw.ValueFrom))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x EnvVar) ToRaw(ctx context.Context) EnvVarRaw {
    raw := EnvVarRaw{}
    raw.Name = x.Name()
    raw.Value = x.Value()
    if x.s.HasField(2) {
        nestedRaw := x.ValueFrom().ToRaw(ctx)
        raw.ValueFrom = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x EnvVar) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(23)
}

// EnvVarSource represents a source for the value of an EnvVar.
type EnvVarSource struct {
   s *segment.Struct
}

// NewEnvVarSource creates a new pooled instance of EnvVarSource.
// Call Release() when done to return it to the pool for reuse.
func NewEnvVarSource(ctx context.Context) EnvVarSource {
    s := segment.New(ctx, XXXMappingEnvVarSource)
    s.SetIsSetEnabled(true)
    return EnvVarSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x EnvVarSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewEnvVarSourceFrom creates a new EnvVarSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewEnvVarSourceFrom(s *segment.Struct) EnvVarSource {
    return EnvVarSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x EnvVarSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x EnvVarSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x EnvVarSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x EnvVarSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x EnvVarSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x EnvVarSource) FieldRef() ObjectFieldSelector {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingObjectFieldSelector)
    return ObjectFieldSelector{s: s}
}

func (x EnvVarSource) SetFieldRef(value ObjectFieldSelector) EnvVarSource {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x EnvVarSource) IsSetFieldRef() bool{
    return x.s.HasField(0)
}

func (x EnvVarSource) ResourceFieldRef() ResourceFieldSelector {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingResourceFieldSelector)
    return ResourceFieldSelector{s: s}
}

func (x EnvVarSource) SetResourceFieldRef(value ResourceFieldSelector) EnvVarSource {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x EnvVarSource) IsSetResourceFieldRef() bool{
    return x.s.HasField(1)
}

func (x EnvVarSource) ConfigMapKeyRef() ConfigMapKeySelector {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingConfigMapKeySelector)
    return ConfigMapKeySelector{s: s}
}

func (x EnvVarSource) SetConfigMapKeyRef(value ConfigMapKeySelector) EnvVarSource {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x EnvVarSource) IsSetConfigMapKeyRef() bool{
    return x.s.HasField(2)
}

func (x EnvVarSource) SecretKeyRef() SecretKeySelector {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingSecretKeySelector)
    return SecretKeySelector{s: s}
}

func (x EnvVarSource) SetSecretKeyRef(value SecretKeySelector) EnvVarSource {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x EnvVarSource) IsSetSecretKeyRef() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x EnvVarSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x EnvVarSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x EnvVarSource) XXXTypeHash() [16]byte {
    return XXXTypeHashEnvVarSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x EnvVarSource) SetRecording(enabled bool) EnvVarSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x EnvVarSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x EnvVarSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x EnvVarSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// EnvVarSourceRaw is a plain Go struct representation of EnvVarSource.
// Zero values are not set (sparse encoding).
type EnvVarSourceRaw struct {
    FieldRef *ObjectFieldSelectorRaw
    ResourceFieldRef *ResourceFieldSelectorRaw
    ConfigMapKeyRef *ConfigMapKeySelectorRaw
    SecretKeyRef *SecretKeySelectorRaw
}

// NewEnvVarSourceFromRaw creates a new EnvVarSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewEnvVarSourceFromRaw(ctx context.Context, raw EnvVarSourceRaw) EnvVarSource {
    x := NewEnvVarSource(ctx)
    if raw.FieldRef != nil {
        x.SetFieldRef(NewObjectFieldSelectorFromRaw(ctx, *raw.FieldRef))
    }
    if raw.ResourceFieldRef != nil {
        x.SetResourceFieldRef(NewResourceFieldSelectorFromRaw(ctx, *raw.ResourceFieldRef))
    }
    if raw.ConfigMapKeyRef != nil {
        x.SetConfigMapKeyRef(NewConfigMapKeySelectorFromRaw(ctx, *raw.ConfigMapKeyRef))
    }
    if raw.SecretKeyRef != nil {
        x.SetSecretKeyRef(NewSecretKeySelectorFromRaw(ctx, *raw.SecretKeyRef))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x EnvVarSource) ToRaw(ctx context.Context) EnvVarSourceRaw {
    raw := EnvVarSourceRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.FieldRef().ToRaw(ctx)
        raw.FieldRef = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.ResourceFieldRef().ToRaw(ctx)
        raw.ResourceFieldRef = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.ConfigMapKeyRef().ToRaw(ctx)
        raw.ConfigMapKeyRef = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.SecretKeyRef().ToRaw(ctx)
        raw.SecretKeyRef = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x EnvVarSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(24)
}

// EphemeralContainer is a temporary container that may be added to an existing pod.
type EphemeralContainer struct {
   s *segment.Struct
}

// NewEphemeralContainer creates a new pooled instance of EphemeralContainer.
// Call Release() when done to return it to the pool for reuse.
func NewEphemeralContainer(ctx context.Context) EphemeralContainer {
    s := segment.New(ctx, XXXMappingEphemeralContainer)
    s.SetIsSetEnabled(true)
    return EphemeralContainer{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x EphemeralContainer) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewEphemeralContainerFrom creates a new EphemeralContainer from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewEphemeralContainerFrom(s *segment.Struct) EphemeralContainer {
    return EphemeralContainer{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x EphemeralContainer) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x EphemeralContainer) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x EphemeralContainer) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x EphemeralContainer) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x EphemeralContainer) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x EphemeralContainer) Name() string {
    return segment.GetString(x.s, 0)
}

func (x EphemeralContainer) SetName(value string) EphemeralContainer {
    segment.SetString(x.s, 0, value)
    return x
}
func (x EphemeralContainer) IsSetName() bool{
    return x.s.HasField(0)
}

func (x EphemeralContainer) Image() string {
    return segment.GetString(x.s, 1)
}

func (x EphemeralContainer) SetImage(value string) EphemeralContainer {
    segment.SetString(x.s, 1, value)
    return x
}
func (x EphemeralContainer) IsSetImage() bool{
    return x.s.HasField(1)
}

func (x EphemeralContainer) Command() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 2); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 2)
    return strs
}

// SetCommand replaces all values in the string list.
func (x EphemeralContainer) SetCommand(v ...string) EphemeralContainer {
    strs := x.Command()
    strs.SetAll(v)
    return x
}
func (x EphemeralContainer) IsSetCommand() bool{
    return x.s.HasField(2)
}

func (x EphemeralContainer) Args() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 3); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 3)
    return strs
}

// SetArgs replaces all values in the string list.
func (x EphemeralContainer) SetArgs(v ...string) EphemeralContainer {
    strs := x.Args()
    strs.SetAll(v)
    return x
}
func (x EphemeralContainer) IsSetArgs() bool{
    return x.s.HasField(3)
}

func (x EphemeralContainer) WorkingDir() string {
    return segment.GetString(x.s, 4)
}

func (x EphemeralContainer) SetWorkingDir(value string) EphemeralContainer {
    segment.SetString(x.s, 4, value)
    return x
}
func (x EphemeralContainer) IsSetWorkingDir() bool{
    return x.s.HasField(4)
}

// PortsList returns the underlying Structs list for iteration.
// Use NewContainerPort() to create items and Append to add them.
func (x EphemeralContainer) PortsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 5, XXXMappingContainerPort); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 5, XXXMappingContainerPort)
    return structs
}

// PortsLen returns the number of items in the list.
func (x EphemeralContainer) PortsLen(ctx context.Context) int {
    return x.PortsList(ctx).Len()
}

// PortsGet returns the item at the given index.
func (x EphemeralContainer) PortsGet(ctx context.Context, index int) ContainerPort {
    s := x.PortsList(ctx).Get(index)
    return ContainerPort{s: s}
}

// PortsAppend appends items to the list.
func (x EphemeralContainer) PortsAppend(ctx context.Context, values ...ContainerPort) {
    list := x.PortsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// PortsAppendRaw appends items to the list using Raw struct representations.
func (x EphemeralContainer) PortsAppendRaw(ctx context.Context, values ...*ContainerPortRaw) {
    list := x.PortsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewContainerPortFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x EphemeralContainer) IsSetPorts() bool{
    return x.s.HasField(5)
}

// EnvFromList returns the underlying Structs list for iteration.
// Use NewEnvFromSource() to create items and Append to add them.
func (x EphemeralContainer) EnvFromList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 6, XXXMappingEnvFromSource); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 6, XXXMappingEnvFromSource)
    return structs
}

// EnvFromLen returns the number of items in the list.
func (x EphemeralContainer) EnvFromLen(ctx context.Context) int {
    return x.EnvFromList(ctx).Len()
}

// EnvFromGet returns the item at the given index.
func (x EphemeralContainer) EnvFromGet(ctx context.Context, index int) EnvFromSource {
    s := x.EnvFromList(ctx).Get(index)
    return EnvFromSource{s: s}
}

// EnvFromAppend appends items to the list.
func (x EphemeralContainer) EnvFromAppend(ctx context.Context, values ...EnvFromSource) {
    list := x.EnvFromList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// EnvFromAppendRaw appends items to the list using Raw struct representations.
func (x EphemeralContainer) EnvFromAppendRaw(ctx context.Context, values ...*EnvFromSourceRaw) {
    list := x.EnvFromList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewEnvFromSourceFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x EphemeralContainer) IsSetEnvFrom() bool{
    return x.s.HasField(6)
}

// EnvList returns the underlying Structs list for iteration.
// Use NewEnvVar() to create items and Append to add them.
func (x EphemeralContainer) EnvList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 7, XXXMappingEnvVar); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 7, XXXMappingEnvVar)
    return structs
}

// EnvLen returns the number of items in the list.
func (x EphemeralContainer) EnvLen(ctx context.Context) int {
    return x.EnvList(ctx).Len()
}

// EnvGet returns the item at the given index.
func (x EphemeralContainer) EnvGet(ctx context.Context, index int) EnvVar {
    s := x.EnvList(ctx).Get(index)
    return EnvVar{s: s}
}

// EnvAppend appends items to the list.
func (x EphemeralContainer) EnvAppend(ctx context.Context, values ...EnvVar) {
    list := x.EnvList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// EnvAppendRaw appends items to the list using Raw struct representations.
func (x EphemeralContainer) EnvAppendRaw(ctx context.Context, values ...*EnvVarRaw) {
    list := x.EnvList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewEnvVarFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x EphemeralContainer) IsSetEnv() bool{
    return x.s.HasField(7)
}

func (x EphemeralContainer) Resources() ResourceRequirements {
    s := segment.GetNestedStruct(x.s, 8, XXXMappingResourceRequirements)
    return ResourceRequirements{s: s}
}

func (x EphemeralContainer) SetResources(value ResourceRequirements) EphemeralContainer {
    segment.SetNestedStruct(x.s, 8, value.XXXGetStruct())
    return x
}
func (x EphemeralContainer) IsSetResources() bool{
    return x.s.HasField(8)
}

// VolumeMountsList returns the underlying Structs list for iteration.
// Use NewVolumeMount() to create items and Append to add them.
func (x EphemeralContainer) VolumeMountsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 9, XXXMappingVolumeMount); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 9, XXXMappingVolumeMount)
    return structs
}

// VolumeMountsLen returns the number of items in the list.
func (x EphemeralContainer) VolumeMountsLen(ctx context.Context) int {
    return x.VolumeMountsList(ctx).Len()
}

// VolumeMountsGet returns the item at the given index.
func (x EphemeralContainer) VolumeMountsGet(ctx context.Context, index int) VolumeMount {
    s := x.VolumeMountsList(ctx).Get(index)
    return VolumeMount{s: s}
}

// VolumeMountsAppend appends items to the list.
func (x EphemeralContainer) VolumeMountsAppend(ctx context.Context, values ...VolumeMount) {
    list := x.VolumeMountsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// VolumeMountsAppendRaw appends items to the list using Raw struct representations.
func (x EphemeralContainer) VolumeMountsAppendRaw(ctx context.Context, values ...*VolumeMountRaw) {
    list := x.VolumeMountsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewVolumeMountFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x EphemeralContainer) IsSetVolumeMounts() bool{
    return x.s.HasField(9)
}

// VolumeDevicesList returns the underlying Structs list for iteration.
// Use NewVolumeDevice() to create items and Append to add them.
func (x EphemeralContainer) VolumeDevicesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 10, XXXMappingVolumeDevice); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 10, XXXMappingVolumeDevice)
    return structs
}

// VolumeDevicesLen returns the number of items in the list.
func (x EphemeralContainer) VolumeDevicesLen(ctx context.Context) int {
    return x.VolumeDevicesList(ctx).Len()
}

// VolumeDevicesGet returns the item at the given index.
func (x EphemeralContainer) VolumeDevicesGet(ctx context.Context, index int) VolumeDevice {
    s := x.VolumeDevicesList(ctx).Get(index)
    return VolumeDevice{s: s}
}

// VolumeDevicesAppend appends items to the list.
func (x EphemeralContainer) VolumeDevicesAppend(ctx context.Context, values ...VolumeDevice) {
    list := x.VolumeDevicesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// VolumeDevicesAppendRaw appends items to the list using Raw struct representations.
func (x EphemeralContainer) VolumeDevicesAppendRaw(ctx context.Context, values ...*VolumeDeviceRaw) {
    list := x.VolumeDevicesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewVolumeDeviceFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x EphemeralContainer) IsSetVolumeDevices() bool{
    return x.s.HasField(10)
}

func (x EphemeralContainer) LivenessProbe() Probe {
    s := segment.GetNestedStruct(x.s, 11, XXXMappingProbe)
    return Probe{s: s}
}

func (x EphemeralContainer) SetLivenessProbe(value Probe) EphemeralContainer {
    segment.SetNestedStruct(x.s, 11, value.XXXGetStruct())
    return x
}
func (x EphemeralContainer) IsSetLivenessProbe() bool{
    return x.s.HasField(11)
}

func (x EphemeralContainer) ReadinessProbe() Probe {
    s := segment.GetNestedStruct(x.s, 12, XXXMappingProbe)
    return Probe{s: s}
}

func (x EphemeralContainer) SetReadinessProbe(value Probe) EphemeralContainer {
    segment.SetNestedStruct(x.s, 12, value.XXXGetStruct())
    return x
}
func (x EphemeralContainer) IsSetReadinessProbe() bool{
    return x.s.HasField(12)
}

func (x EphemeralContainer) StartupProbe() Probe {
    s := segment.GetNestedStruct(x.s, 13, XXXMappingProbe)
    return Probe{s: s}
}

func (x EphemeralContainer) SetStartupProbe(value Probe) EphemeralContainer {
    segment.SetNestedStruct(x.s, 13, value.XXXGetStruct())
    return x
}
func (x EphemeralContainer) IsSetStartupProbe() bool{
    return x.s.HasField(13)
}

func (x EphemeralContainer) Lifecycle() Lifecycle {
    s := segment.GetNestedStruct(x.s, 14, XXXMappingLifecycle)
    return Lifecycle{s: s}
}

func (x EphemeralContainer) SetLifecycle(value Lifecycle) EphemeralContainer {
    segment.SetNestedStruct(x.s, 14, value.XXXGetStruct())
    return x
}
func (x EphemeralContainer) IsSetLifecycle() bool{
    return x.s.HasField(14)
}

func (x EphemeralContainer) TerminationMessagePath() string {
    return segment.GetString(x.s, 15)
}

func (x EphemeralContainer) SetTerminationMessagePath(value string) EphemeralContainer {
    segment.SetString(x.s, 15, value)
    return x
}
func (x EphemeralContainer) IsSetTerminationMessagePath() bool{
    return x.s.HasField(15)
}

func (x EphemeralContainer) TerminationMessagePolicy() TerminationMessagePolicy {
    return TerminationMessagePolicy(segment.GetUint8(x.s, 16))
}

func (x EphemeralContainer) SetTerminationMessagePolicy(value TerminationMessagePolicy) EphemeralContainer {
    segment.SetUint8(x.s, 16, uint8(value))
    return x
}
func (x EphemeralContainer) IsSetTerminationMessagePolicy() bool{
    return x.s.HasField(16)
}

func (x EphemeralContainer) ImagePullPolicy() PullPolicy {
    return PullPolicy(segment.GetUint8(x.s, 17))
}

func (x EphemeralContainer) SetImagePullPolicy(value PullPolicy) EphemeralContainer {
    segment.SetUint8(x.s, 17, uint8(value))
    return x
}
func (x EphemeralContainer) IsSetImagePullPolicy() bool{
    return x.s.HasField(17)
}

func (x EphemeralContainer) SecurityContext() SecurityContext {
    s := segment.GetNestedStruct(x.s, 18, XXXMappingSecurityContext)
    return SecurityContext{s: s}
}

func (x EphemeralContainer) SetSecurityContext(value SecurityContext) EphemeralContainer {
    segment.SetNestedStruct(x.s, 18, value.XXXGetStruct())
    return x
}
func (x EphemeralContainer) IsSetSecurityContext() bool{
    return x.s.HasField(18)
}

func (x EphemeralContainer) Stdin() bool {
    return segment.GetBool(x.s, 19)
}

func (x EphemeralContainer) SetStdin(value bool) EphemeralContainer {
    segment.SetBool(x.s, 19, value)
    return x
}
func (x EphemeralContainer) IsSetStdin() bool{
    return x.s.HasField(19)
}

func (x EphemeralContainer) StdinOnce() bool {
    return segment.GetBool(x.s, 20)
}

func (x EphemeralContainer) SetStdinOnce(value bool) EphemeralContainer {
    segment.SetBool(x.s, 20, value)
    return x
}
func (x EphemeralContainer) IsSetStdinOnce() bool{
    return x.s.HasField(20)
}

func (x EphemeralContainer) Tty() bool {
    return segment.GetBool(x.s, 21)
}

func (x EphemeralContainer) SetTty(value bool) EphemeralContainer {
    segment.SetBool(x.s, 21, value)
    return x
}
func (x EphemeralContainer) IsSetTty() bool{
    return x.s.HasField(21)
}

func (x EphemeralContainer) TargetContainerName() string {
    return segment.GetString(x.s, 22)
}

func (x EphemeralContainer) SetTargetContainerName(value string) EphemeralContainer {
    segment.SetString(x.s, 22, value)
    return x
}
func (x EphemeralContainer) IsSetTargetContainerName() bool{
    return x.s.HasField(22)
}



// ClawStruct returns a reflection type representing the Struct.
func (x EphemeralContainer) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x EphemeralContainer) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x EphemeralContainer) XXXTypeHash() [16]byte {
    return XXXTypeHashEphemeralContainer
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x EphemeralContainer) SetRecording(enabled bool) EphemeralContainer {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x EphemeralContainer) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x EphemeralContainer) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x EphemeralContainer) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// EphemeralContainerRaw is a plain Go struct representation of EphemeralContainer.
// Zero values are not set (sparse encoding).
type EphemeralContainerRaw struct {
    Name string
    Image string
    Command []string
    Args []string
    WorkingDir string
    Ports []*ContainerPortRaw
    EnvFrom []*EnvFromSourceRaw
    Env []*EnvVarRaw
    Resources *ResourceRequirementsRaw
    VolumeMounts []*VolumeMountRaw
    VolumeDevices []*VolumeDeviceRaw
    LivenessProbe *ProbeRaw
    ReadinessProbe *ProbeRaw
    StartupProbe *ProbeRaw
    Lifecycle *LifecycleRaw
    TerminationMessagePath string
    TerminationMessagePolicy TerminationMessagePolicy
    ImagePullPolicy PullPolicy
    SecurityContext *SecurityContextRaw
    Stdin bool
    StdinOnce bool
    Tty bool
    TargetContainerName string
}

// NewEphemeralContainerFromRaw creates a new EphemeralContainer from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewEphemeralContainerFromRaw(ctx context.Context, raw EphemeralContainerRaw) EphemeralContainer {
    x := NewEphemeralContainer(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Image != "" {
        x.SetImage(raw.Image)
    }
    if raw.Command != nil {
        x.SetCommand(raw.Command...)
    }
    if raw.Args != nil {
        x.SetArgs(raw.Args...)
    }
    if raw.WorkingDir != "" {
        x.SetWorkingDir(raw.WorkingDir)
    }
    if raw.Ports != nil {
        list := x.PortsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Ports))
        for _, r := range raw.Ports {
            if r != nil {
                items = append(items, NewContainerPortFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.EnvFrom != nil {
        list := x.EnvFromList(ctx)
        items := make([]*segment.Struct, 0, len(raw.EnvFrom))
        for _, r := range raw.EnvFrom {
            if r != nil {
                items = append(items, NewEnvFromSourceFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Env != nil {
        list := x.EnvList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Env))
        for _, r := range raw.Env {
            if r != nil {
                items = append(items, NewEnvVarFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Resources != nil {
        x.SetResources(NewResourceRequirementsFromRaw(ctx, *raw.Resources))
    }
    if raw.VolumeMounts != nil {
        list := x.VolumeMountsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.VolumeMounts))
        for _, r := range raw.VolumeMounts {
            if r != nil {
                items = append(items, NewVolumeMountFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.VolumeDevices != nil {
        list := x.VolumeDevicesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.VolumeDevices))
        for _, r := range raw.VolumeDevices {
            if r != nil {
                items = append(items, NewVolumeDeviceFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.LivenessProbe != nil {
        x.SetLivenessProbe(NewProbeFromRaw(ctx, *raw.LivenessProbe))
    }
    if raw.ReadinessProbe != nil {
        x.SetReadinessProbe(NewProbeFromRaw(ctx, *raw.ReadinessProbe))
    }
    if raw.StartupProbe != nil {
        x.SetStartupProbe(NewProbeFromRaw(ctx, *raw.StartupProbe))
    }
    if raw.Lifecycle != nil {
        x.SetLifecycle(NewLifecycleFromRaw(ctx, *raw.Lifecycle))
    }
    if raw.TerminationMessagePath != "" {
        x.SetTerminationMessagePath(raw.TerminationMessagePath)
    }
    if raw.TerminationMessagePolicy != 0 {
        x.SetTerminationMessagePolicy(raw.TerminationMessagePolicy)
    }
    if raw.ImagePullPolicy != 0 {
        x.SetImagePullPolicy(raw.ImagePullPolicy)
    }
    if raw.SecurityContext != nil {
        x.SetSecurityContext(NewSecurityContextFromRaw(ctx, *raw.SecurityContext))
    }
    if raw.Stdin {
        x.SetStdin(raw.Stdin)
    }
    if raw.StdinOnce {
        x.SetStdinOnce(raw.StdinOnce)
    }
    if raw.Tty {
        x.SetTty(raw.Tty)
    }
    if raw.TargetContainerName != "" {
        x.SetTargetContainerName(raw.TargetContainerName)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x EphemeralContainer) ToRaw(ctx context.Context) EphemeralContainerRaw {
    raw := EphemeralContainerRaw{}
    raw.Name = x.Name()
    raw.Image = x.Image()
    if l := x.s.GetList(2); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Command = l.(*segment.Strings).Slice()
    } else if x.s.HasField(2) {
        raw.Command = x.Command().Slice()
    }
    if l := x.s.GetList(3); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Args = l.(*segment.Strings).Slice()
    } else if x.s.HasField(3) {
        raw.Args = x.Args().Slice()
    }
    raw.WorkingDir = x.WorkingDir()
    if l := x.s.GetList(5); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Ports = make([]*ContainerPortRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerPort{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Ports[i] = &itemRaw
        }
    } else if x.s.HasField(5) {
        list := x.PortsList(ctx)
        raw.Ports = make([]*ContainerPortRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerPort{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Ports[i] = &itemRaw
        }
    }
    if l := x.s.GetList(6); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.EnvFrom = make([]*EnvFromSourceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EnvFromSource{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.EnvFrom[i] = &itemRaw
        }
    } else if x.s.HasField(6) {
        list := x.EnvFromList(ctx)
        raw.EnvFrom = make([]*EnvFromSourceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EnvFromSource{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.EnvFrom[i] = &itemRaw
        }
    }
    if l := x.s.GetList(7); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Env = make([]*EnvVarRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EnvVar{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Env[i] = &itemRaw
        }
    } else if x.s.HasField(7) {
        list := x.EnvList(ctx)
        raw.Env = make([]*EnvVarRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EnvVar{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Env[i] = &itemRaw
        }
    }
    if x.s.HasField(8) {
        nestedRaw := x.Resources().ToRaw(ctx)
        raw.Resources = &nestedRaw
    }
    if l := x.s.GetList(9); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.VolumeMounts = make([]*VolumeMountRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeMount{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeMounts[i] = &itemRaw
        }
    } else if x.s.HasField(9) {
        list := x.VolumeMountsList(ctx)
        raw.VolumeMounts = make([]*VolumeMountRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeMount{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeMounts[i] = &itemRaw
        }
    }
    if l := x.s.GetList(10); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.VolumeDevices = make([]*VolumeDeviceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeDevice{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeDevices[i] = &itemRaw
        }
    } else if x.s.HasField(10) {
        list := x.VolumeDevicesList(ctx)
        raw.VolumeDevices = make([]*VolumeDeviceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeDevice{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.VolumeDevices[i] = &itemRaw
        }
    }
    if x.s.HasField(11) {
        nestedRaw := x.LivenessProbe().ToRaw(ctx)
        raw.LivenessProbe = &nestedRaw
    }
    if x.s.HasField(12) {
        nestedRaw := x.ReadinessProbe().ToRaw(ctx)
        raw.ReadinessProbe = &nestedRaw
    }
    if x.s.HasField(13) {
        nestedRaw := x.StartupProbe().ToRaw(ctx)
        raw.StartupProbe = &nestedRaw
    }
    if x.s.HasField(14) {
        nestedRaw := x.Lifecycle().ToRaw(ctx)
        raw.Lifecycle = &nestedRaw
    }
    raw.TerminationMessagePath = x.TerminationMessagePath()
    raw.TerminationMessagePolicy = x.TerminationMessagePolicy()
    raw.ImagePullPolicy = x.ImagePullPolicy()
    if x.s.HasField(18) {
        nestedRaw := x.SecurityContext().ToRaw(ctx)
        raw.SecurityContext = &nestedRaw
    }
    raw.Stdin = x.Stdin()
    raw.StdinOnce = x.StdinOnce()
    raw.Tty = x.Tty()
    raw.TargetContainerName = x.TargetContainerName()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x EphemeralContainer) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(25)
}

// EphemeralVolumeSource represents an ephemeral volume.
type EphemeralVolumeSource struct {
   s *segment.Struct
}

// NewEphemeralVolumeSource creates a new pooled instance of EphemeralVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewEphemeralVolumeSource(ctx context.Context) EphemeralVolumeSource {
    s := segment.New(ctx, XXXMappingEphemeralVolumeSource)
    s.SetIsSetEnabled(true)
    return EphemeralVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x EphemeralVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewEphemeralVolumeSourceFrom creates a new EphemeralVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewEphemeralVolumeSourceFrom(s *segment.Struct) EphemeralVolumeSource {
    return EphemeralVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x EphemeralVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x EphemeralVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x EphemeralVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x EphemeralVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x EphemeralVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x EphemeralVolumeSource) VolumeClaimTemplate() PersistentVolumeClaimTemplate {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingPersistentVolumeClaimTemplate)
    return PersistentVolumeClaimTemplate{s: s}
}

func (x EphemeralVolumeSource) SetVolumeClaimTemplate(value PersistentVolumeClaimTemplate) EphemeralVolumeSource {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x EphemeralVolumeSource) IsSetVolumeClaimTemplate() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x EphemeralVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x EphemeralVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x EphemeralVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashEphemeralVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x EphemeralVolumeSource) SetRecording(enabled bool) EphemeralVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x EphemeralVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x EphemeralVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x EphemeralVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// EphemeralVolumeSourceRaw is a plain Go struct representation of EphemeralVolumeSource.
// Zero values are not set (sparse encoding).
type EphemeralVolumeSourceRaw struct {
    VolumeClaimTemplate *PersistentVolumeClaimTemplateRaw
}

// NewEphemeralVolumeSourceFromRaw creates a new EphemeralVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewEphemeralVolumeSourceFromRaw(ctx context.Context, raw EphemeralVolumeSourceRaw) EphemeralVolumeSource {
    x := NewEphemeralVolumeSource(ctx)
    if raw.VolumeClaimTemplate != nil {
        x.SetVolumeClaimTemplate(NewPersistentVolumeClaimTemplateFromRaw(ctx, *raw.VolumeClaimTemplate))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x EphemeralVolumeSource) ToRaw(ctx context.Context) EphemeralVolumeSourceRaw {
    raw := EphemeralVolumeSourceRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.VolumeClaimTemplate().ToRaw(ctx)
        raw.VolumeClaimTemplate = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x EphemeralVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(26)
}

// ExecAction describes a "run in container" action.
type ExecAction struct {
   s *segment.Struct
}

// NewExecAction creates a new pooled instance of ExecAction.
// Call Release() when done to return it to the pool for reuse.
func NewExecAction(ctx context.Context) ExecAction {
    s := segment.New(ctx, XXXMappingExecAction)
    s.SetIsSetEnabled(true)
    return ExecAction{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ExecAction) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewExecActionFrom creates a new ExecAction from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewExecActionFrom(s *segment.Struct) ExecAction {
    return ExecAction{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ExecAction) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ExecAction) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ExecAction) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ExecAction) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ExecAction) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ExecAction) Command() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 0); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 0)
    return strs
}

// SetCommand replaces all values in the string list.
func (x ExecAction) SetCommand(v ...string) ExecAction {
    strs := x.Command()
    strs.SetAll(v)
    return x
}
func (x ExecAction) IsSetCommand() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ExecAction) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ExecAction) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ExecAction) XXXTypeHash() [16]byte {
    return XXXTypeHashExecAction
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ExecAction) SetRecording(enabled bool) ExecAction {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ExecAction) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ExecAction) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ExecAction) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ExecActionRaw is a plain Go struct representation of ExecAction.
// Zero values are not set (sparse encoding).
type ExecActionRaw struct {
    Command []string
}

// NewExecActionFromRaw creates a new ExecAction from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewExecActionFromRaw(ctx context.Context, raw ExecActionRaw) ExecAction {
    x := NewExecAction(ctx)
    if raw.Command != nil {
        x.SetCommand(raw.Command...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ExecAction) ToRaw(ctx context.Context) ExecActionRaw {
    raw := ExecActionRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Command = l.(*segment.Strings).Slice()
    } else if x.s.HasField(0) {
        raw.Command = x.Command().Slice()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ExecAction) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(27)
}

// GCEPersistentDiskVolumeSource represents a GCE persistent disk.
type GCEPersistentDiskVolumeSource struct {
   s *segment.Struct
}

// NewGCEPersistentDiskVolumeSource creates a new pooled instance of GCEPersistentDiskVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewGCEPersistentDiskVolumeSource(ctx context.Context) GCEPersistentDiskVolumeSource {
    s := segment.New(ctx, XXXMappingGCEPersistentDiskVolumeSource)
    s.SetIsSetEnabled(true)
    return GCEPersistentDiskVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x GCEPersistentDiskVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewGCEPersistentDiskVolumeSourceFrom creates a new GCEPersistentDiskVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewGCEPersistentDiskVolumeSourceFrom(s *segment.Struct) GCEPersistentDiskVolumeSource {
    return GCEPersistentDiskVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x GCEPersistentDiskVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x GCEPersistentDiskVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x GCEPersistentDiskVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x GCEPersistentDiskVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x GCEPersistentDiskVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x GCEPersistentDiskVolumeSource) PdName() string {
    return segment.GetString(x.s, 0)
}

func (x GCEPersistentDiskVolumeSource) SetPdName(value string) GCEPersistentDiskVolumeSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x GCEPersistentDiskVolumeSource) IsSetPdName() bool{
    return x.s.HasField(0)
}

func (x GCEPersistentDiskVolumeSource) FsType() string {
    return segment.GetString(x.s, 1)
}

func (x GCEPersistentDiskVolumeSource) SetFsType(value string) GCEPersistentDiskVolumeSource {
    segment.SetString(x.s, 1, value)
    return x
}
func (x GCEPersistentDiskVolumeSource) IsSetFsType() bool{
    return x.s.HasField(1)
}

func (x GCEPersistentDiskVolumeSource) Partition() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x GCEPersistentDiskVolumeSource) SetPartition(value int32) GCEPersistentDiskVolumeSource {
    segment.SetInt32(x.s, 2, value)
    return x
}
func (x GCEPersistentDiskVolumeSource) IsSetPartition() bool{
    return x.s.HasField(2)
}

func (x GCEPersistentDiskVolumeSource) ReadOnly() bool {
    return segment.GetBool(x.s, 3)
}

func (x GCEPersistentDiskVolumeSource) SetReadOnly(value bool) GCEPersistentDiskVolumeSource {
    segment.SetBool(x.s, 3, value)
    return x
}
func (x GCEPersistentDiskVolumeSource) IsSetReadOnly() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x GCEPersistentDiskVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x GCEPersistentDiskVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x GCEPersistentDiskVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashGCEPersistentDiskVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x GCEPersistentDiskVolumeSource) SetRecording(enabled bool) GCEPersistentDiskVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x GCEPersistentDiskVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x GCEPersistentDiskVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x GCEPersistentDiskVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// GCEPersistentDiskVolumeSourceRaw is a plain Go struct representation of GCEPersistentDiskVolumeSource.
// Zero values are not set (sparse encoding).
type GCEPersistentDiskVolumeSourceRaw struct {
    PdName string
    FsType string
    Partition int32
    ReadOnly bool
}

// NewGCEPersistentDiskVolumeSourceFromRaw creates a new GCEPersistentDiskVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewGCEPersistentDiskVolumeSourceFromRaw(ctx context.Context, raw GCEPersistentDiskVolumeSourceRaw) GCEPersistentDiskVolumeSource {
    x := NewGCEPersistentDiskVolumeSource(ctx)
    if raw.PdName != "" {
        x.SetPdName(raw.PdName)
    }
    if raw.FsType != "" {
        x.SetFsType(raw.FsType)
    }
    if raw.Partition != 0 {
        x.SetPartition(raw.Partition)
    }
    if raw.ReadOnly {
        x.SetReadOnly(raw.ReadOnly)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x GCEPersistentDiskVolumeSource) ToRaw(ctx context.Context) GCEPersistentDiskVolumeSourceRaw {
    raw := GCEPersistentDiskVolumeSourceRaw{}
    raw.PdName = x.PdName()
    raw.FsType = x.FsType()
    raw.Partition = x.Partition()
    raw.ReadOnly = x.ReadOnly()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x GCEPersistentDiskVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(28)
}

// GRPCAction describes an action involving a GRPC port.
type GRPCAction struct {
   s *segment.Struct
}

// NewGRPCAction creates a new pooled instance of GRPCAction.
// Call Release() when done to return it to the pool for reuse.
func NewGRPCAction(ctx context.Context) GRPCAction {
    s := segment.New(ctx, XXXMappingGRPCAction)
    s.SetIsSetEnabled(true)
    return GRPCAction{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x GRPCAction) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewGRPCActionFrom creates a new GRPCAction from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewGRPCActionFrom(s *segment.Struct) GRPCAction {
    return GRPCAction{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x GRPCAction) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x GRPCAction) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x GRPCAction) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x GRPCAction) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x GRPCAction) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x GRPCAction) Port() int32 {
    return segment.GetInt32(x.s, 0)
}

func (x GRPCAction) SetPort(value int32) GRPCAction {
    segment.SetInt32(x.s, 0, value)
    return x
}
func (x GRPCAction) IsSetPort() bool{
    return x.s.HasField(0)
}

func (x GRPCAction) Service() string {
    return segment.GetString(x.s, 1)
}

func (x GRPCAction) SetService(value string) GRPCAction {
    segment.SetString(x.s, 1, value)
    return x
}
func (x GRPCAction) IsSetService() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x GRPCAction) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x GRPCAction) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x GRPCAction) XXXTypeHash() [16]byte {
    return XXXTypeHashGRPCAction
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x GRPCAction) SetRecording(enabled bool) GRPCAction {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x GRPCAction) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x GRPCAction) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x GRPCAction) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// GRPCActionRaw is a plain Go struct representation of GRPCAction.
// Zero values are not set (sparse encoding).
type GRPCActionRaw struct {
    Port int32
    Service string
}

// NewGRPCActionFromRaw creates a new GRPCAction from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewGRPCActionFromRaw(ctx context.Context, raw GRPCActionRaw) GRPCAction {
    x := NewGRPCAction(ctx)
    if raw.Port != 0 {
        x.SetPort(raw.Port)
    }
    if raw.Service != "" {
        x.SetService(raw.Service)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x GRPCAction) ToRaw(ctx context.Context) GRPCActionRaw {
    raw := GRPCActionRaw{}
    raw.Port = x.Port()
    raw.Service = x.Service()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x GRPCAction) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(29)
}

// HTTPGetAction describes an action based on HTTP Get requests.
type HTTPGetAction struct {
   s *segment.Struct
}

// NewHTTPGetAction creates a new pooled instance of HTTPGetAction.
// Call Release() when done to return it to the pool for reuse.
func NewHTTPGetAction(ctx context.Context) HTTPGetAction {
    s := segment.New(ctx, XXXMappingHTTPGetAction)
    s.SetIsSetEnabled(true)
    return HTTPGetAction{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x HTTPGetAction) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewHTTPGetActionFrom creates a new HTTPGetAction from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewHTTPGetActionFrom(s *segment.Struct) HTTPGetAction {
    return HTTPGetAction{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x HTTPGetAction) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x HTTPGetAction) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x HTTPGetAction) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x HTTPGetAction) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x HTTPGetAction) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x HTTPGetAction) Path() string {
    return segment.GetString(x.s, 0)
}

func (x HTTPGetAction) SetPath(value string) HTTPGetAction {
    segment.SetString(x.s, 0, value)
    return x
}
func (x HTTPGetAction) IsSetPath() bool{
    return x.s.HasField(0)
}

func (x HTTPGetAction) Port() IntOrString {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingIntOrString)
    return IntOrString{s: s}
}

func (x HTTPGetAction) SetPort(value IntOrString) HTTPGetAction {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x HTTPGetAction) IsSetPort() bool{
    return x.s.HasField(1)
}

func (x HTTPGetAction) Host() string {
    return segment.GetString(x.s, 2)
}

func (x HTTPGetAction) SetHost(value string) HTTPGetAction {
    segment.SetString(x.s, 2, value)
    return x
}
func (x HTTPGetAction) IsSetHost() bool{
    return x.s.HasField(2)
}

func (x HTTPGetAction) Scheme() URIScheme {
    return URIScheme(segment.GetUint8(x.s, 3))
}

func (x HTTPGetAction) SetScheme(value URIScheme) HTTPGetAction {
    segment.SetUint8(x.s, 3, uint8(value))
    return x
}
func (x HTTPGetAction) IsSetScheme() bool{
    return x.s.HasField(3)
}

// HttpHeadersList returns the underlying Structs list for iteration.
// Use NewHTTPHeader() to create items and Append to add them.
func (x HTTPGetAction) HttpHeadersList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 4, XXXMappingHTTPHeader); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 4, XXXMappingHTTPHeader)
    return structs
}

// HttpHeadersLen returns the number of items in the list.
func (x HTTPGetAction) HttpHeadersLen(ctx context.Context) int {
    return x.HttpHeadersList(ctx).Len()
}

// HttpHeadersGet returns the item at the given index.
func (x HTTPGetAction) HttpHeadersGet(ctx context.Context, index int) HTTPHeader {
    s := x.HttpHeadersList(ctx).Get(index)
    return HTTPHeader{s: s}
}

// HttpHeadersAppend appends items to the list.
func (x HTTPGetAction) HttpHeadersAppend(ctx context.Context, values ...HTTPHeader) {
    list := x.HttpHeadersList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// HttpHeadersAppendRaw appends items to the list using Raw struct representations.
func (x HTTPGetAction) HttpHeadersAppendRaw(ctx context.Context, values ...*HTTPHeaderRaw) {
    list := x.HttpHeadersList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewHTTPHeaderFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x HTTPGetAction) IsSetHttpHeaders() bool{
    return x.s.HasField(4)
}



// ClawStruct returns a reflection type representing the Struct.
func (x HTTPGetAction) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x HTTPGetAction) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x HTTPGetAction) XXXTypeHash() [16]byte {
    return XXXTypeHashHTTPGetAction
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x HTTPGetAction) SetRecording(enabled bool) HTTPGetAction {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x HTTPGetAction) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x HTTPGetAction) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x HTTPGetAction) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// HTTPGetActionRaw is a plain Go struct representation of HTTPGetAction.
// Zero values are not set (sparse encoding).
type HTTPGetActionRaw struct {
    Path string
    Port *IntOrStringRaw
    Host string
    Scheme URIScheme
    HttpHeaders []*HTTPHeaderRaw
}

// NewHTTPGetActionFromRaw creates a new HTTPGetAction from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewHTTPGetActionFromRaw(ctx context.Context, raw HTTPGetActionRaw) HTTPGetAction {
    x := NewHTTPGetAction(ctx)
    if raw.Path != "" {
        x.SetPath(raw.Path)
    }
    if raw.Port != nil {
        x.SetPort(NewIntOrStringFromRaw(ctx, *raw.Port))
    }
    if raw.Host != "" {
        x.SetHost(raw.Host)
    }
    if raw.Scheme != 0 {
        x.SetScheme(raw.Scheme)
    }
    if raw.HttpHeaders != nil {
        list := x.HttpHeadersList(ctx)
        items := make([]*segment.Struct, 0, len(raw.HttpHeaders))
        for _, r := range raw.HttpHeaders {
            if r != nil {
                items = append(items, NewHTTPHeaderFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x HTTPGetAction) ToRaw(ctx context.Context) HTTPGetActionRaw {
    raw := HTTPGetActionRaw{}
    raw.Path = x.Path()
    if x.s.HasField(1) {
        nestedRaw := x.Port().ToRaw(ctx)
        raw.Port = &nestedRaw
    }
    raw.Host = x.Host()
    raw.Scheme = x.Scheme()
    if l := x.s.GetList(4); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.HttpHeaders = make([]*HTTPHeaderRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := HTTPHeader{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.HttpHeaders[i] = &itemRaw
        }
    } else if x.s.HasField(4) {
        list := x.HttpHeadersList(ctx)
        raw.HttpHeaders = make([]*HTTPHeaderRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := HTTPHeader{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.HttpHeaders[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x HTTPGetAction) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(30)
}

// HTTPHeader describes a custom header to be used in HTTP probes.
type HTTPHeader struct {
   s *segment.Struct
}

// NewHTTPHeader creates a new pooled instance of HTTPHeader.
// Call Release() when done to return it to the pool for reuse.
func NewHTTPHeader(ctx context.Context) HTTPHeader {
    s := segment.New(ctx, XXXMappingHTTPHeader)
    s.SetIsSetEnabled(true)
    return HTTPHeader{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x HTTPHeader) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewHTTPHeaderFrom creates a new HTTPHeader from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewHTTPHeaderFrom(s *segment.Struct) HTTPHeader {
    return HTTPHeader{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x HTTPHeader) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x HTTPHeader) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x HTTPHeader) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x HTTPHeader) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x HTTPHeader) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x HTTPHeader) Name() string {
    return segment.GetString(x.s, 0)
}

func (x HTTPHeader) SetName(value string) HTTPHeader {
    segment.SetString(x.s, 0, value)
    return x
}
func (x HTTPHeader) IsSetName() bool{
    return x.s.HasField(0)
}

func (x HTTPHeader) Value() string {
    return segment.GetString(x.s, 1)
}

func (x HTTPHeader) SetValue(value string) HTTPHeader {
    segment.SetString(x.s, 1, value)
    return x
}
func (x HTTPHeader) IsSetValue() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x HTTPHeader) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x HTTPHeader) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x HTTPHeader) XXXTypeHash() [16]byte {
    return XXXTypeHashHTTPHeader
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x HTTPHeader) SetRecording(enabled bool) HTTPHeader {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x HTTPHeader) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x HTTPHeader) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x HTTPHeader) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// HTTPHeaderRaw is a plain Go struct representation of HTTPHeader.
// Zero values are not set (sparse encoding).
type HTTPHeaderRaw struct {
    Name string
    Value string
}

// NewHTTPHeaderFromRaw creates a new HTTPHeader from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewHTTPHeaderFromRaw(ctx context.Context, raw HTTPHeaderRaw) HTTPHeader {
    x := NewHTTPHeader(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Value != "" {
        x.SetValue(raw.Value)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x HTTPHeader) ToRaw(ctx context.Context) HTTPHeaderRaw {
    raw := HTTPHeaderRaw{}
    raw.Name = x.Name()
    raw.Value = x.Value()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x HTTPHeader) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(31)
}

// HostAlias holds the mapping between IP and hostnames.
type HostAlias struct {
   s *segment.Struct
}

// NewHostAlias creates a new pooled instance of HostAlias.
// Call Release() when done to return it to the pool for reuse.
func NewHostAlias(ctx context.Context) HostAlias {
    s := segment.New(ctx, XXXMappingHostAlias)
    s.SetIsSetEnabled(true)
    return HostAlias{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x HostAlias) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewHostAliasFrom creates a new HostAlias from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewHostAliasFrom(s *segment.Struct) HostAlias {
    return HostAlias{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x HostAlias) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x HostAlias) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x HostAlias) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x HostAlias) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x HostAlias) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x HostAlias) Ip() string {
    return segment.GetString(x.s, 0)
}

func (x HostAlias) SetIp(value string) HostAlias {
    segment.SetString(x.s, 0, value)
    return x
}
func (x HostAlias) IsSetIp() bool{
    return x.s.HasField(0)
}

func (x HostAlias) Hostnames() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 1); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 1)
    return strs
}

// SetHostnames replaces all values in the string list.
func (x HostAlias) SetHostnames(v ...string) HostAlias {
    strs := x.Hostnames()
    strs.SetAll(v)
    return x
}
func (x HostAlias) IsSetHostnames() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x HostAlias) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x HostAlias) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x HostAlias) XXXTypeHash() [16]byte {
    return XXXTypeHashHostAlias
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x HostAlias) SetRecording(enabled bool) HostAlias {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x HostAlias) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x HostAlias) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x HostAlias) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// HostAliasRaw is a plain Go struct representation of HostAlias.
// Zero values are not set (sparse encoding).
type HostAliasRaw struct {
    Ip string
    Hostnames []string
}

// NewHostAliasFromRaw creates a new HostAlias from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewHostAliasFromRaw(ctx context.Context, raw HostAliasRaw) HostAlias {
    x := NewHostAlias(ctx)
    if raw.Ip != "" {
        x.SetIp(raw.Ip)
    }
    if raw.Hostnames != nil {
        x.SetHostnames(raw.Hostnames...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x HostAlias) ToRaw(ctx context.Context) HostAliasRaw {
    raw := HostAliasRaw{}
    raw.Ip = x.Ip()
    if l := x.s.GetList(1); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Hostnames = l.(*segment.Strings).Slice()
    } else if x.s.HasField(1) {
        raw.Hostnames = x.Hostnames().Slice()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x HostAlias) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(32)
}

// HostIP represents a single IP address allocated to the host.
type HostIP struct {
   s *segment.Struct
}

// NewHostIP creates a new pooled instance of HostIP.
// Call Release() when done to return it to the pool for reuse.
func NewHostIP(ctx context.Context) HostIP {
    s := segment.New(ctx, XXXMappingHostIP)
    s.SetIsSetEnabled(true)
    return HostIP{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x HostIP) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewHostIPFrom creates a new HostIP from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewHostIPFrom(s *segment.Struct) HostIP {
    return HostIP{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x HostIP) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x HostIP) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x HostIP) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x HostIP) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x HostIP) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x HostIP) Ip() string {
    return segment.GetString(x.s, 0)
}

func (x HostIP) SetIp(value string) HostIP {
    segment.SetString(x.s, 0, value)
    return x
}
func (x HostIP) IsSetIp() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x HostIP) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x HostIP) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x HostIP) XXXTypeHash() [16]byte {
    return XXXTypeHashHostIP
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x HostIP) SetRecording(enabled bool) HostIP {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x HostIP) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x HostIP) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x HostIP) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// HostIPRaw is a plain Go struct representation of HostIP.
// Zero values are not set (sparse encoding).
type HostIPRaw struct {
    Ip string
}

// NewHostIPFromRaw creates a new HostIP from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewHostIPFromRaw(ctx context.Context, raw HostIPRaw) HostIP {
    x := NewHostIP(ctx)
    if raw.Ip != "" {
        x.SetIp(raw.Ip)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x HostIP) ToRaw(ctx context.Context) HostIPRaw {
    raw := HostIPRaw{}
    raw.Ip = x.Ip()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x HostIP) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(33)
}

// HostPathVolumeSource represents a host path mapped into a pod.
type HostPathVolumeSource struct {
   s *segment.Struct
}

// NewHostPathVolumeSource creates a new pooled instance of HostPathVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewHostPathVolumeSource(ctx context.Context) HostPathVolumeSource {
    s := segment.New(ctx, XXXMappingHostPathVolumeSource)
    s.SetIsSetEnabled(true)
    return HostPathVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x HostPathVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewHostPathVolumeSourceFrom creates a new HostPathVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewHostPathVolumeSourceFrom(s *segment.Struct) HostPathVolumeSource {
    return HostPathVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x HostPathVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x HostPathVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x HostPathVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x HostPathVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x HostPathVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x HostPathVolumeSource) Path() string {
    return segment.GetString(x.s, 0)
}

func (x HostPathVolumeSource) SetPath(value string) HostPathVolumeSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x HostPathVolumeSource) IsSetPath() bool{
    return x.s.HasField(0)
}

func (x HostPathVolumeSource) Type() HostPathType {
    return HostPathType(segment.GetUint8(x.s, 1))
}

func (x HostPathVolumeSource) SetType(value HostPathType) HostPathVolumeSource {
    segment.SetUint8(x.s, 1, uint8(value))
    return x
}
func (x HostPathVolumeSource) IsSetType() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x HostPathVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x HostPathVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x HostPathVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashHostPathVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x HostPathVolumeSource) SetRecording(enabled bool) HostPathVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x HostPathVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x HostPathVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x HostPathVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// HostPathVolumeSourceRaw is a plain Go struct representation of HostPathVolumeSource.
// Zero values are not set (sparse encoding).
type HostPathVolumeSourceRaw struct {
    Path string
    Type HostPathType
}

// NewHostPathVolumeSourceFromRaw creates a new HostPathVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewHostPathVolumeSourceFromRaw(ctx context.Context, raw HostPathVolumeSourceRaw) HostPathVolumeSource {
    x := NewHostPathVolumeSource(ctx)
    if raw.Path != "" {
        x.SetPath(raw.Path)
    }
    if raw.Type != 0 {
        x.SetType(raw.Type)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x HostPathVolumeSource) ToRaw(ctx context.Context) HostPathVolumeSourceRaw {
    raw := HostPathVolumeSourceRaw{}
    raw.Path = x.Path()
    raw.Type = x.Type()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x HostPathVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(34)
}

// IntOrString is a type that can hold an int32 or a string.
type IntOrString struct {
   s *segment.Struct
}

// NewIntOrString creates a new pooled instance of IntOrString.
// Call Release() when done to return it to the pool for reuse.
func NewIntOrString(ctx context.Context) IntOrString {
    s := segment.New(ctx, XXXMappingIntOrString)
    s.SetIsSetEnabled(true)
    return IntOrString{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x IntOrString) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewIntOrStringFrom creates a new IntOrString from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewIntOrStringFrom(s *segment.Struct) IntOrString {
    return IntOrString{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x IntOrString) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x IntOrString) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x IntOrString) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x IntOrString) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x IntOrString) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x IntOrString) IntVal() int32 {
    return segment.GetInt32(x.s, 0)
}

func (x IntOrString) SetIntVal(value int32) IntOrString {
    segment.SetInt32(x.s, 0, value)
    return x
}
func (x IntOrString) IsSetIntVal() bool{
    return x.s.HasField(0)
}

func (x IntOrString) StrVal() string {
    return segment.GetString(x.s, 1)
}

func (x IntOrString) SetStrVal(value string) IntOrString {
    segment.SetString(x.s, 1, value)
    return x
}
func (x IntOrString) IsSetStrVal() bool{
    return x.s.HasField(1)
}

func (x IntOrString) IsString() bool {
    return segment.GetBool(x.s, 2)
}

func (x IntOrString) SetIsString(value bool) IntOrString {
    segment.SetBool(x.s, 2, value)
    return x
}
func (x IntOrString) IsSetIsString() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x IntOrString) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x IntOrString) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x IntOrString) XXXTypeHash() [16]byte {
    return XXXTypeHashIntOrString
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x IntOrString) SetRecording(enabled bool) IntOrString {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x IntOrString) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x IntOrString) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x IntOrString) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// IntOrStringRaw is a plain Go struct representation of IntOrString.
// Zero values are not set (sparse encoding).
type IntOrStringRaw struct {
    IntVal int32
    StrVal string
    IsString bool
}

// NewIntOrStringFromRaw creates a new IntOrString from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewIntOrStringFromRaw(ctx context.Context, raw IntOrStringRaw) IntOrString {
    x := NewIntOrString(ctx)
    if raw.IntVal != 0 {
        x.SetIntVal(raw.IntVal)
    }
    if raw.StrVal != "" {
        x.SetStrVal(raw.StrVal)
    }
    if raw.IsString {
        x.SetIsString(raw.IsString)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x IntOrString) ToRaw(ctx context.Context) IntOrStringRaw {
    raw := IntOrStringRaw{}
    raw.IntVal = x.IntVal()
    raw.StrVal = x.StrVal()
    raw.IsString = x.IsString()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x IntOrString) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(35)
}

// KeyToPath maps a string key to a path within a volume.
type KeyToPath struct {
   s *segment.Struct
}

// NewKeyToPath creates a new pooled instance of KeyToPath.
// Call Release() when done to return it to the pool for reuse.
func NewKeyToPath(ctx context.Context) KeyToPath {
    s := segment.New(ctx, XXXMappingKeyToPath)
    s.SetIsSetEnabled(true)
    return KeyToPath{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x KeyToPath) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewKeyToPathFrom creates a new KeyToPath from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewKeyToPathFrom(s *segment.Struct) KeyToPath {
    return KeyToPath{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x KeyToPath) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x KeyToPath) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x KeyToPath) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x KeyToPath) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x KeyToPath) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x KeyToPath) Key() string {
    return segment.GetString(x.s, 0)
}

func (x KeyToPath) SetKey(value string) KeyToPath {
    segment.SetString(x.s, 0, value)
    return x
}
func (x KeyToPath) IsSetKey() bool{
    return x.s.HasField(0)
}

func (x KeyToPath) Path() string {
    return segment.GetString(x.s, 1)
}

func (x KeyToPath) SetPath(value string) KeyToPath {
    segment.SetString(x.s, 1, value)
    return x
}
func (x KeyToPath) IsSetPath() bool{
    return x.s.HasField(1)
}

func (x KeyToPath) Mode() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x KeyToPath) SetMode(value int32) KeyToPath {
    segment.SetInt32(x.s, 2, value)
    return x
}
func (x KeyToPath) IsSetMode() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x KeyToPath) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x KeyToPath) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x KeyToPath) XXXTypeHash() [16]byte {
    return XXXTypeHashKeyToPath
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x KeyToPath) SetRecording(enabled bool) KeyToPath {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x KeyToPath) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x KeyToPath) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x KeyToPath) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// KeyToPathRaw is a plain Go struct representation of KeyToPath.
// Zero values are not set (sparse encoding).
type KeyToPathRaw struct {
    Key string
    Path string
    Mode int32
}

// NewKeyToPathFromRaw creates a new KeyToPath from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewKeyToPathFromRaw(ctx context.Context, raw KeyToPathRaw) KeyToPath {
    x := NewKeyToPath(ctx)
    if raw.Key != "" {
        x.SetKey(raw.Key)
    }
    if raw.Path != "" {
        x.SetPath(raw.Path)
    }
    if raw.Mode != 0 {
        x.SetMode(raw.Mode)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x KeyToPath) ToRaw(ctx context.Context) KeyToPathRaw {
    raw := KeyToPathRaw{}
    raw.Key = x.Key()
    raw.Path = x.Path()
    raw.Mode = x.Mode()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x KeyToPath) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(36)
}

// KeyValue represents a key-value pair for maps.
type KeyValue struct {
   s *segment.Struct
}

// NewKeyValue creates a new pooled instance of KeyValue.
// Call Release() when done to return it to the pool for reuse.
func NewKeyValue(ctx context.Context) KeyValue {
    s := segment.New(ctx, XXXMappingKeyValue)
    s.SetIsSetEnabled(true)
    return KeyValue{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x KeyValue) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewKeyValueFrom creates a new KeyValue from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewKeyValueFrom(s *segment.Struct) KeyValue {
    return KeyValue{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x KeyValue) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x KeyValue) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x KeyValue) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x KeyValue) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x KeyValue) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x KeyValue) Key() string {
    return segment.GetString(x.s, 0)
}

func (x KeyValue) SetKey(value string) KeyValue {
    segment.SetString(x.s, 0, value)
    return x
}
func (x KeyValue) IsSetKey() bool{
    return x.s.HasField(0)
}

func (x KeyValue) Value() string {
    return segment.GetString(x.s, 1)
}

func (x KeyValue) SetValue(value string) KeyValue {
    segment.SetString(x.s, 1, value)
    return x
}
func (x KeyValue) IsSetValue() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x KeyValue) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x KeyValue) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x KeyValue) XXXTypeHash() [16]byte {
    return XXXTypeHashKeyValue
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x KeyValue) SetRecording(enabled bool) KeyValue {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x KeyValue) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x KeyValue) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x KeyValue) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// KeyValueRaw is a plain Go struct representation of KeyValue.
// Zero values are not set (sparse encoding).
type KeyValueRaw struct {
    Key string
    Value string
}

// NewKeyValueFromRaw creates a new KeyValue from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewKeyValueFromRaw(ctx context.Context, raw KeyValueRaw) KeyValue {
    x := NewKeyValue(ctx)
    if raw.Key != "" {
        x.SetKey(raw.Key)
    }
    if raw.Value != "" {
        x.SetValue(raw.Value)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x KeyValue) ToRaw(ctx context.Context) KeyValueRaw {
    raw := KeyValueRaw{}
    raw.Key = x.Key()
    raw.Value = x.Value()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x KeyValue) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(37)
}

// LabelSelector is a label query over a set of resources.
type LabelSelector struct {
   s *segment.Struct
}

// NewLabelSelector creates a new pooled instance of LabelSelector.
// Call Release() when done to return it to the pool for reuse.
func NewLabelSelector(ctx context.Context) LabelSelector {
    s := segment.New(ctx, XXXMappingLabelSelector)
    s.SetIsSetEnabled(true)
    return LabelSelector{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x LabelSelector) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewLabelSelectorFrom creates a new LabelSelector from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewLabelSelectorFrom(s *segment.Struct) LabelSelector {
    return LabelSelector{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x LabelSelector) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x LabelSelector) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x LabelSelector) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x LabelSelector) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x LabelSelector) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// MatchLabelsList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x LabelSelector) MatchLabelsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingKeyValue)
    return structs
}

// MatchLabelsLen returns the number of items in the list.
func (x LabelSelector) MatchLabelsLen(ctx context.Context) int {
    return x.MatchLabelsList(ctx).Len()
}

// MatchLabelsGet returns the item at the given index.
func (x LabelSelector) MatchLabelsGet(ctx context.Context, index int) KeyValue {
    s := x.MatchLabelsList(ctx).Get(index)
    return KeyValue{s: s}
}

// MatchLabelsAppend appends items to the list.
func (x LabelSelector) MatchLabelsAppend(ctx context.Context, values ...KeyValue) {
    list := x.MatchLabelsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// MatchLabelsAppendRaw appends items to the list using Raw struct representations.
func (x LabelSelector) MatchLabelsAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.MatchLabelsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x LabelSelector) IsSetMatchLabels() bool{
    return x.s.HasField(0)
}

// MatchExpressionsList returns the underlying Structs list for iteration.
// Use NewLabelSelectorRequirement() to create items and Append to add them.
func (x LabelSelector) MatchExpressionsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingLabelSelectorRequirement); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingLabelSelectorRequirement)
    return structs
}

// MatchExpressionsLen returns the number of items in the list.
func (x LabelSelector) MatchExpressionsLen(ctx context.Context) int {
    return x.MatchExpressionsList(ctx).Len()
}

// MatchExpressionsGet returns the item at the given index.
func (x LabelSelector) MatchExpressionsGet(ctx context.Context, index int) LabelSelectorRequirement {
    s := x.MatchExpressionsList(ctx).Get(index)
    return LabelSelectorRequirement{s: s}
}

// MatchExpressionsAppend appends items to the list.
func (x LabelSelector) MatchExpressionsAppend(ctx context.Context, values ...LabelSelectorRequirement) {
    list := x.MatchExpressionsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// MatchExpressionsAppendRaw appends items to the list using Raw struct representations.
func (x LabelSelector) MatchExpressionsAppendRaw(ctx context.Context, values ...*LabelSelectorRequirementRaw) {
    list := x.MatchExpressionsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewLabelSelectorRequirementFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x LabelSelector) IsSetMatchExpressions() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x LabelSelector) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x LabelSelector) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x LabelSelector) XXXTypeHash() [16]byte {
    return XXXTypeHashLabelSelector
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x LabelSelector) SetRecording(enabled bool) LabelSelector {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x LabelSelector) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x LabelSelector) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x LabelSelector) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// LabelSelectorRaw is a plain Go struct representation of LabelSelector.
// Zero values are not set (sparse encoding).
type LabelSelectorRaw struct {
    MatchLabels []*KeyValueRaw
    MatchExpressions []*LabelSelectorRequirementRaw
}

// NewLabelSelectorFromRaw creates a new LabelSelector from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewLabelSelectorFromRaw(ctx context.Context, raw LabelSelectorRaw) LabelSelector {
    x := NewLabelSelector(ctx)
    if raw.MatchLabels != nil {
        list := x.MatchLabelsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.MatchLabels))
        for _, r := range raw.MatchLabels {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.MatchExpressions != nil {
        list := x.MatchExpressionsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.MatchExpressions))
        for _, r := range raw.MatchExpressions {
            if r != nil {
                items = append(items, NewLabelSelectorRequirementFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x LabelSelector) ToRaw(ctx context.Context) LabelSelectorRaw {
    raw := LabelSelectorRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.MatchLabels = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.MatchLabels[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.MatchLabelsList(ctx)
        raw.MatchLabels = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.MatchLabels[i] = &itemRaw
        }
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.MatchExpressions = make([]*LabelSelectorRequirementRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := LabelSelectorRequirement{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.MatchExpressions[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.MatchExpressionsList(ctx)
        raw.MatchExpressions = make([]*LabelSelectorRequirementRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := LabelSelectorRequirement{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.MatchExpressions[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x LabelSelector) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(38)
}

// LabelSelectorRequirement is a selector that contains values and an operator.
type LabelSelectorRequirement struct {
   s *segment.Struct
}

// NewLabelSelectorRequirement creates a new pooled instance of LabelSelectorRequirement.
// Call Release() when done to return it to the pool for reuse.
func NewLabelSelectorRequirement(ctx context.Context) LabelSelectorRequirement {
    s := segment.New(ctx, XXXMappingLabelSelectorRequirement)
    s.SetIsSetEnabled(true)
    return LabelSelectorRequirement{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x LabelSelectorRequirement) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewLabelSelectorRequirementFrom creates a new LabelSelectorRequirement from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewLabelSelectorRequirementFrom(s *segment.Struct) LabelSelectorRequirement {
    return LabelSelectorRequirement{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x LabelSelectorRequirement) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x LabelSelectorRequirement) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x LabelSelectorRequirement) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x LabelSelectorRequirement) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x LabelSelectorRequirement) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x LabelSelectorRequirement) Key() string {
    return segment.GetString(x.s, 0)
}

func (x LabelSelectorRequirement) SetKey(value string) LabelSelectorRequirement {
    segment.SetString(x.s, 0, value)
    return x
}
func (x LabelSelectorRequirement) IsSetKey() bool{
    return x.s.HasField(0)
}

func (x LabelSelectorRequirement) Operator() LabelSelectorOperator {
    return LabelSelectorOperator(segment.GetUint8(x.s, 1))
}

func (x LabelSelectorRequirement) SetOperator(value LabelSelectorOperator) LabelSelectorRequirement {
    segment.SetUint8(x.s, 1, uint8(value))
    return x
}
func (x LabelSelectorRequirement) IsSetOperator() bool{
    return x.s.HasField(1)
}

func (x LabelSelectorRequirement) Values() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 2); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 2)
    return strs
}

// SetValues replaces all values in the string list.
func (x LabelSelectorRequirement) SetValues(v ...string) LabelSelectorRequirement {
    strs := x.Values()
    strs.SetAll(v)
    return x
}
func (x LabelSelectorRequirement) IsSetValues() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x LabelSelectorRequirement) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x LabelSelectorRequirement) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x LabelSelectorRequirement) XXXTypeHash() [16]byte {
    return XXXTypeHashLabelSelectorRequirement
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x LabelSelectorRequirement) SetRecording(enabled bool) LabelSelectorRequirement {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x LabelSelectorRequirement) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x LabelSelectorRequirement) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x LabelSelectorRequirement) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// LabelSelectorRequirementRaw is a plain Go struct representation of LabelSelectorRequirement.
// Zero values are not set (sparse encoding).
type LabelSelectorRequirementRaw struct {
    Key string
    Operator LabelSelectorOperator
    Values []string
}

// NewLabelSelectorRequirementFromRaw creates a new LabelSelectorRequirement from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewLabelSelectorRequirementFromRaw(ctx context.Context, raw LabelSelectorRequirementRaw) LabelSelectorRequirement {
    x := NewLabelSelectorRequirement(ctx)
    if raw.Key != "" {
        x.SetKey(raw.Key)
    }
    if raw.Operator != 0 {
        x.SetOperator(raw.Operator)
    }
    if raw.Values != nil {
        x.SetValues(raw.Values...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x LabelSelectorRequirement) ToRaw(ctx context.Context) LabelSelectorRequirementRaw {
    raw := LabelSelectorRequirementRaw{}
    raw.Key = x.Key()
    raw.Operator = x.Operator()
    if l := x.s.GetList(2); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Values = l.(*segment.Strings).Slice()
    } else if x.s.HasField(2) {
        raw.Values = x.Values().Slice()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x LabelSelectorRequirement) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(39)
}

// Lifecycle describes actions that the management system should take.
type Lifecycle struct {
   s *segment.Struct
}

// NewLifecycle creates a new pooled instance of Lifecycle.
// Call Release() when done to return it to the pool for reuse.
func NewLifecycle(ctx context.Context) Lifecycle {
    s := segment.New(ctx, XXXMappingLifecycle)
    s.SetIsSetEnabled(true)
    return Lifecycle{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Lifecycle) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewLifecycleFrom creates a new Lifecycle from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewLifecycleFrom(s *segment.Struct) Lifecycle {
    return Lifecycle{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Lifecycle) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Lifecycle) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Lifecycle) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Lifecycle) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Lifecycle) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Lifecycle) PostStart() LifecycleHandler {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingLifecycleHandler)
    return LifecycleHandler{s: s}
}

func (x Lifecycle) SetPostStart(value LifecycleHandler) Lifecycle {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x Lifecycle) IsSetPostStart() bool{
    return x.s.HasField(0)
}

func (x Lifecycle) PreStop() LifecycleHandler {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingLifecycleHandler)
    return LifecycleHandler{s: s}
}

func (x Lifecycle) SetPreStop(value LifecycleHandler) Lifecycle {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x Lifecycle) IsSetPreStop() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Lifecycle) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Lifecycle) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Lifecycle) XXXTypeHash() [16]byte {
    return XXXTypeHashLifecycle
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Lifecycle) SetRecording(enabled bool) Lifecycle {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Lifecycle) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Lifecycle) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Lifecycle) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// LifecycleRaw is a plain Go struct representation of Lifecycle.
// Zero values are not set (sparse encoding).
type LifecycleRaw struct {
    PostStart *LifecycleHandlerRaw
    PreStop *LifecycleHandlerRaw
}

// NewLifecycleFromRaw creates a new Lifecycle from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewLifecycleFromRaw(ctx context.Context, raw LifecycleRaw) Lifecycle {
    x := NewLifecycle(ctx)
    if raw.PostStart != nil {
        x.SetPostStart(NewLifecycleHandlerFromRaw(ctx, *raw.PostStart))
    }
    if raw.PreStop != nil {
        x.SetPreStop(NewLifecycleHandlerFromRaw(ctx, *raw.PreStop))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Lifecycle) ToRaw(ctx context.Context) LifecycleRaw {
    raw := LifecycleRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.PostStart().ToRaw(ctx)
        raw.PostStart = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.PreStop().ToRaw(ctx)
        raw.PreStop = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Lifecycle) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(40)
}

// LifecycleHandler defines a specific action that should be taken.
type LifecycleHandler struct {
   s *segment.Struct
}

// NewLifecycleHandler creates a new pooled instance of LifecycleHandler.
// Call Release() when done to return it to the pool for reuse.
func NewLifecycleHandler(ctx context.Context) LifecycleHandler {
    s := segment.New(ctx, XXXMappingLifecycleHandler)
    s.SetIsSetEnabled(true)
    return LifecycleHandler{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x LifecycleHandler) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewLifecycleHandlerFrom creates a new LifecycleHandler from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewLifecycleHandlerFrom(s *segment.Struct) LifecycleHandler {
    return LifecycleHandler{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x LifecycleHandler) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x LifecycleHandler) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x LifecycleHandler) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x LifecycleHandler) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x LifecycleHandler) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x LifecycleHandler) Exec() ExecAction {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingExecAction)
    return ExecAction{s: s}
}

func (x LifecycleHandler) SetExec(value ExecAction) LifecycleHandler {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x LifecycleHandler) IsSetExec() bool{
    return x.s.HasField(0)
}

func (x LifecycleHandler) HttpGet() HTTPGetAction {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingHTTPGetAction)
    return HTTPGetAction{s: s}
}

func (x LifecycleHandler) SetHttpGet(value HTTPGetAction) LifecycleHandler {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x LifecycleHandler) IsSetHttpGet() bool{
    return x.s.HasField(1)
}

func (x LifecycleHandler) TcpSocket() TCPSocketAction {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingTCPSocketAction)
    return TCPSocketAction{s: s}
}

func (x LifecycleHandler) SetTcpSocket(value TCPSocketAction) LifecycleHandler {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x LifecycleHandler) IsSetTcpSocket() bool{
    return x.s.HasField(2)
}

func (x LifecycleHandler) Sleep() SleepAction {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingSleepAction)
    return SleepAction{s: s}
}

func (x LifecycleHandler) SetSleep(value SleepAction) LifecycleHandler {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x LifecycleHandler) IsSetSleep() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x LifecycleHandler) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x LifecycleHandler) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x LifecycleHandler) XXXTypeHash() [16]byte {
    return XXXTypeHashLifecycleHandler
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x LifecycleHandler) SetRecording(enabled bool) LifecycleHandler {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x LifecycleHandler) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x LifecycleHandler) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x LifecycleHandler) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// LifecycleHandlerRaw is a plain Go struct representation of LifecycleHandler.
// Zero values are not set (sparse encoding).
type LifecycleHandlerRaw struct {
    Exec *ExecActionRaw
    HttpGet *HTTPGetActionRaw
    TcpSocket *TCPSocketActionRaw
    Sleep *SleepActionRaw
}

// NewLifecycleHandlerFromRaw creates a new LifecycleHandler from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewLifecycleHandlerFromRaw(ctx context.Context, raw LifecycleHandlerRaw) LifecycleHandler {
    x := NewLifecycleHandler(ctx)
    if raw.Exec != nil {
        x.SetExec(NewExecActionFromRaw(ctx, *raw.Exec))
    }
    if raw.HttpGet != nil {
        x.SetHttpGet(NewHTTPGetActionFromRaw(ctx, *raw.HttpGet))
    }
    if raw.TcpSocket != nil {
        x.SetTcpSocket(NewTCPSocketActionFromRaw(ctx, *raw.TcpSocket))
    }
    if raw.Sleep != nil {
        x.SetSleep(NewSleepActionFromRaw(ctx, *raw.Sleep))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x LifecycleHandler) ToRaw(ctx context.Context) LifecycleHandlerRaw {
    raw := LifecycleHandlerRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.Exec().ToRaw(ctx)
        raw.Exec = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.HttpGet().ToRaw(ctx)
        raw.HttpGet = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.TcpSocket().ToRaw(ctx)
        raw.TcpSocket = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.Sleep().ToRaw(ctx)
        raw.Sleep = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x LifecycleHandler) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(41)
}

// LocalObjectReference contains enough information to locate the referenced object.
type LocalObjectReference struct {
   s *segment.Struct
}

// NewLocalObjectReference creates a new pooled instance of LocalObjectReference.
// Call Release() when done to return it to the pool for reuse.
func NewLocalObjectReference(ctx context.Context) LocalObjectReference {
    s := segment.New(ctx, XXXMappingLocalObjectReference)
    s.SetIsSetEnabled(true)
    return LocalObjectReference{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x LocalObjectReference) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewLocalObjectReferenceFrom creates a new LocalObjectReference from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewLocalObjectReferenceFrom(s *segment.Struct) LocalObjectReference {
    return LocalObjectReference{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x LocalObjectReference) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x LocalObjectReference) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x LocalObjectReference) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x LocalObjectReference) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x LocalObjectReference) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x LocalObjectReference) Name() string {
    return segment.GetString(x.s, 0)
}

func (x LocalObjectReference) SetName(value string) LocalObjectReference {
    segment.SetString(x.s, 0, value)
    return x
}
func (x LocalObjectReference) IsSetName() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x LocalObjectReference) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x LocalObjectReference) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x LocalObjectReference) XXXTypeHash() [16]byte {
    return XXXTypeHashLocalObjectReference
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x LocalObjectReference) SetRecording(enabled bool) LocalObjectReference {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x LocalObjectReference) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x LocalObjectReference) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x LocalObjectReference) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// LocalObjectReferenceRaw is a plain Go struct representation of LocalObjectReference.
// Zero values are not set (sparse encoding).
type LocalObjectReferenceRaw struct {
    Name string
}

// NewLocalObjectReferenceFromRaw creates a new LocalObjectReference from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewLocalObjectReferenceFromRaw(ctx context.Context, raw LocalObjectReferenceRaw) LocalObjectReference {
    x := NewLocalObjectReference(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x LocalObjectReference) ToRaw(ctx context.Context) LocalObjectReferenceRaw {
    raw := LocalObjectReferenceRaw{}
    raw.Name = x.Name()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x LocalObjectReference) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(42)
}

// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource.
type ManagedFieldsEntry struct {
   s *segment.Struct
}

// NewManagedFieldsEntry creates a new pooled instance of ManagedFieldsEntry.
// Call Release() when done to return it to the pool for reuse.
func NewManagedFieldsEntry(ctx context.Context) ManagedFieldsEntry {
    s := segment.New(ctx, XXXMappingManagedFieldsEntry)
    s.SetIsSetEnabled(true)
    return ManagedFieldsEntry{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ManagedFieldsEntry) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewManagedFieldsEntryFrom creates a new ManagedFieldsEntry from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewManagedFieldsEntryFrom(s *segment.Struct) ManagedFieldsEntry {
    return ManagedFieldsEntry{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ManagedFieldsEntry) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ManagedFieldsEntry) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ManagedFieldsEntry) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ManagedFieldsEntry) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ManagedFieldsEntry) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ManagedFieldsEntry) Manager() string {
    return segment.GetString(x.s, 0)
}

func (x ManagedFieldsEntry) SetManager(value string) ManagedFieldsEntry {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ManagedFieldsEntry) IsSetManager() bool{
    return x.s.HasField(0)
}

func (x ManagedFieldsEntry) Operation() string {
    return segment.GetString(x.s, 1)
}

func (x ManagedFieldsEntry) SetOperation(value string) ManagedFieldsEntry {
    segment.SetString(x.s, 1, value)
    return x
}
func (x ManagedFieldsEntry) IsSetOperation() bool{
    return x.s.HasField(1)
}

func (x ManagedFieldsEntry) ApiVersion() string {
    return segment.GetString(x.s, 2)
}

func (x ManagedFieldsEntry) SetApiVersion(value string) ManagedFieldsEntry {
    segment.SetString(x.s, 2, value)
    return x
}
func (x ManagedFieldsEntry) IsSetApiVersion() bool{
    return x.s.HasField(2)
}

func (x ManagedFieldsEntry) Time() Time {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingTime)
    return Time{s: s}
}

func (x ManagedFieldsEntry) SetTime(value Time) ManagedFieldsEntry {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x ManagedFieldsEntry) IsSetTime() bool{
    return x.s.HasField(3)
}

func (x ManagedFieldsEntry) FieldsType() string {
    return segment.GetString(x.s, 4)
}

func (x ManagedFieldsEntry) SetFieldsType(value string) ManagedFieldsEntry {
    segment.SetString(x.s, 4, value)
    return x
}
func (x ManagedFieldsEntry) IsSetFieldsType() bool{
    return x.s.HasField(4)
}

func (x ManagedFieldsEntry) FieldsV1() string {
    return segment.GetString(x.s, 5)
}

func (x ManagedFieldsEntry) SetFieldsV1(value string) ManagedFieldsEntry {
    segment.SetString(x.s, 5, value)
    return x
}
func (x ManagedFieldsEntry) IsSetFieldsV1() bool{
    return x.s.HasField(5)
}

func (x ManagedFieldsEntry) Subresource() string {
    return segment.GetString(x.s, 6)
}

func (x ManagedFieldsEntry) SetSubresource(value string) ManagedFieldsEntry {
    segment.SetString(x.s, 6, value)
    return x
}
func (x ManagedFieldsEntry) IsSetSubresource() bool{
    return x.s.HasField(6)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ManagedFieldsEntry) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ManagedFieldsEntry) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ManagedFieldsEntry) XXXTypeHash() [16]byte {
    return XXXTypeHashManagedFieldsEntry
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ManagedFieldsEntry) SetRecording(enabled bool) ManagedFieldsEntry {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ManagedFieldsEntry) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ManagedFieldsEntry) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ManagedFieldsEntry) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ManagedFieldsEntryRaw is a plain Go struct representation of ManagedFieldsEntry.
// Zero values are not set (sparse encoding).
type ManagedFieldsEntryRaw struct {
    Manager string
    Operation string
    ApiVersion string
    Time *TimeRaw
    FieldsType string
    FieldsV1 string
    Subresource string
}

// NewManagedFieldsEntryFromRaw creates a new ManagedFieldsEntry from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewManagedFieldsEntryFromRaw(ctx context.Context, raw ManagedFieldsEntryRaw) ManagedFieldsEntry {
    x := NewManagedFieldsEntry(ctx)
    if raw.Manager != "" {
        x.SetManager(raw.Manager)
    }
    if raw.Operation != "" {
        x.SetOperation(raw.Operation)
    }
    if raw.ApiVersion != "" {
        x.SetApiVersion(raw.ApiVersion)
    }
    if raw.Time != nil {
        x.SetTime(NewTimeFromRaw(ctx, *raw.Time))
    }
    if raw.FieldsType != "" {
        x.SetFieldsType(raw.FieldsType)
    }
    if raw.FieldsV1 != "" {
        x.SetFieldsV1(raw.FieldsV1)
    }
    if raw.Subresource != "" {
        x.SetSubresource(raw.Subresource)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ManagedFieldsEntry) ToRaw(ctx context.Context) ManagedFieldsEntryRaw {
    raw := ManagedFieldsEntryRaw{}
    raw.Manager = x.Manager()
    raw.Operation = x.Operation()
    raw.ApiVersion = x.ApiVersion()
    if x.s.HasField(3) {
        nestedRaw := x.Time().ToRaw(ctx)
        raw.Time = &nestedRaw
    }
    raw.FieldsType = x.FieldsType()
    raw.FieldsV1 = x.FieldsV1()
    raw.Subresource = x.Subresource()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ManagedFieldsEntry) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(43)
}

// NFSVolumeSource represents an NFS mount that lasts the lifetime of a pod.
type NFSVolumeSource struct {
   s *segment.Struct
}

// NewNFSVolumeSource creates a new pooled instance of NFSVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewNFSVolumeSource(ctx context.Context) NFSVolumeSource {
    s := segment.New(ctx, XXXMappingNFSVolumeSource)
    s.SetIsSetEnabled(true)
    return NFSVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x NFSVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewNFSVolumeSourceFrom creates a new NFSVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewNFSVolumeSourceFrom(s *segment.Struct) NFSVolumeSource {
    return NFSVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x NFSVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x NFSVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x NFSVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x NFSVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x NFSVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x NFSVolumeSource) Server() string {
    return segment.GetString(x.s, 0)
}

func (x NFSVolumeSource) SetServer(value string) NFSVolumeSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x NFSVolumeSource) IsSetServer() bool{
    return x.s.HasField(0)
}

func (x NFSVolumeSource) Path() string {
    return segment.GetString(x.s, 1)
}

func (x NFSVolumeSource) SetPath(value string) NFSVolumeSource {
    segment.SetString(x.s, 1, value)
    return x
}
func (x NFSVolumeSource) IsSetPath() bool{
    return x.s.HasField(1)
}

func (x NFSVolumeSource) ReadOnly() bool {
    return segment.GetBool(x.s, 2)
}

func (x NFSVolumeSource) SetReadOnly(value bool) NFSVolumeSource {
    segment.SetBool(x.s, 2, value)
    return x
}
func (x NFSVolumeSource) IsSetReadOnly() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x NFSVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x NFSVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x NFSVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashNFSVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x NFSVolumeSource) SetRecording(enabled bool) NFSVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x NFSVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x NFSVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x NFSVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// NFSVolumeSourceRaw is a plain Go struct representation of NFSVolumeSource.
// Zero values are not set (sparse encoding).
type NFSVolumeSourceRaw struct {
    Server string
    Path string
    ReadOnly bool
}

// NewNFSVolumeSourceFromRaw creates a new NFSVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewNFSVolumeSourceFromRaw(ctx context.Context, raw NFSVolumeSourceRaw) NFSVolumeSource {
    x := NewNFSVolumeSource(ctx)
    if raw.Server != "" {
        x.SetServer(raw.Server)
    }
    if raw.Path != "" {
        x.SetPath(raw.Path)
    }
    if raw.ReadOnly {
        x.SetReadOnly(raw.ReadOnly)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x NFSVolumeSource) ToRaw(ctx context.Context) NFSVolumeSourceRaw {
    raw := NFSVolumeSourceRaw{}
    raw.Server = x.Server()
    raw.Path = x.Path()
    raw.ReadOnly = x.ReadOnly()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x NFSVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(44)
}

// NodeAffinity is a group of node affinity scheduling rules.
type NodeAffinity struct {
   s *segment.Struct
}

// NewNodeAffinity creates a new pooled instance of NodeAffinity.
// Call Release() when done to return it to the pool for reuse.
func NewNodeAffinity(ctx context.Context) NodeAffinity {
    s := segment.New(ctx, XXXMappingNodeAffinity)
    s.SetIsSetEnabled(true)
    return NodeAffinity{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x NodeAffinity) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewNodeAffinityFrom creates a new NodeAffinity from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewNodeAffinityFrom(s *segment.Struct) NodeAffinity {
    return NodeAffinity{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x NodeAffinity) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x NodeAffinity) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x NodeAffinity) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x NodeAffinity) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x NodeAffinity) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x NodeAffinity) RequiredDuringSchedulingIgnoredDuringExecution() NodeSelector {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingNodeSelector)
    return NodeSelector{s: s}
}

func (x NodeAffinity) SetRequiredDuringSchedulingIgnoredDuringExecution(value NodeSelector) NodeAffinity {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x NodeAffinity) IsSetRequiredDuringSchedulingIgnoredDuringExecution() bool{
    return x.s.HasField(0)
}

// PreferredDuringSchedulingIgnoredDuringExecutionList returns the underlying Structs list for iteration.
// Use NewPreferredSchedulingTerm() to create items and Append to add them.
func (x NodeAffinity) PreferredDuringSchedulingIgnoredDuringExecutionList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingPreferredSchedulingTerm); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingPreferredSchedulingTerm)
    return structs
}

// PreferredDuringSchedulingIgnoredDuringExecutionLen returns the number of items in the list.
func (x NodeAffinity) PreferredDuringSchedulingIgnoredDuringExecutionLen(ctx context.Context) int {
    return x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx).Len()
}

// PreferredDuringSchedulingIgnoredDuringExecutionGet returns the item at the given index.
func (x NodeAffinity) PreferredDuringSchedulingIgnoredDuringExecutionGet(ctx context.Context, index int) PreferredSchedulingTerm {
    s := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx).Get(index)
    return PreferredSchedulingTerm{s: s}
}

// PreferredDuringSchedulingIgnoredDuringExecutionAppend appends items to the list.
func (x NodeAffinity) PreferredDuringSchedulingIgnoredDuringExecutionAppend(ctx context.Context, values ...PreferredSchedulingTerm) {
    list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// PreferredDuringSchedulingIgnoredDuringExecutionAppendRaw appends items to the list using Raw struct representations.
func (x NodeAffinity) PreferredDuringSchedulingIgnoredDuringExecutionAppendRaw(ctx context.Context, values ...*PreferredSchedulingTermRaw) {
    list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPreferredSchedulingTermFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x NodeAffinity) IsSetPreferredDuringSchedulingIgnoredDuringExecution() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x NodeAffinity) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x NodeAffinity) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x NodeAffinity) XXXTypeHash() [16]byte {
    return XXXTypeHashNodeAffinity
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x NodeAffinity) SetRecording(enabled bool) NodeAffinity {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x NodeAffinity) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x NodeAffinity) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x NodeAffinity) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// NodeAffinityRaw is a plain Go struct representation of NodeAffinity.
// Zero values are not set (sparse encoding).
type NodeAffinityRaw struct {
    RequiredDuringSchedulingIgnoredDuringExecution *NodeSelectorRaw
    PreferredDuringSchedulingIgnoredDuringExecution []*PreferredSchedulingTermRaw
}

// NewNodeAffinityFromRaw creates a new NodeAffinity from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewNodeAffinityFromRaw(ctx context.Context, raw NodeAffinityRaw) NodeAffinity {
    x := NewNodeAffinity(ctx)
    if raw.RequiredDuringSchedulingIgnoredDuringExecution != nil {
        x.SetRequiredDuringSchedulingIgnoredDuringExecution(NewNodeSelectorFromRaw(ctx, *raw.RequiredDuringSchedulingIgnoredDuringExecution))
    }
    if raw.PreferredDuringSchedulingIgnoredDuringExecution != nil {
        list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
        items := make([]*segment.Struct, 0, len(raw.PreferredDuringSchedulingIgnoredDuringExecution))
        for _, r := range raw.PreferredDuringSchedulingIgnoredDuringExecution {
            if r != nil {
                items = append(items, NewPreferredSchedulingTermFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x NodeAffinity) ToRaw(ctx context.Context) NodeAffinityRaw {
    raw := NodeAffinityRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.RequiredDuringSchedulingIgnoredDuringExecution().ToRaw(ctx)
        raw.RequiredDuringSchedulingIgnoredDuringExecution = &nestedRaw
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.PreferredDuringSchedulingIgnoredDuringExecution = make([]*PreferredSchedulingTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PreferredSchedulingTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.PreferredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
        raw.PreferredDuringSchedulingIgnoredDuringExecution = make([]*PreferredSchedulingTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PreferredSchedulingTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.PreferredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x NodeAffinity) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(45)
}

// NodeSelector represents the union of the results of one or more label queries.
type NodeSelector struct {
   s *segment.Struct
}

// NewNodeSelector creates a new pooled instance of NodeSelector.
// Call Release() when done to return it to the pool for reuse.
func NewNodeSelector(ctx context.Context) NodeSelector {
    s := segment.New(ctx, XXXMappingNodeSelector)
    s.SetIsSetEnabled(true)
    return NodeSelector{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x NodeSelector) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewNodeSelectorFrom creates a new NodeSelector from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewNodeSelectorFrom(s *segment.Struct) NodeSelector {
    return NodeSelector{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x NodeSelector) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x NodeSelector) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x NodeSelector) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x NodeSelector) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x NodeSelector) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// NodeSelectorTermsList returns the underlying Structs list for iteration.
// Use NewNodeSelectorTerm() to create items and Append to add them.
func (x NodeSelector) NodeSelectorTermsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingNodeSelectorTerm); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingNodeSelectorTerm)
    return structs
}

// NodeSelectorTermsLen returns the number of items in the list.
func (x NodeSelector) NodeSelectorTermsLen(ctx context.Context) int {
    return x.NodeSelectorTermsList(ctx).Len()
}

// NodeSelectorTermsGet returns the item at the given index.
func (x NodeSelector) NodeSelectorTermsGet(ctx context.Context, index int) NodeSelectorTerm {
    s := x.NodeSelectorTermsList(ctx).Get(index)
    return NodeSelectorTerm{s: s}
}

// NodeSelectorTermsAppend appends items to the list.
func (x NodeSelector) NodeSelectorTermsAppend(ctx context.Context, values ...NodeSelectorTerm) {
    list := x.NodeSelectorTermsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// NodeSelectorTermsAppendRaw appends items to the list using Raw struct representations.
func (x NodeSelector) NodeSelectorTermsAppendRaw(ctx context.Context, values ...*NodeSelectorTermRaw) {
    list := x.NodeSelectorTermsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewNodeSelectorTermFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x NodeSelector) IsSetNodeSelectorTerms() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x NodeSelector) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x NodeSelector) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x NodeSelector) XXXTypeHash() [16]byte {
    return XXXTypeHashNodeSelector
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x NodeSelector) SetRecording(enabled bool) NodeSelector {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x NodeSelector) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x NodeSelector) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x NodeSelector) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// NodeSelectorRaw is a plain Go struct representation of NodeSelector.
// Zero values are not set (sparse encoding).
type NodeSelectorRaw struct {
    NodeSelectorTerms []*NodeSelectorTermRaw
}

// NewNodeSelectorFromRaw creates a new NodeSelector from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewNodeSelectorFromRaw(ctx context.Context, raw NodeSelectorRaw) NodeSelector {
    x := NewNodeSelector(ctx)
    if raw.NodeSelectorTerms != nil {
        list := x.NodeSelectorTermsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.NodeSelectorTerms))
        for _, r := range raw.NodeSelectorTerms {
            if r != nil {
                items = append(items, NewNodeSelectorTermFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x NodeSelector) ToRaw(ctx context.Context) NodeSelectorRaw {
    raw := NodeSelectorRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.NodeSelectorTerms = make([]*NodeSelectorTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := NodeSelectorTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.NodeSelectorTerms[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.NodeSelectorTermsList(ctx)
        raw.NodeSelectorTerms = make([]*NodeSelectorTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := NodeSelectorTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.NodeSelectorTerms[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x NodeSelector) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(46)
}

// NodeSelectorRequirement is a selector that contains values and an operator.
type NodeSelectorRequirement struct {
   s *segment.Struct
}

// NewNodeSelectorRequirement creates a new pooled instance of NodeSelectorRequirement.
// Call Release() when done to return it to the pool for reuse.
func NewNodeSelectorRequirement(ctx context.Context) NodeSelectorRequirement {
    s := segment.New(ctx, XXXMappingNodeSelectorRequirement)
    s.SetIsSetEnabled(true)
    return NodeSelectorRequirement{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x NodeSelectorRequirement) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewNodeSelectorRequirementFrom creates a new NodeSelectorRequirement from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewNodeSelectorRequirementFrom(s *segment.Struct) NodeSelectorRequirement {
    return NodeSelectorRequirement{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x NodeSelectorRequirement) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x NodeSelectorRequirement) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x NodeSelectorRequirement) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x NodeSelectorRequirement) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x NodeSelectorRequirement) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x NodeSelectorRequirement) Key() string {
    return segment.GetString(x.s, 0)
}

func (x NodeSelectorRequirement) SetKey(value string) NodeSelectorRequirement {
    segment.SetString(x.s, 0, value)
    return x
}
func (x NodeSelectorRequirement) IsSetKey() bool{
    return x.s.HasField(0)
}

func (x NodeSelectorRequirement) Operator() NodeSelectorOperator {
    return NodeSelectorOperator(segment.GetUint8(x.s, 1))
}

func (x NodeSelectorRequirement) SetOperator(value NodeSelectorOperator) NodeSelectorRequirement {
    segment.SetUint8(x.s, 1, uint8(value))
    return x
}
func (x NodeSelectorRequirement) IsSetOperator() bool{
    return x.s.HasField(1)
}

func (x NodeSelectorRequirement) Values() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 2); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 2)
    return strs
}

// SetValues replaces all values in the string list.
func (x NodeSelectorRequirement) SetValues(v ...string) NodeSelectorRequirement {
    strs := x.Values()
    strs.SetAll(v)
    return x
}
func (x NodeSelectorRequirement) IsSetValues() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x NodeSelectorRequirement) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x NodeSelectorRequirement) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x NodeSelectorRequirement) XXXTypeHash() [16]byte {
    return XXXTypeHashNodeSelectorRequirement
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x NodeSelectorRequirement) SetRecording(enabled bool) NodeSelectorRequirement {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x NodeSelectorRequirement) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x NodeSelectorRequirement) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x NodeSelectorRequirement) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// NodeSelectorRequirementRaw is a plain Go struct representation of NodeSelectorRequirement.
// Zero values are not set (sparse encoding).
type NodeSelectorRequirementRaw struct {
    Key string
    Operator NodeSelectorOperator
    Values []string
}

// NewNodeSelectorRequirementFromRaw creates a new NodeSelectorRequirement from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewNodeSelectorRequirementFromRaw(ctx context.Context, raw NodeSelectorRequirementRaw) NodeSelectorRequirement {
    x := NewNodeSelectorRequirement(ctx)
    if raw.Key != "" {
        x.SetKey(raw.Key)
    }
    if raw.Operator != 0 {
        x.SetOperator(raw.Operator)
    }
    if raw.Values != nil {
        x.SetValues(raw.Values...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x NodeSelectorRequirement) ToRaw(ctx context.Context) NodeSelectorRequirementRaw {
    raw := NodeSelectorRequirementRaw{}
    raw.Key = x.Key()
    raw.Operator = x.Operator()
    if l := x.s.GetList(2); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Values = l.(*segment.Strings).Slice()
    } else if x.s.HasField(2) {
        raw.Values = x.Values().Slice()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x NodeSelectorRequirement) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(47)
}

// NodeSelectorTerm represents expressions and fields required to select node(s).
type NodeSelectorTerm struct {
   s *segment.Struct
}

// NewNodeSelectorTerm creates a new pooled instance of NodeSelectorTerm.
// Call Release() when done to return it to the pool for reuse.
func NewNodeSelectorTerm(ctx context.Context) NodeSelectorTerm {
    s := segment.New(ctx, XXXMappingNodeSelectorTerm)
    s.SetIsSetEnabled(true)
    return NodeSelectorTerm{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x NodeSelectorTerm) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewNodeSelectorTermFrom creates a new NodeSelectorTerm from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewNodeSelectorTermFrom(s *segment.Struct) NodeSelectorTerm {
    return NodeSelectorTerm{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x NodeSelectorTerm) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x NodeSelectorTerm) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x NodeSelectorTerm) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x NodeSelectorTerm) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x NodeSelectorTerm) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// MatchExpressionsList returns the underlying Structs list for iteration.
// Use NewNodeSelectorRequirement() to create items and Append to add them.
func (x NodeSelectorTerm) MatchExpressionsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingNodeSelectorRequirement); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingNodeSelectorRequirement)
    return structs
}

// MatchExpressionsLen returns the number of items in the list.
func (x NodeSelectorTerm) MatchExpressionsLen(ctx context.Context) int {
    return x.MatchExpressionsList(ctx).Len()
}

// MatchExpressionsGet returns the item at the given index.
func (x NodeSelectorTerm) MatchExpressionsGet(ctx context.Context, index int) NodeSelectorRequirement {
    s := x.MatchExpressionsList(ctx).Get(index)
    return NodeSelectorRequirement{s: s}
}

// MatchExpressionsAppend appends items to the list.
func (x NodeSelectorTerm) MatchExpressionsAppend(ctx context.Context, values ...NodeSelectorRequirement) {
    list := x.MatchExpressionsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// MatchExpressionsAppendRaw appends items to the list using Raw struct representations.
func (x NodeSelectorTerm) MatchExpressionsAppendRaw(ctx context.Context, values ...*NodeSelectorRequirementRaw) {
    list := x.MatchExpressionsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewNodeSelectorRequirementFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x NodeSelectorTerm) IsSetMatchExpressions() bool{
    return x.s.HasField(0)
}

// MatchFieldsList returns the underlying Structs list for iteration.
// Use NewNodeSelectorRequirement() to create items and Append to add them.
func (x NodeSelectorTerm) MatchFieldsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingNodeSelectorRequirement); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingNodeSelectorRequirement)
    return structs
}

// MatchFieldsLen returns the number of items in the list.
func (x NodeSelectorTerm) MatchFieldsLen(ctx context.Context) int {
    return x.MatchFieldsList(ctx).Len()
}

// MatchFieldsGet returns the item at the given index.
func (x NodeSelectorTerm) MatchFieldsGet(ctx context.Context, index int) NodeSelectorRequirement {
    s := x.MatchFieldsList(ctx).Get(index)
    return NodeSelectorRequirement{s: s}
}

// MatchFieldsAppend appends items to the list.
func (x NodeSelectorTerm) MatchFieldsAppend(ctx context.Context, values ...NodeSelectorRequirement) {
    list := x.MatchFieldsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// MatchFieldsAppendRaw appends items to the list using Raw struct representations.
func (x NodeSelectorTerm) MatchFieldsAppendRaw(ctx context.Context, values ...*NodeSelectorRequirementRaw) {
    list := x.MatchFieldsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewNodeSelectorRequirementFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x NodeSelectorTerm) IsSetMatchFields() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x NodeSelectorTerm) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x NodeSelectorTerm) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x NodeSelectorTerm) XXXTypeHash() [16]byte {
    return XXXTypeHashNodeSelectorTerm
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x NodeSelectorTerm) SetRecording(enabled bool) NodeSelectorTerm {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x NodeSelectorTerm) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x NodeSelectorTerm) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x NodeSelectorTerm) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// NodeSelectorTermRaw is a plain Go struct representation of NodeSelectorTerm.
// Zero values are not set (sparse encoding).
type NodeSelectorTermRaw struct {
    MatchExpressions []*NodeSelectorRequirementRaw
    MatchFields []*NodeSelectorRequirementRaw
}

// NewNodeSelectorTermFromRaw creates a new NodeSelectorTerm from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewNodeSelectorTermFromRaw(ctx context.Context, raw NodeSelectorTermRaw) NodeSelectorTerm {
    x := NewNodeSelectorTerm(ctx)
    if raw.MatchExpressions != nil {
        list := x.MatchExpressionsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.MatchExpressions))
        for _, r := range raw.MatchExpressions {
            if r != nil {
                items = append(items, NewNodeSelectorRequirementFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.MatchFields != nil {
        list := x.MatchFieldsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.MatchFields))
        for _, r := range raw.MatchFields {
            if r != nil {
                items = append(items, NewNodeSelectorRequirementFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x NodeSelectorTerm) ToRaw(ctx context.Context) NodeSelectorTermRaw {
    raw := NodeSelectorTermRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.MatchExpressions = make([]*NodeSelectorRequirementRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := NodeSelectorRequirement{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.MatchExpressions[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.MatchExpressionsList(ctx)
        raw.MatchExpressions = make([]*NodeSelectorRequirementRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := NodeSelectorRequirement{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.MatchExpressions[i] = &itemRaw
        }
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.MatchFields = make([]*NodeSelectorRequirementRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := NodeSelectorRequirement{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.MatchFields[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.MatchFieldsList(ctx)
        raw.MatchFields = make([]*NodeSelectorRequirementRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := NodeSelectorRequirement{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.MatchFields[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x NodeSelectorTerm) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(48)
}

// ObjectFieldSelector selects an APIVersioned field of an object.
type ObjectFieldSelector struct {
   s *segment.Struct
}

// NewObjectFieldSelector creates a new pooled instance of ObjectFieldSelector.
// Call Release() when done to return it to the pool for reuse.
func NewObjectFieldSelector(ctx context.Context) ObjectFieldSelector {
    s := segment.New(ctx, XXXMappingObjectFieldSelector)
    s.SetIsSetEnabled(true)
    return ObjectFieldSelector{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ObjectFieldSelector) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewObjectFieldSelectorFrom creates a new ObjectFieldSelector from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewObjectFieldSelectorFrom(s *segment.Struct) ObjectFieldSelector {
    return ObjectFieldSelector{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ObjectFieldSelector) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ObjectFieldSelector) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ObjectFieldSelector) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ObjectFieldSelector) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ObjectFieldSelector) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ObjectFieldSelector) ApiVersion() string {
    return segment.GetString(x.s, 0)
}

func (x ObjectFieldSelector) SetApiVersion(value string) ObjectFieldSelector {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ObjectFieldSelector) IsSetApiVersion() bool{
    return x.s.HasField(0)
}

func (x ObjectFieldSelector) FieldPath() string {
    return segment.GetString(x.s, 1)
}

func (x ObjectFieldSelector) SetFieldPath(value string) ObjectFieldSelector {
    segment.SetString(x.s, 1, value)
    return x
}
func (x ObjectFieldSelector) IsSetFieldPath() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ObjectFieldSelector) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ObjectFieldSelector) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ObjectFieldSelector) XXXTypeHash() [16]byte {
    return XXXTypeHashObjectFieldSelector
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ObjectFieldSelector) SetRecording(enabled bool) ObjectFieldSelector {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ObjectFieldSelector) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ObjectFieldSelector) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ObjectFieldSelector) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ObjectFieldSelectorRaw is a plain Go struct representation of ObjectFieldSelector.
// Zero values are not set (sparse encoding).
type ObjectFieldSelectorRaw struct {
    ApiVersion string
    FieldPath string
}

// NewObjectFieldSelectorFromRaw creates a new ObjectFieldSelector from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewObjectFieldSelectorFromRaw(ctx context.Context, raw ObjectFieldSelectorRaw) ObjectFieldSelector {
    x := NewObjectFieldSelector(ctx)
    if raw.ApiVersion != "" {
        x.SetApiVersion(raw.ApiVersion)
    }
    if raw.FieldPath != "" {
        x.SetFieldPath(raw.FieldPath)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ObjectFieldSelector) ToRaw(ctx context.Context) ObjectFieldSelectorRaw {
    raw := ObjectFieldSelectorRaw{}
    raw.ApiVersion = x.ApiVersion()
    raw.FieldPath = x.FieldPath()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ObjectFieldSelector) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(49)
}

// ObjectMeta is metadata that all persisted resources must have.
type ObjectMeta struct {
   s *segment.Struct
}

// NewObjectMeta creates a new pooled instance of ObjectMeta.
// Call Release() when done to return it to the pool for reuse.
func NewObjectMeta(ctx context.Context) ObjectMeta {
    s := segment.New(ctx, XXXMappingObjectMeta)
    s.SetIsSetEnabled(true)
    return ObjectMeta{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ObjectMeta) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewObjectMetaFrom creates a new ObjectMeta from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewObjectMetaFrom(s *segment.Struct) ObjectMeta {
    return ObjectMeta{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ObjectMeta) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ObjectMeta) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ObjectMeta) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ObjectMeta) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ObjectMeta) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ObjectMeta) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ObjectMeta) SetName(value string) ObjectMeta {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ObjectMeta) IsSetName() bool{
    return x.s.HasField(0)
}

func (x ObjectMeta) GenerateName() string {
    return segment.GetString(x.s, 1)
}

func (x ObjectMeta) SetGenerateName(value string) ObjectMeta {
    segment.SetString(x.s, 1, value)
    return x
}
func (x ObjectMeta) IsSetGenerateName() bool{
    return x.s.HasField(1)
}

func (x ObjectMeta) Namespace() string {
    return segment.GetString(x.s, 2)
}

func (x ObjectMeta) SetNamespace(value string) ObjectMeta {
    segment.SetString(x.s, 2, value)
    return x
}
func (x ObjectMeta) IsSetNamespace() bool{
    return x.s.HasField(2)
}

func (x ObjectMeta) SelfLink() string {
    return segment.GetString(x.s, 3)
}

func (x ObjectMeta) SetSelfLink(value string) ObjectMeta {
    segment.SetString(x.s, 3, value)
    return x
}
func (x ObjectMeta) IsSetSelfLink() bool{
    return x.s.HasField(3)
}

func (x ObjectMeta) Uid() string {
    return segment.GetString(x.s, 4)
}

func (x ObjectMeta) SetUid(value string) ObjectMeta {
    segment.SetString(x.s, 4, value)
    return x
}
func (x ObjectMeta) IsSetUid() bool{
    return x.s.HasField(4)
}

func (x ObjectMeta) ResourceVersion() string {
    return segment.GetString(x.s, 5)
}

func (x ObjectMeta) SetResourceVersion(value string) ObjectMeta {
    segment.SetString(x.s, 5, value)
    return x
}
func (x ObjectMeta) IsSetResourceVersion() bool{
    return x.s.HasField(5)
}

func (x ObjectMeta) Generation() int64 {
    return segment.GetInt64(x.s, 6)
}

func (x ObjectMeta) SetGeneration(value int64) ObjectMeta {
    segment.SetInt64(x.s, 6, value)
    return x
}
func (x ObjectMeta) IsSetGeneration() bool{
    return x.s.HasField(6)
}

func (x ObjectMeta) CreationTimestamp() Time {
    s := segment.GetNestedStruct(x.s, 7, XXXMappingTime)
    return Time{s: s}
}

func (x ObjectMeta) SetCreationTimestamp(value Time) ObjectMeta {
    segment.SetNestedStruct(x.s, 7, value.XXXGetStruct())
    return x
}
func (x ObjectMeta) IsSetCreationTimestamp() bool{
    return x.s.HasField(7)
}

func (x ObjectMeta) DeletionTimestamp() Time {
    s := segment.GetNestedStruct(x.s, 8, XXXMappingTime)
    return Time{s: s}
}

func (x ObjectMeta) SetDeletionTimestamp(value Time) ObjectMeta {
    segment.SetNestedStruct(x.s, 8, value.XXXGetStruct())
    return x
}
func (x ObjectMeta) IsSetDeletionTimestamp() bool{
    return x.s.HasField(8)
}

func (x ObjectMeta) DeletionGracePeriodSeconds() int64 {
    return segment.GetInt64(x.s, 9)
}

func (x ObjectMeta) SetDeletionGracePeriodSeconds(value int64) ObjectMeta {
    segment.SetInt64(x.s, 9, value)
    return x
}
func (x ObjectMeta) IsSetDeletionGracePeriodSeconds() bool{
    return x.s.HasField(9)
}

// LabelsList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x ObjectMeta) LabelsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 10, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 10, XXXMappingKeyValue)
    return structs
}

// LabelsLen returns the number of items in the list.
func (x ObjectMeta) LabelsLen(ctx context.Context) int {
    return x.LabelsList(ctx).Len()
}

// LabelsGet returns the item at the given index.
func (x ObjectMeta) LabelsGet(ctx context.Context, index int) KeyValue {
    s := x.LabelsList(ctx).Get(index)
    return KeyValue{s: s}
}

// LabelsAppend appends items to the list.
func (x ObjectMeta) LabelsAppend(ctx context.Context, values ...KeyValue) {
    list := x.LabelsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// LabelsAppendRaw appends items to the list using Raw struct representations.
func (x ObjectMeta) LabelsAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.LabelsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ObjectMeta) IsSetLabels() bool{
    return x.s.HasField(10)
}

// AnnotationsList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x ObjectMeta) AnnotationsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 11, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 11, XXXMappingKeyValue)
    return structs
}

// AnnotationsLen returns the number of items in the list.
func (x ObjectMeta) AnnotationsLen(ctx context.Context) int {
    return x.AnnotationsList(ctx).Len()
}

// AnnotationsGet returns the item at the given index.
func (x ObjectMeta) AnnotationsGet(ctx context.Context, index int) KeyValue {
    s := x.AnnotationsList(ctx).Get(index)
    return KeyValue{s: s}
}

// AnnotationsAppend appends items to the list.
func (x ObjectMeta) AnnotationsAppend(ctx context.Context, values ...KeyValue) {
    list := x.AnnotationsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// AnnotationsAppendRaw appends items to the list using Raw struct representations.
func (x ObjectMeta) AnnotationsAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.AnnotationsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ObjectMeta) IsSetAnnotations() bool{
    return x.s.HasField(11)
}

// OwnerReferencesList returns the underlying Structs list for iteration.
// Use NewOwnerReference() to create items and Append to add them.
func (x ObjectMeta) OwnerReferencesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 12, XXXMappingOwnerReference); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 12, XXXMappingOwnerReference)
    return structs
}

// OwnerReferencesLen returns the number of items in the list.
func (x ObjectMeta) OwnerReferencesLen(ctx context.Context) int {
    return x.OwnerReferencesList(ctx).Len()
}

// OwnerReferencesGet returns the item at the given index.
func (x ObjectMeta) OwnerReferencesGet(ctx context.Context, index int) OwnerReference {
    s := x.OwnerReferencesList(ctx).Get(index)
    return OwnerReference{s: s}
}

// OwnerReferencesAppend appends items to the list.
func (x ObjectMeta) OwnerReferencesAppend(ctx context.Context, values ...OwnerReference) {
    list := x.OwnerReferencesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// OwnerReferencesAppendRaw appends items to the list using Raw struct representations.
func (x ObjectMeta) OwnerReferencesAppendRaw(ctx context.Context, values ...*OwnerReferenceRaw) {
    list := x.OwnerReferencesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewOwnerReferenceFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ObjectMeta) IsSetOwnerReferences() bool{
    return x.s.HasField(12)
}

func (x ObjectMeta) Finalizers() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 13); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 13)
    return strs
}

// SetFinalizers replaces all values in the string list.
func (x ObjectMeta) SetFinalizers(v ...string) ObjectMeta {
    strs := x.Finalizers()
    strs.SetAll(v)
    return x
}
func (x ObjectMeta) IsSetFinalizers() bool{
    return x.s.HasField(13)
}

// ManagedFieldsList returns the underlying Structs list for iteration.
// Use NewManagedFieldsEntry() to create items and Append to add them.
func (x ObjectMeta) ManagedFieldsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 14, XXXMappingManagedFieldsEntry); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 14, XXXMappingManagedFieldsEntry)
    return structs
}

// ManagedFieldsLen returns the number of items in the list.
func (x ObjectMeta) ManagedFieldsLen(ctx context.Context) int {
    return x.ManagedFieldsList(ctx).Len()
}

// ManagedFieldsGet returns the item at the given index.
func (x ObjectMeta) ManagedFieldsGet(ctx context.Context, index int) ManagedFieldsEntry {
    s := x.ManagedFieldsList(ctx).Get(index)
    return ManagedFieldsEntry{s: s}
}

// ManagedFieldsAppend appends items to the list.
func (x ObjectMeta) ManagedFieldsAppend(ctx context.Context, values ...ManagedFieldsEntry) {
    list := x.ManagedFieldsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ManagedFieldsAppendRaw appends items to the list using Raw struct representations.
func (x ObjectMeta) ManagedFieldsAppendRaw(ctx context.Context, values ...*ManagedFieldsEntryRaw) {
    list := x.ManagedFieldsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewManagedFieldsEntryFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ObjectMeta) IsSetManagedFields() bool{
    return x.s.HasField(14)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ObjectMeta) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ObjectMeta) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ObjectMeta) XXXTypeHash() [16]byte {
    return XXXTypeHashObjectMeta
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ObjectMeta) SetRecording(enabled bool) ObjectMeta {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ObjectMeta) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ObjectMeta) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ObjectMeta) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ObjectMetaRaw is a plain Go struct representation of ObjectMeta.
// Zero values are not set (sparse encoding).
type ObjectMetaRaw struct {
    Name string
    GenerateName string
    Namespace string
    SelfLink string
    Uid string
    ResourceVersion string
    Generation int64
    CreationTimestamp *TimeRaw
    DeletionTimestamp *TimeRaw
    DeletionGracePeriodSeconds int64
    Labels []*KeyValueRaw
    Annotations []*KeyValueRaw
    OwnerReferences []*OwnerReferenceRaw
    Finalizers []string
    ManagedFields []*ManagedFieldsEntryRaw
}

// NewObjectMetaFromRaw creates a new ObjectMeta from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewObjectMetaFromRaw(ctx context.Context, raw ObjectMetaRaw) ObjectMeta {
    x := NewObjectMeta(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.GenerateName != "" {
        x.SetGenerateName(raw.GenerateName)
    }
    if raw.Namespace != "" {
        x.SetNamespace(raw.Namespace)
    }
    if raw.SelfLink != "" {
        x.SetSelfLink(raw.SelfLink)
    }
    if raw.Uid != "" {
        x.SetUid(raw.Uid)
    }
    if raw.ResourceVersion != "" {
        x.SetResourceVersion(raw.ResourceVersion)
    }
    if raw.Generation != 0 {
        x.SetGeneration(raw.Generation)
    }
    if raw.CreationTimestamp != nil {
        x.SetCreationTimestamp(NewTimeFromRaw(ctx, *raw.CreationTimestamp))
    }
    if raw.DeletionTimestamp != nil {
        x.SetDeletionTimestamp(NewTimeFromRaw(ctx, *raw.DeletionTimestamp))
    }
    if raw.DeletionGracePeriodSeconds != 0 {
        x.SetDeletionGracePeriodSeconds(raw.DeletionGracePeriodSeconds)
    }
    if raw.Labels != nil {
        list := x.LabelsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Labels))
        for _, r := range raw.Labels {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Annotations != nil {
        list := x.AnnotationsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Annotations))
        for _, r := range raw.Annotations {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.OwnerReferences != nil {
        list := x.OwnerReferencesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.OwnerReferences))
        for _, r := range raw.OwnerReferences {
            if r != nil {
                items = append(items, NewOwnerReferenceFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Finalizers != nil {
        x.SetFinalizers(raw.Finalizers...)
    }
    if raw.ManagedFields != nil {
        list := x.ManagedFieldsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.ManagedFields))
        for _, r := range raw.ManagedFields {
            if r != nil {
                items = append(items, NewManagedFieldsEntryFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ObjectMeta) ToRaw(ctx context.Context) ObjectMetaRaw {
    raw := ObjectMetaRaw{}
    raw.Name = x.Name()
    raw.GenerateName = x.GenerateName()
    raw.Namespace = x.Namespace()
    raw.SelfLink = x.SelfLink()
    raw.Uid = x.Uid()
    raw.ResourceVersion = x.ResourceVersion()
    raw.Generation = x.Generation()
    if x.s.HasField(7) {
        nestedRaw := x.CreationTimestamp().ToRaw(ctx)
        raw.CreationTimestamp = &nestedRaw
    }
    if x.s.HasField(8) {
        nestedRaw := x.DeletionTimestamp().ToRaw(ctx)
        raw.DeletionTimestamp = &nestedRaw
    }
    raw.DeletionGracePeriodSeconds = x.DeletionGracePeriodSeconds()
    if l := x.s.GetList(10); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Labels = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Labels[i] = &itemRaw
        }
    } else if x.s.HasField(10) {
        list := x.LabelsList(ctx)
        raw.Labels = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Labels[i] = &itemRaw
        }
    }
    if l := x.s.GetList(11); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Annotations = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Annotations[i] = &itemRaw
        }
    } else if x.s.HasField(11) {
        list := x.AnnotationsList(ctx)
        raw.Annotations = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Annotations[i] = &itemRaw
        }
    }
    if l := x.s.GetList(12); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.OwnerReferences = make([]*OwnerReferenceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := OwnerReference{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.OwnerReferences[i] = &itemRaw
        }
    } else if x.s.HasField(12) {
        list := x.OwnerReferencesList(ctx)
        raw.OwnerReferences = make([]*OwnerReferenceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := OwnerReference{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.OwnerReferences[i] = &itemRaw
        }
    }
    if l := x.s.GetList(13); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Finalizers = l.(*segment.Strings).Slice()
    } else if x.s.HasField(13) {
        raw.Finalizers = x.Finalizers().Slice()
    }
    if l := x.s.GetList(14); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.ManagedFields = make([]*ManagedFieldsEntryRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ManagedFieldsEntry{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ManagedFields[i] = &itemRaw
        }
    } else if x.s.HasField(14) {
        list := x.ManagedFieldsList(ctx)
        raw.ManagedFields = make([]*ManagedFieldsEntryRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ManagedFieldsEntry{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ManagedFields[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ObjectMeta) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(50)
}

// OwnerReference contains enough information to let you identify an owning object.
type OwnerReference struct {
   s *segment.Struct
}

// NewOwnerReference creates a new pooled instance of OwnerReference.
// Call Release() when done to return it to the pool for reuse.
func NewOwnerReference(ctx context.Context) OwnerReference {
    s := segment.New(ctx, XXXMappingOwnerReference)
    s.SetIsSetEnabled(true)
    return OwnerReference{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x OwnerReference) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewOwnerReferenceFrom creates a new OwnerReference from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewOwnerReferenceFrom(s *segment.Struct) OwnerReference {
    return OwnerReference{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x OwnerReference) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x OwnerReference) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x OwnerReference) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x OwnerReference) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x OwnerReference) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x OwnerReference) ApiVersion() string {
    return segment.GetString(x.s, 0)
}

func (x OwnerReference) SetApiVersion(value string) OwnerReference {
    segment.SetString(x.s, 0, value)
    return x
}
func (x OwnerReference) IsSetApiVersion() bool{
    return x.s.HasField(0)
}

func (x OwnerReference) Kind() string {
    return segment.GetString(x.s, 1)
}

func (x OwnerReference) SetKind(value string) OwnerReference {
    segment.SetString(x.s, 1, value)
    return x
}
func (x OwnerReference) IsSetKind() bool{
    return x.s.HasField(1)
}

func (x OwnerReference) Name() string {
    return segment.GetString(x.s, 2)
}

func (x OwnerReference) SetName(value string) OwnerReference {
    segment.SetString(x.s, 2, value)
    return x
}
func (x OwnerReference) IsSetName() bool{
    return x.s.HasField(2)
}

func (x OwnerReference) Uid() string {
    return segment.GetString(x.s, 3)
}

func (x OwnerReference) SetUid(value string) OwnerReference {
    segment.SetString(x.s, 3, value)
    return x
}
func (x OwnerReference) IsSetUid() bool{
    return x.s.HasField(3)
}

func (x OwnerReference) Controller() bool {
    return segment.GetBool(x.s, 4)
}

func (x OwnerReference) SetController(value bool) OwnerReference {
    segment.SetBool(x.s, 4, value)
    return x
}
func (x OwnerReference) IsSetController() bool{
    return x.s.HasField(4)
}

func (x OwnerReference) BlockOwnerDeletion() bool {
    return segment.GetBool(x.s, 5)
}

func (x OwnerReference) SetBlockOwnerDeletion(value bool) OwnerReference {
    segment.SetBool(x.s, 5, value)
    return x
}
func (x OwnerReference) IsSetBlockOwnerDeletion() bool{
    return x.s.HasField(5)
}



// ClawStruct returns a reflection type representing the Struct.
func (x OwnerReference) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x OwnerReference) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x OwnerReference) XXXTypeHash() [16]byte {
    return XXXTypeHashOwnerReference
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x OwnerReference) SetRecording(enabled bool) OwnerReference {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x OwnerReference) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x OwnerReference) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x OwnerReference) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// OwnerReferenceRaw is a plain Go struct representation of OwnerReference.
// Zero values are not set (sparse encoding).
type OwnerReferenceRaw struct {
    ApiVersion string
    Kind string
    Name string
    Uid string
    Controller bool
    BlockOwnerDeletion bool
}

// NewOwnerReferenceFromRaw creates a new OwnerReference from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewOwnerReferenceFromRaw(ctx context.Context, raw OwnerReferenceRaw) OwnerReference {
    x := NewOwnerReference(ctx)
    if raw.ApiVersion != "" {
        x.SetApiVersion(raw.ApiVersion)
    }
    if raw.Kind != "" {
        x.SetKind(raw.Kind)
    }
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Uid != "" {
        x.SetUid(raw.Uid)
    }
    if raw.Controller {
        x.SetController(raw.Controller)
    }
    if raw.BlockOwnerDeletion {
        x.SetBlockOwnerDeletion(raw.BlockOwnerDeletion)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x OwnerReference) ToRaw(ctx context.Context) OwnerReferenceRaw {
    raw := OwnerReferenceRaw{}
    raw.ApiVersion = x.ApiVersion()
    raw.Kind = x.Kind()
    raw.Name = x.Name()
    raw.Uid = x.Uid()
    raw.Controller = x.Controller()
    raw.BlockOwnerDeletion = x.BlockOwnerDeletion()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x OwnerReference) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(51)
}

// PersistentVolumeClaimSpec describes the common attributes of storage devices.
type PersistentVolumeClaimSpec struct {
   s *segment.Struct
}

// NewPersistentVolumeClaimSpec creates a new pooled instance of PersistentVolumeClaimSpec.
// Call Release() when done to return it to the pool for reuse.
func NewPersistentVolumeClaimSpec(ctx context.Context) PersistentVolumeClaimSpec {
    s := segment.New(ctx, XXXMappingPersistentVolumeClaimSpec)
    s.SetIsSetEnabled(true)
    return PersistentVolumeClaimSpec{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PersistentVolumeClaimSpec) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPersistentVolumeClaimSpecFrom creates a new PersistentVolumeClaimSpec from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPersistentVolumeClaimSpecFrom(s *segment.Struct) PersistentVolumeClaimSpec {
    return PersistentVolumeClaimSpec{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PersistentVolumeClaimSpec) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PersistentVolumeClaimSpec) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PersistentVolumeClaimSpec) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PersistentVolumeClaimSpec) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PersistentVolumeClaimSpec) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// Enum list - returns a number list that can be cast to the enum type
func (x PersistentVolumeClaimSpec) AccessModes() *segment.Numbers[PersistentVolumeAccessMode] {
    // Try to get cached or parse from segment
    if nums := segment.GetListNumbers[PersistentVolumeAccessMode](x.s, 0); nums != nil {
        return nums
    }
    // Create new empty list if no data exists
    nums := segment.NewNumbers[PersistentVolumeAccessMode](x.s, 0)
    return nums
}
func (x PersistentVolumeClaimSpec) IsSetAccessModes() bool{
    return x.s.HasField(0)
}

// SetAccessModes replaces all values in the numeric list.
func (x PersistentVolumeClaimSpec) SetAccessModes(v ...PersistentVolumeAccessMode) PersistentVolumeClaimSpec {
    nums := x.AccessModes()
    nums.SetAll(v)
    return x
}

func (x PersistentVolumeClaimSpec) Selector() LabelSelector {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingLabelSelector)
    return LabelSelector{s: s}
}

func (x PersistentVolumeClaimSpec) SetSelector(value LabelSelector) PersistentVolumeClaimSpec {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x PersistentVolumeClaimSpec) IsSetSelector() bool{
    return x.s.HasField(1)
}

func (x PersistentVolumeClaimSpec) Resources() ResourceRequirements {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingResourceRequirements)
    return ResourceRequirements{s: s}
}

func (x PersistentVolumeClaimSpec) SetResources(value ResourceRequirements) PersistentVolumeClaimSpec {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x PersistentVolumeClaimSpec) IsSetResources() bool{
    return x.s.HasField(2)
}

func (x PersistentVolumeClaimSpec) VolumeName() string {
    return segment.GetString(x.s, 3)
}

func (x PersistentVolumeClaimSpec) SetVolumeName(value string) PersistentVolumeClaimSpec {
    segment.SetString(x.s, 3, value)
    return x
}
func (x PersistentVolumeClaimSpec) IsSetVolumeName() bool{
    return x.s.HasField(3)
}

func (x PersistentVolumeClaimSpec) StorageClassName() string {
    return segment.GetString(x.s, 4)
}

func (x PersistentVolumeClaimSpec) SetStorageClassName(value string) PersistentVolumeClaimSpec {
    segment.SetString(x.s, 4, value)
    return x
}
func (x PersistentVolumeClaimSpec) IsSetStorageClassName() bool{
    return x.s.HasField(4)
}

func (x PersistentVolumeClaimSpec) VolumeMode() PersistentVolumeMode {
    return PersistentVolumeMode(segment.GetUint8(x.s, 5))
}

func (x PersistentVolumeClaimSpec) SetVolumeMode(value PersistentVolumeMode) PersistentVolumeClaimSpec {
    segment.SetUint8(x.s, 5, uint8(value))
    return x
}
func (x PersistentVolumeClaimSpec) IsSetVolumeMode() bool{
    return x.s.HasField(5)
}

func (x PersistentVolumeClaimSpec) DataSource() TypedLocalObjectReference {
    s := segment.GetNestedStruct(x.s, 6, XXXMappingTypedLocalObjectReference)
    return TypedLocalObjectReference{s: s}
}

func (x PersistentVolumeClaimSpec) SetDataSource(value TypedLocalObjectReference) PersistentVolumeClaimSpec {
    segment.SetNestedStruct(x.s, 6, value.XXXGetStruct())
    return x
}
func (x PersistentVolumeClaimSpec) IsSetDataSource() bool{
    return x.s.HasField(6)
}

func (x PersistentVolumeClaimSpec) DataSourceRef() TypedObjectReference {
    s := segment.GetNestedStruct(x.s, 7, XXXMappingTypedObjectReference)
    return TypedObjectReference{s: s}
}

func (x PersistentVolumeClaimSpec) SetDataSourceRef(value TypedObjectReference) PersistentVolumeClaimSpec {
    segment.SetNestedStruct(x.s, 7, value.XXXGetStruct())
    return x
}
func (x PersistentVolumeClaimSpec) IsSetDataSourceRef() bool{
    return x.s.HasField(7)
}

func (x PersistentVolumeClaimSpec) VolumeAttributesClassName() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 8); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 8)
    return strs
}

// SetVolumeAttributesClassName replaces all values in the string list.
func (x PersistentVolumeClaimSpec) SetVolumeAttributesClassName(v ...string) PersistentVolumeClaimSpec {
    strs := x.VolumeAttributesClassName()
    strs.SetAll(v)
    return x
}
func (x PersistentVolumeClaimSpec) IsSetVolumeAttributesClassName() bool{
    return x.s.HasField(8)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PersistentVolumeClaimSpec) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PersistentVolumeClaimSpec) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PersistentVolumeClaimSpec) XXXTypeHash() [16]byte {
    return XXXTypeHashPersistentVolumeClaimSpec
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PersistentVolumeClaimSpec) SetRecording(enabled bool) PersistentVolumeClaimSpec {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PersistentVolumeClaimSpec) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PersistentVolumeClaimSpec) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PersistentVolumeClaimSpec) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PersistentVolumeClaimSpecRaw is a plain Go struct representation of PersistentVolumeClaimSpec.
// Zero values are not set (sparse encoding).
type PersistentVolumeClaimSpecRaw struct {
    AccessModes []PersistentVolumeAccessMode
    Selector *LabelSelectorRaw
    Resources *ResourceRequirementsRaw
    VolumeName string
    StorageClassName string
    VolumeMode PersistentVolumeMode
    DataSource *TypedLocalObjectReferenceRaw
    DataSourceRef *TypedObjectReferenceRaw
    VolumeAttributesClassName []string
}

// NewPersistentVolumeClaimSpecFromRaw creates a new PersistentVolumeClaimSpec from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPersistentVolumeClaimSpecFromRaw(ctx context.Context, raw PersistentVolumeClaimSpecRaw) PersistentVolumeClaimSpec {
    x := NewPersistentVolumeClaimSpec(ctx)
    if raw.AccessModes != nil {
        x.SetAccessModes(raw.AccessModes...)
    }
    if raw.Selector != nil {
        x.SetSelector(NewLabelSelectorFromRaw(ctx, *raw.Selector))
    }
    if raw.Resources != nil {
        x.SetResources(NewResourceRequirementsFromRaw(ctx, *raw.Resources))
    }
    if raw.VolumeName != "" {
        x.SetVolumeName(raw.VolumeName)
    }
    if raw.StorageClassName != "" {
        x.SetStorageClassName(raw.StorageClassName)
    }
    if raw.VolumeMode != 0 {
        x.SetVolumeMode(raw.VolumeMode)
    }
    if raw.DataSource != nil {
        x.SetDataSource(NewTypedLocalObjectReferenceFromRaw(ctx, *raw.DataSource))
    }
    if raw.DataSourceRef != nil {
        x.SetDataSourceRef(NewTypedObjectReferenceFromRaw(ctx, *raw.DataSourceRef))
    }
    if raw.VolumeAttributesClassName != nil {
        x.SetVolumeAttributesClassName(raw.VolumeAttributesClassName...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PersistentVolumeClaimSpec) ToRaw(ctx context.Context) PersistentVolumeClaimSpecRaw {
    raw := PersistentVolumeClaimSpecRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Numbers[PersistentVolumeAccessMode]).Len() > 0 {
        raw.AccessModes = l.(*segment.Numbers[PersistentVolumeAccessMode]).Slice()
    } else if x.s.HasField(0) {
        raw.AccessModes = x.AccessModes().Slice()
    }
    if x.s.HasField(1) {
        nestedRaw := x.Selector().ToRaw(ctx)
        raw.Selector = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.Resources().ToRaw(ctx)
        raw.Resources = &nestedRaw
    }
    raw.VolumeName = x.VolumeName()
    raw.StorageClassName = x.StorageClassName()
    raw.VolumeMode = x.VolumeMode()
    if x.s.HasField(6) {
        nestedRaw := x.DataSource().ToRaw(ctx)
        raw.DataSource = &nestedRaw
    }
    if x.s.HasField(7) {
        nestedRaw := x.DataSourceRef().ToRaw(ctx)
        raw.DataSourceRef = &nestedRaw
    }
    if l := x.s.GetList(8); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.VolumeAttributesClassName = l.(*segment.Strings).Slice()
    } else if x.s.HasField(8) {
        raw.VolumeAttributesClassName = x.VolumeAttributesClassName().Slice()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PersistentVolumeClaimSpec) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(52)
}

// PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim objects.
type PersistentVolumeClaimTemplate struct {
   s *segment.Struct
}

// NewPersistentVolumeClaimTemplate creates a new pooled instance of PersistentVolumeClaimTemplate.
// Call Release() when done to return it to the pool for reuse.
func NewPersistentVolumeClaimTemplate(ctx context.Context) PersistentVolumeClaimTemplate {
    s := segment.New(ctx, XXXMappingPersistentVolumeClaimTemplate)
    s.SetIsSetEnabled(true)
    return PersistentVolumeClaimTemplate{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PersistentVolumeClaimTemplate) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPersistentVolumeClaimTemplateFrom creates a new PersistentVolumeClaimTemplate from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPersistentVolumeClaimTemplateFrom(s *segment.Struct) PersistentVolumeClaimTemplate {
    return PersistentVolumeClaimTemplate{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PersistentVolumeClaimTemplate) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PersistentVolumeClaimTemplate) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PersistentVolumeClaimTemplate) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PersistentVolumeClaimTemplate) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PersistentVolumeClaimTemplate) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PersistentVolumeClaimTemplate) Metadata() ObjectMeta {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingObjectMeta)
    return ObjectMeta{s: s}
}

func (x PersistentVolumeClaimTemplate) SetMetadata(value ObjectMeta) PersistentVolumeClaimTemplate {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x PersistentVolumeClaimTemplate) IsSetMetadata() bool{
    return x.s.HasField(0)
}

func (x PersistentVolumeClaimTemplate) Spec() PersistentVolumeClaimSpec {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingPersistentVolumeClaimSpec)
    return PersistentVolumeClaimSpec{s: s}
}

func (x PersistentVolumeClaimTemplate) SetSpec(value PersistentVolumeClaimSpec) PersistentVolumeClaimTemplate {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x PersistentVolumeClaimTemplate) IsSetSpec() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PersistentVolumeClaimTemplate) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PersistentVolumeClaimTemplate) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PersistentVolumeClaimTemplate) XXXTypeHash() [16]byte {
    return XXXTypeHashPersistentVolumeClaimTemplate
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PersistentVolumeClaimTemplate) SetRecording(enabled bool) PersistentVolumeClaimTemplate {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PersistentVolumeClaimTemplate) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PersistentVolumeClaimTemplate) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PersistentVolumeClaimTemplate) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PersistentVolumeClaimTemplateRaw is a plain Go struct representation of PersistentVolumeClaimTemplate.
// Zero values are not set (sparse encoding).
type PersistentVolumeClaimTemplateRaw struct {
    Metadata *ObjectMetaRaw
    Spec *PersistentVolumeClaimSpecRaw
}

// NewPersistentVolumeClaimTemplateFromRaw creates a new PersistentVolumeClaimTemplate from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPersistentVolumeClaimTemplateFromRaw(ctx context.Context, raw PersistentVolumeClaimTemplateRaw) PersistentVolumeClaimTemplate {
    x := NewPersistentVolumeClaimTemplate(ctx)
    if raw.Metadata != nil {
        x.SetMetadata(NewObjectMetaFromRaw(ctx, *raw.Metadata))
    }
    if raw.Spec != nil {
        x.SetSpec(NewPersistentVolumeClaimSpecFromRaw(ctx, *raw.Spec))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PersistentVolumeClaimTemplate) ToRaw(ctx context.Context) PersistentVolumeClaimTemplateRaw {
    raw := PersistentVolumeClaimTemplateRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.Metadata().ToRaw(ctx)
        raw.Metadata = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.Spec().ToRaw(ctx)
        raw.Spec = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PersistentVolumeClaimTemplate) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(53)
}

// PersistentVolumeClaimVolumeSource references a PersistentVolumeClaim.
type PersistentVolumeClaimVolumeSource struct {
   s *segment.Struct
}

// NewPersistentVolumeClaimVolumeSource creates a new pooled instance of PersistentVolumeClaimVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewPersistentVolumeClaimVolumeSource(ctx context.Context) PersistentVolumeClaimVolumeSource {
    s := segment.New(ctx, XXXMappingPersistentVolumeClaimVolumeSource)
    s.SetIsSetEnabled(true)
    return PersistentVolumeClaimVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PersistentVolumeClaimVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPersistentVolumeClaimVolumeSourceFrom creates a new PersistentVolumeClaimVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPersistentVolumeClaimVolumeSourceFrom(s *segment.Struct) PersistentVolumeClaimVolumeSource {
    return PersistentVolumeClaimVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PersistentVolumeClaimVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PersistentVolumeClaimVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PersistentVolumeClaimVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PersistentVolumeClaimVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PersistentVolumeClaimVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PersistentVolumeClaimVolumeSource) ClaimName() string {
    return segment.GetString(x.s, 0)
}

func (x PersistentVolumeClaimVolumeSource) SetClaimName(value string) PersistentVolumeClaimVolumeSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x PersistentVolumeClaimVolumeSource) IsSetClaimName() bool{
    return x.s.HasField(0)
}

func (x PersistentVolumeClaimVolumeSource) ReadOnly() bool {
    return segment.GetBool(x.s, 1)
}

func (x PersistentVolumeClaimVolumeSource) SetReadOnly(value bool) PersistentVolumeClaimVolumeSource {
    segment.SetBool(x.s, 1, value)
    return x
}
func (x PersistentVolumeClaimVolumeSource) IsSetReadOnly() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PersistentVolumeClaimVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PersistentVolumeClaimVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PersistentVolumeClaimVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashPersistentVolumeClaimVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PersistentVolumeClaimVolumeSource) SetRecording(enabled bool) PersistentVolumeClaimVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PersistentVolumeClaimVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PersistentVolumeClaimVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PersistentVolumeClaimVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PersistentVolumeClaimVolumeSourceRaw is a plain Go struct representation of PersistentVolumeClaimVolumeSource.
// Zero values are not set (sparse encoding).
type PersistentVolumeClaimVolumeSourceRaw struct {
    ClaimName string
    ReadOnly bool
}

// NewPersistentVolumeClaimVolumeSourceFromRaw creates a new PersistentVolumeClaimVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPersistentVolumeClaimVolumeSourceFromRaw(ctx context.Context, raw PersistentVolumeClaimVolumeSourceRaw) PersistentVolumeClaimVolumeSource {
    x := NewPersistentVolumeClaimVolumeSource(ctx)
    if raw.ClaimName != "" {
        x.SetClaimName(raw.ClaimName)
    }
    if raw.ReadOnly {
        x.SetReadOnly(raw.ReadOnly)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PersistentVolumeClaimVolumeSource) ToRaw(ctx context.Context) PersistentVolumeClaimVolumeSourceRaw {
    raw := PersistentVolumeClaimVolumeSourceRaw{}
    raw.ClaimName = x.ClaimName()
    raw.ReadOnly = x.ReadOnly()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PersistentVolumeClaimVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(54)
}

// Pod is a collection of containers that can run on a host.
type Pod struct {
   s *segment.Struct
}

// NewPod creates a new pooled instance of Pod.
// Call Release() when done to return it to the pool for reuse.
func NewPod(ctx context.Context) Pod {
    s := segment.New(ctx, XXXMappingPod)
    s.SetIsSetEnabled(true)
    return Pod{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Pod) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodFrom creates a new Pod from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodFrom(s *segment.Struct) Pod {
    return Pod{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Pod) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Pod) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Pod) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Pod) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Pod) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Pod) TypeMeta() TypeMeta {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingTypeMeta)
    return TypeMeta{s: s}
}

func (x Pod) SetTypeMeta(value TypeMeta) Pod {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x Pod) IsSetTypeMeta() bool{
    return x.s.HasField(0)
}

func (x Pod) Metadata() ObjectMeta {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingObjectMeta)
    return ObjectMeta{s: s}
}

func (x Pod) SetMetadata(value ObjectMeta) Pod {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x Pod) IsSetMetadata() bool{
    return x.s.HasField(1)
}

func (x Pod) Spec() PodSpec {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingPodSpec)
    return PodSpec{s: s}
}

func (x Pod) SetSpec(value PodSpec) Pod {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x Pod) IsSetSpec() bool{
    return x.s.HasField(2)
}

func (x Pod) Status() PodStatus {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingPodStatus)
    return PodStatus{s: s}
}

func (x Pod) SetStatus(value PodStatus) Pod {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x Pod) IsSetStatus() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Pod) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Pod) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Pod) XXXTypeHash() [16]byte {
    return XXXTypeHashPod
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Pod) SetRecording(enabled bool) Pod {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Pod) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Pod) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Pod) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodRaw is a plain Go struct representation of Pod.
// Zero values are not set (sparse encoding).
type PodRaw struct {
    TypeMeta *TypeMetaRaw
    Metadata *ObjectMetaRaw
    Spec *PodSpecRaw
    Status *PodStatusRaw
}

// NewPodFromRaw creates a new Pod from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodFromRaw(ctx context.Context, raw PodRaw) Pod {
    x := NewPod(ctx)
    if raw.TypeMeta != nil {
        x.SetTypeMeta(NewTypeMetaFromRaw(ctx, *raw.TypeMeta))
    }
    if raw.Metadata != nil {
        x.SetMetadata(NewObjectMetaFromRaw(ctx, *raw.Metadata))
    }
    if raw.Spec != nil {
        x.SetSpec(NewPodSpecFromRaw(ctx, *raw.Spec))
    }
    if raw.Status != nil {
        x.SetStatus(NewPodStatusFromRaw(ctx, *raw.Status))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Pod) ToRaw(ctx context.Context) PodRaw {
    raw := PodRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.TypeMeta().ToRaw(ctx)
        raw.TypeMeta = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.Metadata().ToRaw(ctx)
        raw.Metadata = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.Spec().ToRaw(ctx)
        raw.Spec = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.Status().ToRaw(ctx)
        raw.Status = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Pod) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(55)
}

// PodAffinity is a group of inter pod affinity scheduling rules.
type PodAffinity struct {
   s *segment.Struct
}

// NewPodAffinity creates a new pooled instance of PodAffinity.
// Call Release() when done to return it to the pool for reuse.
func NewPodAffinity(ctx context.Context) PodAffinity {
    s := segment.New(ctx, XXXMappingPodAffinity)
    s.SetIsSetEnabled(true)
    return PodAffinity{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodAffinity) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodAffinityFrom creates a new PodAffinity from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodAffinityFrom(s *segment.Struct) PodAffinity {
    return PodAffinity{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodAffinity) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodAffinity) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodAffinity) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodAffinity) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodAffinity) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// RequiredDuringSchedulingIgnoredDuringExecutionList returns the underlying Structs list for iteration.
// Use NewPodAffinityTerm() to create items and Append to add them.
func (x PodAffinity) RequiredDuringSchedulingIgnoredDuringExecutionList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingPodAffinityTerm); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingPodAffinityTerm)
    return structs
}

// RequiredDuringSchedulingIgnoredDuringExecutionLen returns the number of items in the list.
func (x PodAffinity) RequiredDuringSchedulingIgnoredDuringExecutionLen(ctx context.Context) int {
    return x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx).Len()
}

// RequiredDuringSchedulingIgnoredDuringExecutionGet returns the item at the given index.
func (x PodAffinity) RequiredDuringSchedulingIgnoredDuringExecutionGet(ctx context.Context, index int) PodAffinityTerm {
    s := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx).Get(index)
    return PodAffinityTerm{s: s}
}

// RequiredDuringSchedulingIgnoredDuringExecutionAppend appends items to the list.
func (x PodAffinity) RequiredDuringSchedulingIgnoredDuringExecutionAppend(ctx context.Context, values ...PodAffinityTerm) {
    list := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// RequiredDuringSchedulingIgnoredDuringExecutionAppendRaw appends items to the list using Raw struct representations.
func (x PodAffinity) RequiredDuringSchedulingIgnoredDuringExecutionAppendRaw(ctx context.Context, values ...*PodAffinityTermRaw) {
    list := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodAffinityTermFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodAffinity) IsSetRequiredDuringSchedulingIgnoredDuringExecution() bool{
    return x.s.HasField(0)
}

// PreferredDuringSchedulingIgnoredDuringExecutionList returns the underlying Structs list for iteration.
// Use NewWeightedPodAffinityTerm() to create items and Append to add them.
func (x PodAffinity) PreferredDuringSchedulingIgnoredDuringExecutionList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingWeightedPodAffinityTerm); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingWeightedPodAffinityTerm)
    return structs
}

// PreferredDuringSchedulingIgnoredDuringExecutionLen returns the number of items in the list.
func (x PodAffinity) PreferredDuringSchedulingIgnoredDuringExecutionLen(ctx context.Context) int {
    return x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx).Len()
}

// PreferredDuringSchedulingIgnoredDuringExecutionGet returns the item at the given index.
func (x PodAffinity) PreferredDuringSchedulingIgnoredDuringExecutionGet(ctx context.Context, index int) WeightedPodAffinityTerm {
    s := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx).Get(index)
    return WeightedPodAffinityTerm{s: s}
}

// PreferredDuringSchedulingIgnoredDuringExecutionAppend appends items to the list.
func (x PodAffinity) PreferredDuringSchedulingIgnoredDuringExecutionAppend(ctx context.Context, values ...WeightedPodAffinityTerm) {
    list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// PreferredDuringSchedulingIgnoredDuringExecutionAppendRaw appends items to the list using Raw struct representations.
func (x PodAffinity) PreferredDuringSchedulingIgnoredDuringExecutionAppendRaw(ctx context.Context, values ...*WeightedPodAffinityTermRaw) {
    list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewWeightedPodAffinityTermFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodAffinity) IsSetPreferredDuringSchedulingIgnoredDuringExecution() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodAffinity) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodAffinity) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodAffinity) XXXTypeHash() [16]byte {
    return XXXTypeHashPodAffinity
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodAffinity) SetRecording(enabled bool) PodAffinity {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodAffinity) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodAffinity) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodAffinity) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodAffinityRaw is a plain Go struct representation of PodAffinity.
// Zero values are not set (sparse encoding).
type PodAffinityRaw struct {
    RequiredDuringSchedulingIgnoredDuringExecution []*PodAffinityTermRaw
    PreferredDuringSchedulingIgnoredDuringExecution []*WeightedPodAffinityTermRaw
}

// NewPodAffinityFromRaw creates a new PodAffinity from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodAffinityFromRaw(ctx context.Context, raw PodAffinityRaw) PodAffinity {
    x := NewPodAffinity(ctx)
    if raw.RequiredDuringSchedulingIgnoredDuringExecution != nil {
        list := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx)
        items := make([]*segment.Struct, 0, len(raw.RequiredDuringSchedulingIgnoredDuringExecution))
        for _, r := range raw.RequiredDuringSchedulingIgnoredDuringExecution {
            if r != nil {
                items = append(items, NewPodAffinityTermFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.PreferredDuringSchedulingIgnoredDuringExecution != nil {
        list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
        items := make([]*segment.Struct, 0, len(raw.PreferredDuringSchedulingIgnoredDuringExecution))
        for _, r := range raw.PreferredDuringSchedulingIgnoredDuringExecution {
            if r != nil {
                items = append(items, NewWeightedPodAffinityTermFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodAffinity) ToRaw(ctx context.Context) PodAffinityRaw {
    raw := PodAffinityRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.RequiredDuringSchedulingIgnoredDuringExecution = make([]*PodAffinityTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodAffinityTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.RequiredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx)
        raw.RequiredDuringSchedulingIgnoredDuringExecution = make([]*PodAffinityTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodAffinityTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.RequiredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.PreferredDuringSchedulingIgnoredDuringExecution = make([]*WeightedPodAffinityTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := WeightedPodAffinityTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.PreferredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
        raw.PreferredDuringSchedulingIgnoredDuringExecution = make([]*WeightedPodAffinityTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := WeightedPodAffinityTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.PreferredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodAffinity) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(56)
}

// PodAffinityTerm defines a set of pods for this pod to co-locate/anti-locate with.
type PodAffinityTerm struct {
   s *segment.Struct
}

// NewPodAffinityTerm creates a new pooled instance of PodAffinityTerm.
// Call Release() when done to return it to the pool for reuse.
func NewPodAffinityTerm(ctx context.Context) PodAffinityTerm {
    s := segment.New(ctx, XXXMappingPodAffinityTerm)
    s.SetIsSetEnabled(true)
    return PodAffinityTerm{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodAffinityTerm) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodAffinityTermFrom creates a new PodAffinityTerm from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodAffinityTermFrom(s *segment.Struct) PodAffinityTerm {
    return PodAffinityTerm{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodAffinityTerm) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodAffinityTerm) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodAffinityTerm) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodAffinityTerm) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodAffinityTerm) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodAffinityTerm) LabelSelector() LabelSelector {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingLabelSelector)
    return LabelSelector{s: s}
}

func (x PodAffinityTerm) SetLabelSelector(value LabelSelector) PodAffinityTerm {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x PodAffinityTerm) IsSetLabelSelector() bool{
    return x.s.HasField(0)
}

func (x PodAffinityTerm) Namespaces() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 1); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 1)
    return strs
}

// SetNamespaces replaces all values in the string list.
func (x PodAffinityTerm) SetNamespaces(v ...string) PodAffinityTerm {
    strs := x.Namespaces()
    strs.SetAll(v)
    return x
}
func (x PodAffinityTerm) IsSetNamespaces() bool{
    return x.s.HasField(1)
}

func (x PodAffinityTerm) TopologyKey() string {
    return segment.GetString(x.s, 2)
}

func (x PodAffinityTerm) SetTopologyKey(value string) PodAffinityTerm {
    segment.SetString(x.s, 2, value)
    return x
}
func (x PodAffinityTerm) IsSetTopologyKey() bool{
    return x.s.HasField(2)
}

func (x PodAffinityTerm) NamespaceSelector() LabelSelector {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingLabelSelector)
    return LabelSelector{s: s}
}

func (x PodAffinityTerm) SetNamespaceSelector(value LabelSelector) PodAffinityTerm {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x PodAffinityTerm) IsSetNamespaceSelector() bool{
    return x.s.HasField(3)
}

func (x PodAffinityTerm) MatchLabelKeys() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 4); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 4)
    return strs
}

// SetMatchLabelKeys replaces all values in the string list.
func (x PodAffinityTerm) SetMatchLabelKeys(v ...string) PodAffinityTerm {
    strs := x.MatchLabelKeys()
    strs.SetAll(v)
    return x
}
func (x PodAffinityTerm) IsSetMatchLabelKeys() bool{
    return x.s.HasField(4)
}

func (x PodAffinityTerm) MismatchLabelKeys() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 5); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 5)
    return strs
}

// SetMismatchLabelKeys replaces all values in the string list.
func (x PodAffinityTerm) SetMismatchLabelKeys(v ...string) PodAffinityTerm {
    strs := x.MismatchLabelKeys()
    strs.SetAll(v)
    return x
}
func (x PodAffinityTerm) IsSetMismatchLabelKeys() bool{
    return x.s.HasField(5)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodAffinityTerm) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodAffinityTerm) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodAffinityTerm) XXXTypeHash() [16]byte {
    return XXXTypeHashPodAffinityTerm
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodAffinityTerm) SetRecording(enabled bool) PodAffinityTerm {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodAffinityTerm) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodAffinityTerm) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodAffinityTerm) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodAffinityTermRaw is a plain Go struct representation of PodAffinityTerm.
// Zero values are not set (sparse encoding).
type PodAffinityTermRaw struct {
    LabelSelector *LabelSelectorRaw
    Namespaces []string
    TopologyKey string
    NamespaceSelector *LabelSelectorRaw
    MatchLabelKeys []string
    MismatchLabelKeys []string
}

// NewPodAffinityTermFromRaw creates a new PodAffinityTerm from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodAffinityTermFromRaw(ctx context.Context, raw PodAffinityTermRaw) PodAffinityTerm {
    x := NewPodAffinityTerm(ctx)
    if raw.LabelSelector != nil {
        x.SetLabelSelector(NewLabelSelectorFromRaw(ctx, *raw.LabelSelector))
    }
    if raw.Namespaces != nil {
        x.SetNamespaces(raw.Namespaces...)
    }
    if raw.TopologyKey != "" {
        x.SetTopologyKey(raw.TopologyKey)
    }
    if raw.NamespaceSelector != nil {
        x.SetNamespaceSelector(NewLabelSelectorFromRaw(ctx, *raw.NamespaceSelector))
    }
    if raw.MatchLabelKeys != nil {
        x.SetMatchLabelKeys(raw.MatchLabelKeys...)
    }
    if raw.MismatchLabelKeys != nil {
        x.SetMismatchLabelKeys(raw.MismatchLabelKeys...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodAffinityTerm) ToRaw(ctx context.Context) PodAffinityTermRaw {
    raw := PodAffinityTermRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.LabelSelector().ToRaw(ctx)
        raw.LabelSelector = &nestedRaw
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Namespaces = l.(*segment.Strings).Slice()
    } else if x.s.HasField(1) {
        raw.Namespaces = x.Namespaces().Slice()
    }
    raw.TopologyKey = x.TopologyKey()
    if x.s.HasField(3) {
        nestedRaw := x.NamespaceSelector().ToRaw(ctx)
        raw.NamespaceSelector = &nestedRaw
    }
    if l := x.s.GetList(4); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.MatchLabelKeys = l.(*segment.Strings).Slice()
    } else if x.s.HasField(4) {
        raw.MatchLabelKeys = x.MatchLabelKeys().Slice()
    }
    if l := x.s.GetList(5); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.MismatchLabelKeys = l.(*segment.Strings).Slice()
    } else if x.s.HasField(5) {
        raw.MismatchLabelKeys = x.MismatchLabelKeys().Slice()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodAffinityTerm) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(57)
}

// PodAntiAffinity is a group of inter pod anti affinity scheduling rules.
type PodAntiAffinity struct {
   s *segment.Struct
}

// NewPodAntiAffinity creates a new pooled instance of PodAntiAffinity.
// Call Release() when done to return it to the pool for reuse.
func NewPodAntiAffinity(ctx context.Context) PodAntiAffinity {
    s := segment.New(ctx, XXXMappingPodAntiAffinity)
    s.SetIsSetEnabled(true)
    return PodAntiAffinity{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodAntiAffinity) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodAntiAffinityFrom creates a new PodAntiAffinity from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodAntiAffinityFrom(s *segment.Struct) PodAntiAffinity {
    return PodAntiAffinity{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodAntiAffinity) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodAntiAffinity) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodAntiAffinity) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodAntiAffinity) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodAntiAffinity) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// RequiredDuringSchedulingIgnoredDuringExecutionList returns the underlying Structs list for iteration.
// Use NewPodAffinityTerm() to create items and Append to add them.
func (x PodAntiAffinity) RequiredDuringSchedulingIgnoredDuringExecutionList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingPodAffinityTerm); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingPodAffinityTerm)
    return structs
}

// RequiredDuringSchedulingIgnoredDuringExecutionLen returns the number of items in the list.
func (x PodAntiAffinity) RequiredDuringSchedulingIgnoredDuringExecutionLen(ctx context.Context) int {
    return x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx).Len()
}

// RequiredDuringSchedulingIgnoredDuringExecutionGet returns the item at the given index.
func (x PodAntiAffinity) RequiredDuringSchedulingIgnoredDuringExecutionGet(ctx context.Context, index int) PodAffinityTerm {
    s := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx).Get(index)
    return PodAffinityTerm{s: s}
}

// RequiredDuringSchedulingIgnoredDuringExecutionAppend appends items to the list.
func (x PodAntiAffinity) RequiredDuringSchedulingIgnoredDuringExecutionAppend(ctx context.Context, values ...PodAffinityTerm) {
    list := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// RequiredDuringSchedulingIgnoredDuringExecutionAppendRaw appends items to the list using Raw struct representations.
func (x PodAntiAffinity) RequiredDuringSchedulingIgnoredDuringExecutionAppendRaw(ctx context.Context, values ...*PodAffinityTermRaw) {
    list := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodAffinityTermFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodAntiAffinity) IsSetRequiredDuringSchedulingIgnoredDuringExecution() bool{
    return x.s.HasField(0)
}

// PreferredDuringSchedulingIgnoredDuringExecutionList returns the underlying Structs list for iteration.
// Use NewWeightedPodAffinityTerm() to create items and Append to add them.
func (x PodAntiAffinity) PreferredDuringSchedulingIgnoredDuringExecutionList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingWeightedPodAffinityTerm); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingWeightedPodAffinityTerm)
    return structs
}

// PreferredDuringSchedulingIgnoredDuringExecutionLen returns the number of items in the list.
func (x PodAntiAffinity) PreferredDuringSchedulingIgnoredDuringExecutionLen(ctx context.Context) int {
    return x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx).Len()
}

// PreferredDuringSchedulingIgnoredDuringExecutionGet returns the item at the given index.
func (x PodAntiAffinity) PreferredDuringSchedulingIgnoredDuringExecutionGet(ctx context.Context, index int) WeightedPodAffinityTerm {
    s := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx).Get(index)
    return WeightedPodAffinityTerm{s: s}
}

// PreferredDuringSchedulingIgnoredDuringExecutionAppend appends items to the list.
func (x PodAntiAffinity) PreferredDuringSchedulingIgnoredDuringExecutionAppend(ctx context.Context, values ...WeightedPodAffinityTerm) {
    list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// PreferredDuringSchedulingIgnoredDuringExecutionAppendRaw appends items to the list using Raw struct representations.
func (x PodAntiAffinity) PreferredDuringSchedulingIgnoredDuringExecutionAppendRaw(ctx context.Context, values ...*WeightedPodAffinityTermRaw) {
    list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewWeightedPodAffinityTermFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodAntiAffinity) IsSetPreferredDuringSchedulingIgnoredDuringExecution() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodAntiAffinity) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodAntiAffinity) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodAntiAffinity) XXXTypeHash() [16]byte {
    return XXXTypeHashPodAntiAffinity
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodAntiAffinity) SetRecording(enabled bool) PodAntiAffinity {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodAntiAffinity) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodAntiAffinity) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodAntiAffinity) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodAntiAffinityRaw is a plain Go struct representation of PodAntiAffinity.
// Zero values are not set (sparse encoding).
type PodAntiAffinityRaw struct {
    RequiredDuringSchedulingIgnoredDuringExecution []*PodAffinityTermRaw
    PreferredDuringSchedulingIgnoredDuringExecution []*WeightedPodAffinityTermRaw
}

// NewPodAntiAffinityFromRaw creates a new PodAntiAffinity from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodAntiAffinityFromRaw(ctx context.Context, raw PodAntiAffinityRaw) PodAntiAffinity {
    x := NewPodAntiAffinity(ctx)
    if raw.RequiredDuringSchedulingIgnoredDuringExecution != nil {
        list := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx)
        items := make([]*segment.Struct, 0, len(raw.RequiredDuringSchedulingIgnoredDuringExecution))
        for _, r := range raw.RequiredDuringSchedulingIgnoredDuringExecution {
            if r != nil {
                items = append(items, NewPodAffinityTermFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.PreferredDuringSchedulingIgnoredDuringExecution != nil {
        list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
        items := make([]*segment.Struct, 0, len(raw.PreferredDuringSchedulingIgnoredDuringExecution))
        for _, r := range raw.PreferredDuringSchedulingIgnoredDuringExecution {
            if r != nil {
                items = append(items, NewWeightedPodAffinityTermFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodAntiAffinity) ToRaw(ctx context.Context) PodAntiAffinityRaw {
    raw := PodAntiAffinityRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.RequiredDuringSchedulingIgnoredDuringExecution = make([]*PodAffinityTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodAffinityTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.RequiredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.RequiredDuringSchedulingIgnoredDuringExecutionList(ctx)
        raw.RequiredDuringSchedulingIgnoredDuringExecution = make([]*PodAffinityTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodAffinityTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.RequiredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.PreferredDuringSchedulingIgnoredDuringExecution = make([]*WeightedPodAffinityTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := WeightedPodAffinityTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.PreferredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.PreferredDuringSchedulingIgnoredDuringExecutionList(ctx)
        raw.PreferredDuringSchedulingIgnoredDuringExecution = make([]*WeightedPodAffinityTermRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := WeightedPodAffinityTerm{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.PreferredDuringSchedulingIgnoredDuringExecution[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodAntiAffinity) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(58)
}

// PodCondition contains details for the current condition of this pod.
type PodCondition struct {
   s *segment.Struct
}

// NewPodCondition creates a new pooled instance of PodCondition.
// Call Release() when done to return it to the pool for reuse.
func NewPodCondition(ctx context.Context) PodCondition {
    s := segment.New(ctx, XXXMappingPodCondition)
    s.SetIsSetEnabled(true)
    return PodCondition{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodCondition) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodConditionFrom creates a new PodCondition from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodConditionFrom(s *segment.Struct) PodCondition {
    return PodCondition{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodCondition) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodCondition) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodCondition) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodCondition) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodCondition) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodCondition) Type() PodConditionType {
    return PodConditionType(segment.GetUint8(x.s, 0))
}

func (x PodCondition) SetType(value PodConditionType) PodCondition {
    segment.SetUint8(x.s, 0, uint8(value))
    return x
}
func (x PodCondition) IsSetType() bool{
    return x.s.HasField(0)
}

func (x PodCondition) Status() ConditionStatus {
    return ConditionStatus(segment.GetUint8(x.s, 1))
}

func (x PodCondition) SetStatus(value ConditionStatus) PodCondition {
    segment.SetUint8(x.s, 1, uint8(value))
    return x
}
func (x PodCondition) IsSetStatus() bool{
    return x.s.HasField(1)
}

func (x PodCondition) LastProbeTime() Time {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingTime)
    return Time{s: s}
}

func (x PodCondition) SetLastProbeTime(value Time) PodCondition {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x PodCondition) IsSetLastProbeTime() bool{
    return x.s.HasField(2)
}

func (x PodCondition) LastTransitionTime() Time {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingTime)
    return Time{s: s}
}

func (x PodCondition) SetLastTransitionTime(value Time) PodCondition {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x PodCondition) IsSetLastTransitionTime() bool{
    return x.s.HasField(3)
}

func (x PodCondition) Reason() string {
    return segment.GetString(x.s, 4)
}

func (x PodCondition) SetReason(value string) PodCondition {
    segment.SetString(x.s, 4, value)
    return x
}
func (x PodCondition) IsSetReason() bool{
    return x.s.HasField(4)
}

func (x PodCondition) Message() string {
    return segment.GetString(x.s, 5)
}

func (x PodCondition) SetMessage(value string) PodCondition {
    segment.SetString(x.s, 5, value)
    return x
}
func (x PodCondition) IsSetMessage() bool{
    return x.s.HasField(5)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodCondition) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodCondition) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodCondition) XXXTypeHash() [16]byte {
    return XXXTypeHashPodCondition
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodCondition) SetRecording(enabled bool) PodCondition {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodCondition) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodCondition) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodCondition) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodConditionRaw is a plain Go struct representation of PodCondition.
// Zero values are not set (sparse encoding).
type PodConditionRaw struct {
    Type PodConditionType
    Status ConditionStatus
    LastProbeTime *TimeRaw
    LastTransitionTime *TimeRaw
    Reason string
    Message string
}

// NewPodConditionFromRaw creates a new PodCondition from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodConditionFromRaw(ctx context.Context, raw PodConditionRaw) PodCondition {
    x := NewPodCondition(ctx)
    if raw.Type != 0 {
        x.SetType(raw.Type)
    }
    if raw.Status != 0 {
        x.SetStatus(raw.Status)
    }
    if raw.LastProbeTime != nil {
        x.SetLastProbeTime(NewTimeFromRaw(ctx, *raw.LastProbeTime))
    }
    if raw.LastTransitionTime != nil {
        x.SetLastTransitionTime(NewTimeFromRaw(ctx, *raw.LastTransitionTime))
    }
    if raw.Reason != "" {
        x.SetReason(raw.Reason)
    }
    if raw.Message != "" {
        x.SetMessage(raw.Message)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodCondition) ToRaw(ctx context.Context) PodConditionRaw {
    raw := PodConditionRaw{}
    raw.Type = x.Type()
    raw.Status = x.Status()
    if x.s.HasField(2) {
        nestedRaw := x.LastProbeTime().ToRaw(ctx)
        raw.LastProbeTime = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.LastTransitionTime().ToRaw(ctx)
        raw.LastTransitionTime = &nestedRaw
    }
    raw.Reason = x.Reason()
    raw.Message = x.Message()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodCondition) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(59)
}

// PodDNSConfig defines the DNS parameters of a pod.
type PodDNSConfig struct {
   s *segment.Struct
}

// NewPodDNSConfig creates a new pooled instance of PodDNSConfig.
// Call Release() when done to return it to the pool for reuse.
func NewPodDNSConfig(ctx context.Context) PodDNSConfig {
    s := segment.New(ctx, XXXMappingPodDNSConfig)
    s.SetIsSetEnabled(true)
    return PodDNSConfig{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodDNSConfig) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodDNSConfigFrom creates a new PodDNSConfig from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodDNSConfigFrom(s *segment.Struct) PodDNSConfig {
    return PodDNSConfig{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodDNSConfig) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodDNSConfig) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodDNSConfig) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodDNSConfig) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodDNSConfig) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodDNSConfig) Nameservers() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 0); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 0)
    return strs
}

// SetNameservers replaces all values in the string list.
func (x PodDNSConfig) SetNameservers(v ...string) PodDNSConfig {
    strs := x.Nameservers()
    strs.SetAll(v)
    return x
}
func (x PodDNSConfig) IsSetNameservers() bool{
    return x.s.HasField(0)
}

func (x PodDNSConfig) Searches() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 1); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 1)
    return strs
}

// SetSearches replaces all values in the string list.
func (x PodDNSConfig) SetSearches(v ...string) PodDNSConfig {
    strs := x.Searches()
    strs.SetAll(v)
    return x
}
func (x PodDNSConfig) IsSetSearches() bool{
    return x.s.HasField(1)
}

// OptionsList returns the underlying Structs list for iteration.
// Use NewPodDNSConfigOption() to create items and Append to add them.
func (x PodDNSConfig) OptionsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 2, XXXMappingPodDNSConfigOption); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 2, XXXMappingPodDNSConfigOption)
    return structs
}

// OptionsLen returns the number of items in the list.
func (x PodDNSConfig) OptionsLen(ctx context.Context) int {
    return x.OptionsList(ctx).Len()
}

// OptionsGet returns the item at the given index.
func (x PodDNSConfig) OptionsGet(ctx context.Context, index int) PodDNSConfigOption {
    s := x.OptionsList(ctx).Get(index)
    return PodDNSConfigOption{s: s}
}

// OptionsAppend appends items to the list.
func (x PodDNSConfig) OptionsAppend(ctx context.Context, values ...PodDNSConfigOption) {
    list := x.OptionsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// OptionsAppendRaw appends items to the list using Raw struct representations.
func (x PodDNSConfig) OptionsAppendRaw(ctx context.Context, values ...*PodDNSConfigOptionRaw) {
    list := x.OptionsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodDNSConfigOptionFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodDNSConfig) IsSetOptions() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodDNSConfig) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodDNSConfig) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodDNSConfig) XXXTypeHash() [16]byte {
    return XXXTypeHashPodDNSConfig
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodDNSConfig) SetRecording(enabled bool) PodDNSConfig {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodDNSConfig) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodDNSConfig) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodDNSConfig) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodDNSConfigRaw is a plain Go struct representation of PodDNSConfig.
// Zero values are not set (sparse encoding).
type PodDNSConfigRaw struct {
    Nameservers []string
    Searches []string
    Options []*PodDNSConfigOptionRaw
}

// NewPodDNSConfigFromRaw creates a new PodDNSConfig from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodDNSConfigFromRaw(ctx context.Context, raw PodDNSConfigRaw) PodDNSConfig {
    x := NewPodDNSConfig(ctx)
    if raw.Nameservers != nil {
        x.SetNameservers(raw.Nameservers...)
    }
    if raw.Searches != nil {
        x.SetSearches(raw.Searches...)
    }
    if raw.Options != nil {
        list := x.OptionsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Options))
        for _, r := range raw.Options {
            if r != nil {
                items = append(items, NewPodDNSConfigOptionFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodDNSConfig) ToRaw(ctx context.Context) PodDNSConfigRaw {
    raw := PodDNSConfigRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Nameservers = l.(*segment.Strings).Slice()
    } else if x.s.HasField(0) {
        raw.Nameservers = x.Nameservers().Slice()
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.Searches = l.(*segment.Strings).Slice()
    } else if x.s.HasField(1) {
        raw.Searches = x.Searches().Slice()
    }
    if l := x.s.GetList(2); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Options = make([]*PodDNSConfigOptionRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodDNSConfigOption{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Options[i] = &itemRaw
        }
    } else if x.s.HasField(2) {
        list := x.OptionsList(ctx)
        raw.Options = make([]*PodDNSConfigOptionRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodDNSConfigOption{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Options[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodDNSConfig) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(60)
}

// PodDNSConfigOption defines DNS resolver options.
type PodDNSConfigOption struct {
   s *segment.Struct
}

// NewPodDNSConfigOption creates a new pooled instance of PodDNSConfigOption.
// Call Release() when done to return it to the pool for reuse.
func NewPodDNSConfigOption(ctx context.Context) PodDNSConfigOption {
    s := segment.New(ctx, XXXMappingPodDNSConfigOption)
    s.SetIsSetEnabled(true)
    return PodDNSConfigOption{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodDNSConfigOption) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodDNSConfigOptionFrom creates a new PodDNSConfigOption from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodDNSConfigOptionFrom(s *segment.Struct) PodDNSConfigOption {
    return PodDNSConfigOption{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodDNSConfigOption) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodDNSConfigOption) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodDNSConfigOption) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodDNSConfigOption) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodDNSConfigOption) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodDNSConfigOption) Name() string {
    return segment.GetString(x.s, 0)
}

func (x PodDNSConfigOption) SetName(value string) PodDNSConfigOption {
    segment.SetString(x.s, 0, value)
    return x
}
func (x PodDNSConfigOption) IsSetName() bool{
    return x.s.HasField(0)
}

func (x PodDNSConfigOption) Value() string {
    return segment.GetString(x.s, 1)
}

func (x PodDNSConfigOption) SetValue(value string) PodDNSConfigOption {
    segment.SetString(x.s, 1, value)
    return x
}
func (x PodDNSConfigOption) IsSetValue() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodDNSConfigOption) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodDNSConfigOption) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodDNSConfigOption) XXXTypeHash() [16]byte {
    return XXXTypeHashPodDNSConfigOption
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodDNSConfigOption) SetRecording(enabled bool) PodDNSConfigOption {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodDNSConfigOption) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodDNSConfigOption) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodDNSConfigOption) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodDNSConfigOptionRaw is a plain Go struct representation of PodDNSConfigOption.
// Zero values are not set (sparse encoding).
type PodDNSConfigOptionRaw struct {
    Name string
    Value string
}

// NewPodDNSConfigOptionFromRaw creates a new PodDNSConfigOption from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodDNSConfigOptionFromRaw(ctx context.Context, raw PodDNSConfigOptionRaw) PodDNSConfigOption {
    x := NewPodDNSConfigOption(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Value != "" {
        x.SetValue(raw.Value)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodDNSConfigOption) ToRaw(ctx context.Context) PodDNSConfigOptionRaw {
    raw := PodDNSConfigOptionRaw{}
    raw.Name = x.Name()
    raw.Value = x.Value()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodDNSConfigOption) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(61)
}

// PodIP represents a single IP address allocated to the pod.
type PodIP struct {
   s *segment.Struct
}

// NewPodIP creates a new pooled instance of PodIP.
// Call Release() when done to return it to the pool for reuse.
func NewPodIP(ctx context.Context) PodIP {
    s := segment.New(ctx, XXXMappingPodIP)
    s.SetIsSetEnabled(true)
    return PodIP{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodIP) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodIPFrom creates a new PodIP from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodIPFrom(s *segment.Struct) PodIP {
    return PodIP{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodIP) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodIP) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodIP) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodIP) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodIP) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodIP) Ip() string {
    return segment.GetString(x.s, 0)
}

func (x PodIP) SetIp(value string) PodIP {
    segment.SetString(x.s, 0, value)
    return x
}
func (x PodIP) IsSetIp() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodIP) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodIP) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodIP) XXXTypeHash() [16]byte {
    return XXXTypeHashPodIP
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodIP) SetRecording(enabled bool) PodIP {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodIP) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodIP) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodIP) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodIPRaw is a plain Go struct representation of PodIP.
// Zero values are not set (sparse encoding).
type PodIPRaw struct {
    Ip string
}

// NewPodIPFromRaw creates a new PodIP from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodIPFromRaw(ctx context.Context, raw PodIPRaw) PodIP {
    x := NewPodIP(ctx)
    if raw.Ip != "" {
        x.SetIp(raw.Ip)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodIP) ToRaw(ctx context.Context) PodIPRaw {
    raw := PodIPRaw{}
    raw.Ip = x.Ip()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodIP) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(62)
}

// PodOS defines the OS parameters of a pod.
type PodOS struct {
   s *segment.Struct
}

// NewPodOS creates a new pooled instance of PodOS.
// Call Release() when done to return it to the pool for reuse.
func NewPodOS(ctx context.Context) PodOS {
    s := segment.New(ctx, XXXMappingPodOS)
    s.SetIsSetEnabled(true)
    return PodOS{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodOS) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodOSFrom creates a new PodOS from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodOSFrom(s *segment.Struct) PodOS {
    return PodOS{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodOS) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodOS) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodOS) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodOS) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodOS) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodOS) Name() string {
    return segment.GetString(x.s, 0)
}

func (x PodOS) SetName(value string) PodOS {
    segment.SetString(x.s, 0, value)
    return x
}
func (x PodOS) IsSetName() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodOS) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodOS) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodOS) XXXTypeHash() [16]byte {
    return XXXTypeHashPodOS
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodOS) SetRecording(enabled bool) PodOS {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodOS) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodOS) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodOS) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodOSRaw is a plain Go struct representation of PodOS.
// Zero values are not set (sparse encoding).
type PodOSRaw struct {
    Name string
}

// NewPodOSFromRaw creates a new PodOS from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodOSFromRaw(ctx context.Context, raw PodOSRaw) PodOS {
    x := NewPodOS(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodOS) ToRaw(ctx context.Context) PodOSRaw {
    raw := PodOSRaw{}
    raw.Name = x.Name()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodOS) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(63)
}

// PodReadinessGate contains the reference to a pod condition.
type PodReadinessGate struct {
   s *segment.Struct
}

// NewPodReadinessGate creates a new pooled instance of PodReadinessGate.
// Call Release() when done to return it to the pool for reuse.
func NewPodReadinessGate(ctx context.Context) PodReadinessGate {
    s := segment.New(ctx, XXXMappingPodReadinessGate)
    s.SetIsSetEnabled(true)
    return PodReadinessGate{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodReadinessGate) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodReadinessGateFrom creates a new PodReadinessGate from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodReadinessGateFrom(s *segment.Struct) PodReadinessGate {
    return PodReadinessGate{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodReadinessGate) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodReadinessGate) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodReadinessGate) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodReadinessGate) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodReadinessGate) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodReadinessGate) ConditionType() PodConditionType {
    return PodConditionType(segment.GetUint8(x.s, 0))
}

func (x PodReadinessGate) SetConditionType(value PodConditionType) PodReadinessGate {
    segment.SetUint8(x.s, 0, uint8(value))
    return x
}
func (x PodReadinessGate) IsSetConditionType() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodReadinessGate) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodReadinessGate) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodReadinessGate) XXXTypeHash() [16]byte {
    return XXXTypeHashPodReadinessGate
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodReadinessGate) SetRecording(enabled bool) PodReadinessGate {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodReadinessGate) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodReadinessGate) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodReadinessGate) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodReadinessGateRaw is a plain Go struct representation of PodReadinessGate.
// Zero values are not set (sparse encoding).
type PodReadinessGateRaw struct {
    ConditionType PodConditionType
}

// NewPodReadinessGateFromRaw creates a new PodReadinessGate from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodReadinessGateFromRaw(ctx context.Context, raw PodReadinessGateRaw) PodReadinessGate {
    x := NewPodReadinessGate(ctx)
    if raw.ConditionType != 0 {
        x.SetConditionType(raw.ConditionType)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodReadinessGate) ToRaw(ctx context.Context) PodReadinessGateRaw {
    raw := PodReadinessGateRaw{}
    raw.ConditionType = x.ConditionType()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodReadinessGate) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(64)
}

// PodResourceClaim references a ResourceClaim.
type PodResourceClaim struct {
   s *segment.Struct
}

// NewPodResourceClaim creates a new pooled instance of PodResourceClaim.
// Call Release() when done to return it to the pool for reuse.
func NewPodResourceClaim(ctx context.Context) PodResourceClaim {
    s := segment.New(ctx, XXXMappingPodResourceClaim)
    s.SetIsSetEnabled(true)
    return PodResourceClaim{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodResourceClaim) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodResourceClaimFrom creates a new PodResourceClaim from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodResourceClaimFrom(s *segment.Struct) PodResourceClaim {
    return PodResourceClaim{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodResourceClaim) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodResourceClaim) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodResourceClaim) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodResourceClaim) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodResourceClaim) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodResourceClaim) Name() string {
    return segment.GetString(x.s, 0)
}

func (x PodResourceClaim) SetName(value string) PodResourceClaim {
    segment.SetString(x.s, 0, value)
    return x
}
func (x PodResourceClaim) IsSetName() bool{
    return x.s.HasField(0)
}

func (x PodResourceClaim) ResourceClaimName() string {
    return segment.GetString(x.s, 1)
}

func (x PodResourceClaim) SetResourceClaimName(value string) PodResourceClaim {
    segment.SetString(x.s, 1, value)
    return x
}
func (x PodResourceClaim) IsSetResourceClaimName() bool{
    return x.s.HasField(1)
}

func (x PodResourceClaim) ResourceClaimTemplateName() string {
    return segment.GetString(x.s, 2)
}

func (x PodResourceClaim) SetResourceClaimTemplateName(value string) PodResourceClaim {
    segment.SetString(x.s, 2, value)
    return x
}
func (x PodResourceClaim) IsSetResourceClaimTemplateName() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodResourceClaim) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodResourceClaim) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodResourceClaim) XXXTypeHash() [16]byte {
    return XXXTypeHashPodResourceClaim
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodResourceClaim) SetRecording(enabled bool) PodResourceClaim {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodResourceClaim) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodResourceClaim) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodResourceClaim) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodResourceClaimRaw is a plain Go struct representation of PodResourceClaim.
// Zero values are not set (sparse encoding).
type PodResourceClaimRaw struct {
    Name string
    ResourceClaimName string
    ResourceClaimTemplateName string
}

// NewPodResourceClaimFromRaw creates a new PodResourceClaim from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodResourceClaimFromRaw(ctx context.Context, raw PodResourceClaimRaw) PodResourceClaim {
    x := NewPodResourceClaim(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.ResourceClaimName != "" {
        x.SetResourceClaimName(raw.ResourceClaimName)
    }
    if raw.ResourceClaimTemplateName != "" {
        x.SetResourceClaimTemplateName(raw.ResourceClaimTemplateName)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodResourceClaim) ToRaw(ctx context.Context) PodResourceClaimRaw {
    raw := PodResourceClaimRaw{}
    raw.Name = x.Name()
    raw.ResourceClaimName = x.ResourceClaimName()
    raw.ResourceClaimTemplateName = x.ResourceClaimTemplateName()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodResourceClaim) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(65)
}

// PodResourceClaimStatus is stored in the PodStatus for each PodResourceClaim.
type PodResourceClaimStatus struct {
   s *segment.Struct
}

// NewPodResourceClaimStatus creates a new pooled instance of PodResourceClaimStatus.
// Call Release() when done to return it to the pool for reuse.
func NewPodResourceClaimStatus(ctx context.Context) PodResourceClaimStatus {
    s := segment.New(ctx, XXXMappingPodResourceClaimStatus)
    s.SetIsSetEnabled(true)
    return PodResourceClaimStatus{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodResourceClaimStatus) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodResourceClaimStatusFrom creates a new PodResourceClaimStatus from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodResourceClaimStatusFrom(s *segment.Struct) PodResourceClaimStatus {
    return PodResourceClaimStatus{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodResourceClaimStatus) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodResourceClaimStatus) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodResourceClaimStatus) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodResourceClaimStatus) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodResourceClaimStatus) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodResourceClaimStatus) Name() string {
    return segment.GetString(x.s, 0)
}

func (x PodResourceClaimStatus) SetName(value string) PodResourceClaimStatus {
    segment.SetString(x.s, 0, value)
    return x
}
func (x PodResourceClaimStatus) IsSetName() bool{
    return x.s.HasField(0)
}

func (x PodResourceClaimStatus) ResourceClaimName() string {
    return segment.GetString(x.s, 1)
}

func (x PodResourceClaimStatus) SetResourceClaimName(value string) PodResourceClaimStatus {
    segment.SetString(x.s, 1, value)
    return x
}
func (x PodResourceClaimStatus) IsSetResourceClaimName() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodResourceClaimStatus) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodResourceClaimStatus) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodResourceClaimStatus) XXXTypeHash() [16]byte {
    return XXXTypeHashPodResourceClaimStatus
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodResourceClaimStatus) SetRecording(enabled bool) PodResourceClaimStatus {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodResourceClaimStatus) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodResourceClaimStatus) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodResourceClaimStatus) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodResourceClaimStatusRaw is a plain Go struct representation of PodResourceClaimStatus.
// Zero values are not set (sparse encoding).
type PodResourceClaimStatusRaw struct {
    Name string
    ResourceClaimName string
}

// NewPodResourceClaimStatusFromRaw creates a new PodResourceClaimStatus from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodResourceClaimStatusFromRaw(ctx context.Context, raw PodResourceClaimStatusRaw) PodResourceClaimStatus {
    x := NewPodResourceClaimStatus(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.ResourceClaimName != "" {
        x.SetResourceClaimName(raw.ResourceClaimName)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodResourceClaimStatus) ToRaw(ctx context.Context) PodResourceClaimStatusRaw {
    raw := PodResourceClaimStatusRaw{}
    raw.Name = x.Name()
    raw.ResourceClaimName = x.ResourceClaimName()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodResourceClaimStatus) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(66)
}

// PodSchedulingGate is associated to a Pod to guard its scheduling.
type PodSchedulingGate struct {
   s *segment.Struct
}

// NewPodSchedulingGate creates a new pooled instance of PodSchedulingGate.
// Call Release() when done to return it to the pool for reuse.
func NewPodSchedulingGate(ctx context.Context) PodSchedulingGate {
    s := segment.New(ctx, XXXMappingPodSchedulingGate)
    s.SetIsSetEnabled(true)
    return PodSchedulingGate{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodSchedulingGate) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodSchedulingGateFrom creates a new PodSchedulingGate from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodSchedulingGateFrom(s *segment.Struct) PodSchedulingGate {
    return PodSchedulingGate{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodSchedulingGate) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodSchedulingGate) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodSchedulingGate) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodSchedulingGate) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodSchedulingGate) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodSchedulingGate) Name() string {
    return segment.GetString(x.s, 0)
}

func (x PodSchedulingGate) SetName(value string) PodSchedulingGate {
    segment.SetString(x.s, 0, value)
    return x
}
func (x PodSchedulingGate) IsSetName() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodSchedulingGate) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodSchedulingGate) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodSchedulingGate) XXXTypeHash() [16]byte {
    return XXXTypeHashPodSchedulingGate
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodSchedulingGate) SetRecording(enabled bool) PodSchedulingGate {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodSchedulingGate) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodSchedulingGate) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodSchedulingGate) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodSchedulingGateRaw is a plain Go struct representation of PodSchedulingGate.
// Zero values are not set (sparse encoding).
type PodSchedulingGateRaw struct {
    Name string
}

// NewPodSchedulingGateFromRaw creates a new PodSchedulingGate from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodSchedulingGateFromRaw(ctx context.Context, raw PodSchedulingGateRaw) PodSchedulingGate {
    x := NewPodSchedulingGate(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodSchedulingGate) ToRaw(ctx context.Context) PodSchedulingGateRaw {
    raw := PodSchedulingGateRaw{}
    raw.Name = x.Name()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodSchedulingGate) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(67)
}

// PodSecurityContext holds pod-level security attributes.
type PodSecurityContext struct {
   s *segment.Struct
}

// NewPodSecurityContext creates a new pooled instance of PodSecurityContext.
// Call Release() when done to return it to the pool for reuse.
func NewPodSecurityContext(ctx context.Context) PodSecurityContext {
    s := segment.New(ctx, XXXMappingPodSecurityContext)
    s.SetIsSetEnabled(true)
    return PodSecurityContext{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodSecurityContext) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodSecurityContextFrom creates a new PodSecurityContext from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodSecurityContextFrom(s *segment.Struct) PodSecurityContext {
    return PodSecurityContext{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodSecurityContext) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodSecurityContext) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodSecurityContext) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodSecurityContext) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodSecurityContext) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodSecurityContext) SeLinuxOptions() SELinuxOptions {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingSELinuxOptions)
    return SELinuxOptions{s: s}
}

func (x PodSecurityContext) SetSeLinuxOptions(value SELinuxOptions) PodSecurityContext {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x PodSecurityContext) IsSetSeLinuxOptions() bool{
    return x.s.HasField(0)
}

func (x PodSecurityContext) WindowsOptions() WindowsSecurityContextOptions {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingWindowsSecurityContextOptions)
    return WindowsSecurityContextOptions{s: s}
}

func (x PodSecurityContext) SetWindowsOptions(value WindowsSecurityContextOptions) PodSecurityContext {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x PodSecurityContext) IsSetWindowsOptions() bool{
    return x.s.HasField(1)
}

func (x PodSecurityContext) RunAsUser() int64 {
    return segment.GetInt64(x.s, 2)
}

func (x PodSecurityContext) SetRunAsUser(value int64) PodSecurityContext {
    segment.SetInt64(x.s, 2, value)
    return x
}
func (x PodSecurityContext) IsSetRunAsUser() bool{
    return x.s.HasField(2)
}

func (x PodSecurityContext) RunAsGroup() int64 {
    return segment.GetInt64(x.s, 3)
}

func (x PodSecurityContext) SetRunAsGroup(value int64) PodSecurityContext {
    segment.SetInt64(x.s, 3, value)
    return x
}
func (x PodSecurityContext) IsSetRunAsGroup() bool{
    return x.s.HasField(3)
}

func (x PodSecurityContext) RunAsNonRoot() bool {
    return segment.GetBool(x.s, 4)
}

func (x PodSecurityContext) SetRunAsNonRoot(value bool) PodSecurityContext {
    segment.SetBool(x.s, 4, value)
    return x
}
func (x PodSecurityContext) IsSetRunAsNonRoot() bool{
    return x.s.HasField(4)
}


func (x PodSecurityContext) SupplementalGroups() *segment.Numbers[int64] {
    // Try to get cached or parse from segment
    if nums := segment.GetListNumbers[int64](x.s, 5); nums != nil {
        return nums
    }
    // Create new empty list if no data exists
    nums := segment.NewNumbers[int64](x.s, 5)
    return nums
}
func (x PodSecurityContext) IsSetSupplementalGroups() bool{
    return x.s.HasField(5)
}

// SetSupplementalGroups replaces all values in the numeric list.
func (x PodSecurityContext) SetSupplementalGroups(v ...int64) PodSecurityContext {
    nums := x.SupplementalGroups()
    nums.SetAll(v)
    return x
}

func (x PodSecurityContext) SupplementalGroupsPolicy() SupplementalGroupsPolicy {
    return SupplementalGroupsPolicy(segment.GetUint8(x.s, 6))
}

func (x PodSecurityContext) SetSupplementalGroupsPolicy(value SupplementalGroupsPolicy) PodSecurityContext {
    segment.SetUint8(x.s, 6, uint8(value))
    return x
}
func (x PodSecurityContext) IsSetSupplementalGroupsPolicy() bool{
    return x.s.HasField(6)
}

func (x PodSecurityContext) FsGroup() int64 {
    return segment.GetInt64(x.s, 7)
}

func (x PodSecurityContext) SetFsGroup(value int64) PodSecurityContext {
    segment.SetInt64(x.s, 7, value)
    return x
}
func (x PodSecurityContext) IsSetFsGroup() bool{
    return x.s.HasField(7)
}

// SysctlsList returns the underlying Structs list for iteration.
// Use NewSysctl() to create items and Append to add them.
func (x PodSecurityContext) SysctlsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 8, XXXMappingSysctl); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 8, XXXMappingSysctl)
    return structs
}

// SysctlsLen returns the number of items in the list.
func (x PodSecurityContext) SysctlsLen(ctx context.Context) int {
    return x.SysctlsList(ctx).Len()
}

// SysctlsGet returns the item at the given index.
func (x PodSecurityContext) SysctlsGet(ctx context.Context, index int) Sysctl {
    s := x.SysctlsList(ctx).Get(index)
    return Sysctl{s: s}
}

// SysctlsAppend appends items to the list.
func (x PodSecurityContext) SysctlsAppend(ctx context.Context, values ...Sysctl) {
    list := x.SysctlsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// SysctlsAppendRaw appends items to the list using Raw struct representations.
func (x PodSecurityContext) SysctlsAppendRaw(ctx context.Context, values ...*SysctlRaw) {
    list := x.SysctlsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewSysctlFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSecurityContext) IsSetSysctls() bool{
    return x.s.HasField(8)
}

func (x PodSecurityContext) FsGroupChangePolicy() PodFSGroupChangePolicy {
    return PodFSGroupChangePolicy(segment.GetUint8(x.s, 9))
}

func (x PodSecurityContext) SetFsGroupChangePolicy(value PodFSGroupChangePolicy) PodSecurityContext {
    segment.SetUint8(x.s, 9, uint8(value))
    return x
}
func (x PodSecurityContext) IsSetFsGroupChangePolicy() bool{
    return x.s.HasField(9)
}

func (x PodSecurityContext) SeccompProfile() SeccompProfile {
    s := segment.GetNestedStruct(x.s, 10, XXXMappingSeccompProfile)
    return SeccompProfile{s: s}
}

func (x PodSecurityContext) SetSeccompProfile(value SeccompProfile) PodSecurityContext {
    segment.SetNestedStruct(x.s, 10, value.XXXGetStruct())
    return x
}
func (x PodSecurityContext) IsSetSeccompProfile() bool{
    return x.s.HasField(10)
}

func (x PodSecurityContext) AppArmorProfile() AppArmorProfile {
    s := segment.GetNestedStruct(x.s, 11, XXXMappingAppArmorProfile)
    return AppArmorProfile{s: s}
}

func (x PodSecurityContext) SetAppArmorProfile(value AppArmorProfile) PodSecurityContext {
    segment.SetNestedStruct(x.s, 11, value.XXXGetStruct())
    return x
}
func (x PodSecurityContext) IsSetAppArmorProfile() bool{
    return x.s.HasField(11)
}

func (x PodSecurityContext) SeLinuxChangePolicy() PodSELinuxChangePolicy {
    return PodSELinuxChangePolicy(segment.GetUint8(x.s, 12))
}

func (x PodSecurityContext) SetSeLinuxChangePolicy(value PodSELinuxChangePolicy) PodSecurityContext {
    segment.SetUint8(x.s, 12, uint8(value))
    return x
}
func (x PodSecurityContext) IsSetSeLinuxChangePolicy() bool{
    return x.s.HasField(12)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodSecurityContext) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodSecurityContext) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodSecurityContext) XXXTypeHash() [16]byte {
    return XXXTypeHashPodSecurityContext
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodSecurityContext) SetRecording(enabled bool) PodSecurityContext {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodSecurityContext) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodSecurityContext) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodSecurityContext) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodSecurityContextRaw is a plain Go struct representation of PodSecurityContext.
// Zero values are not set (sparse encoding).
type PodSecurityContextRaw struct {
    SeLinuxOptions *SELinuxOptionsRaw
    WindowsOptions *WindowsSecurityContextOptionsRaw
    RunAsUser int64
    RunAsGroup int64
    RunAsNonRoot bool
    SupplementalGroups []int64
    SupplementalGroupsPolicy SupplementalGroupsPolicy
    FsGroup int64
    Sysctls []*SysctlRaw
    FsGroupChangePolicy PodFSGroupChangePolicy
    SeccompProfile *SeccompProfileRaw
    AppArmorProfile *AppArmorProfileRaw
    SeLinuxChangePolicy PodSELinuxChangePolicy
}

// NewPodSecurityContextFromRaw creates a new PodSecurityContext from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodSecurityContextFromRaw(ctx context.Context, raw PodSecurityContextRaw) PodSecurityContext {
    x := NewPodSecurityContext(ctx)
    if raw.SeLinuxOptions != nil {
        x.SetSeLinuxOptions(NewSELinuxOptionsFromRaw(ctx, *raw.SeLinuxOptions))
    }
    if raw.WindowsOptions != nil {
        x.SetWindowsOptions(NewWindowsSecurityContextOptionsFromRaw(ctx, *raw.WindowsOptions))
    }
    if raw.RunAsUser != 0 {
        x.SetRunAsUser(raw.RunAsUser)
    }
    if raw.RunAsGroup != 0 {
        x.SetRunAsGroup(raw.RunAsGroup)
    }
    if raw.RunAsNonRoot {
        x.SetRunAsNonRoot(raw.RunAsNonRoot)
    }
    if raw.SupplementalGroups != nil {
        x.SetSupplementalGroups(raw.SupplementalGroups...)
    }
    if raw.SupplementalGroupsPolicy != 0 {
        x.SetSupplementalGroupsPolicy(raw.SupplementalGroupsPolicy)
    }
    if raw.FsGroup != 0 {
        x.SetFsGroup(raw.FsGroup)
    }
    if raw.Sysctls != nil {
        list := x.SysctlsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Sysctls))
        for _, r := range raw.Sysctls {
            if r != nil {
                items = append(items, NewSysctlFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.FsGroupChangePolicy != 0 {
        x.SetFsGroupChangePolicy(raw.FsGroupChangePolicy)
    }
    if raw.SeccompProfile != nil {
        x.SetSeccompProfile(NewSeccompProfileFromRaw(ctx, *raw.SeccompProfile))
    }
    if raw.AppArmorProfile != nil {
        x.SetAppArmorProfile(NewAppArmorProfileFromRaw(ctx, *raw.AppArmorProfile))
    }
    if raw.SeLinuxChangePolicy != 0 {
        x.SetSeLinuxChangePolicy(raw.SeLinuxChangePolicy)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodSecurityContext) ToRaw(ctx context.Context) PodSecurityContextRaw {
    raw := PodSecurityContextRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.SeLinuxOptions().ToRaw(ctx)
        raw.SeLinuxOptions = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.WindowsOptions().ToRaw(ctx)
        raw.WindowsOptions = &nestedRaw
    }
    raw.RunAsUser = x.RunAsUser()
    raw.RunAsGroup = x.RunAsGroup()
    raw.RunAsNonRoot = x.RunAsNonRoot()
    if l := x.s.GetList(5); l != nil && l.(*segment.Numbers[int64]).Len() > 0 {
        raw.SupplementalGroups = l.(*segment.Numbers[int64]).Slice()
    } else if x.s.HasField(5) {
        raw.SupplementalGroups = x.SupplementalGroups().Slice()
    }
    raw.SupplementalGroupsPolicy = x.SupplementalGroupsPolicy()
    raw.FsGroup = x.FsGroup()
    if l := x.s.GetList(8); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Sysctls = make([]*SysctlRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Sysctl{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Sysctls[i] = &itemRaw
        }
    } else if x.s.HasField(8) {
        list := x.SysctlsList(ctx)
        raw.Sysctls = make([]*SysctlRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Sysctl{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Sysctls[i] = &itemRaw
        }
    }
    raw.FsGroupChangePolicy = x.FsGroupChangePolicy()
    if x.s.HasField(10) {
        nestedRaw := x.SeccompProfile().ToRaw(ctx)
        raw.SeccompProfile = &nestedRaw
    }
    if x.s.HasField(11) {
        nestedRaw := x.AppArmorProfile().ToRaw(ctx)
        raw.AppArmorProfile = &nestedRaw
    }
    raw.SeLinuxChangePolicy = x.SeLinuxChangePolicy()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodSecurityContext) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(68)
}

// PodSpec is a description of a pod.
type PodSpec struct {
   s *segment.Struct
}

// NewPodSpec creates a new pooled instance of PodSpec.
// Call Release() when done to return it to the pool for reuse.
func NewPodSpec(ctx context.Context) PodSpec {
    s := segment.New(ctx, XXXMappingPodSpec)
    s.SetIsSetEnabled(true)
    return PodSpec{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodSpec) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodSpecFrom creates a new PodSpec from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodSpecFrom(s *segment.Struct) PodSpec {
    return PodSpec{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodSpec) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodSpec) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodSpec) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodSpec) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodSpec) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// VolumesList returns the underlying Structs list for iteration.
// Use NewVolume() to create items and Append to add them.
func (x PodSpec) VolumesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingVolume); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingVolume)
    return structs
}

// VolumesLen returns the number of items in the list.
func (x PodSpec) VolumesLen(ctx context.Context) int {
    return x.VolumesList(ctx).Len()
}

// VolumesGet returns the item at the given index.
func (x PodSpec) VolumesGet(ctx context.Context, index int) Volume {
    s := x.VolumesList(ctx).Get(index)
    return Volume{s: s}
}

// VolumesAppend appends items to the list.
func (x PodSpec) VolumesAppend(ctx context.Context, values ...Volume) {
    list := x.VolumesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// VolumesAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) VolumesAppendRaw(ctx context.Context, values ...*VolumeRaw) {
    list := x.VolumesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewVolumeFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetVolumes() bool{
    return x.s.HasField(0)
}

// InitContainersList returns the underlying Structs list for iteration.
// Use NewContainer() to create items and Append to add them.
func (x PodSpec) InitContainersList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingContainer); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingContainer)
    return structs
}

// InitContainersLen returns the number of items in the list.
func (x PodSpec) InitContainersLen(ctx context.Context) int {
    return x.InitContainersList(ctx).Len()
}

// InitContainersGet returns the item at the given index.
func (x PodSpec) InitContainersGet(ctx context.Context, index int) Container {
    s := x.InitContainersList(ctx).Get(index)
    return Container{s: s}
}

// InitContainersAppend appends items to the list.
func (x PodSpec) InitContainersAppend(ctx context.Context, values ...Container) {
    list := x.InitContainersList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// InitContainersAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) InitContainersAppendRaw(ctx context.Context, values ...*ContainerRaw) {
    list := x.InitContainersList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewContainerFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetInitContainers() bool{
    return x.s.HasField(1)
}

// ContainersList returns the underlying Structs list for iteration.
// Use NewContainer() to create items and Append to add them.
func (x PodSpec) ContainersList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 2, XXXMappingContainer); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 2, XXXMappingContainer)
    return structs
}

// ContainersLen returns the number of items in the list.
func (x PodSpec) ContainersLen(ctx context.Context) int {
    return x.ContainersList(ctx).Len()
}

// ContainersGet returns the item at the given index.
func (x PodSpec) ContainersGet(ctx context.Context, index int) Container {
    s := x.ContainersList(ctx).Get(index)
    return Container{s: s}
}

// ContainersAppend appends items to the list.
func (x PodSpec) ContainersAppend(ctx context.Context, values ...Container) {
    list := x.ContainersList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ContainersAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) ContainersAppendRaw(ctx context.Context, values ...*ContainerRaw) {
    list := x.ContainersList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewContainerFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetContainers() bool{
    return x.s.HasField(2)
}

// EphemeralContainersList returns the underlying Structs list for iteration.
// Use NewEphemeralContainer() to create items and Append to add them.
func (x PodSpec) EphemeralContainersList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 3, XXXMappingEphemeralContainer); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 3, XXXMappingEphemeralContainer)
    return structs
}

// EphemeralContainersLen returns the number of items in the list.
func (x PodSpec) EphemeralContainersLen(ctx context.Context) int {
    return x.EphemeralContainersList(ctx).Len()
}

// EphemeralContainersGet returns the item at the given index.
func (x PodSpec) EphemeralContainersGet(ctx context.Context, index int) EphemeralContainer {
    s := x.EphemeralContainersList(ctx).Get(index)
    return EphemeralContainer{s: s}
}

// EphemeralContainersAppend appends items to the list.
func (x PodSpec) EphemeralContainersAppend(ctx context.Context, values ...EphemeralContainer) {
    list := x.EphemeralContainersList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// EphemeralContainersAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) EphemeralContainersAppendRaw(ctx context.Context, values ...*EphemeralContainerRaw) {
    list := x.EphemeralContainersList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewEphemeralContainerFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetEphemeralContainers() bool{
    return x.s.HasField(3)
}

func (x PodSpec) RestartPolicy() RestartPolicy {
    return RestartPolicy(segment.GetUint8(x.s, 4))
}

func (x PodSpec) SetRestartPolicy(value RestartPolicy) PodSpec {
    segment.SetUint8(x.s, 4, uint8(value))
    return x
}
func (x PodSpec) IsSetRestartPolicy() bool{
    return x.s.HasField(4)
}

func (x PodSpec) TerminationGracePeriodSeconds() int64 {
    return segment.GetInt64(x.s, 5)
}

func (x PodSpec) SetTerminationGracePeriodSeconds(value int64) PodSpec {
    segment.SetInt64(x.s, 5, value)
    return x
}
func (x PodSpec) IsSetTerminationGracePeriodSeconds() bool{
    return x.s.HasField(5)
}

func (x PodSpec) ActiveDeadlineSeconds() int64 {
    return segment.GetInt64(x.s, 6)
}

func (x PodSpec) SetActiveDeadlineSeconds(value int64) PodSpec {
    segment.SetInt64(x.s, 6, value)
    return x
}
func (x PodSpec) IsSetActiveDeadlineSeconds() bool{
    return x.s.HasField(6)
}

func (x PodSpec) DnsPolicy() DNSPolicy {
    return DNSPolicy(segment.GetUint8(x.s, 7))
}

func (x PodSpec) SetDnsPolicy(value DNSPolicy) PodSpec {
    segment.SetUint8(x.s, 7, uint8(value))
    return x
}
func (x PodSpec) IsSetDnsPolicy() bool{
    return x.s.HasField(7)
}

// NodeSelectorList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x PodSpec) NodeSelectorList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 8, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 8, XXXMappingKeyValue)
    return structs
}

// NodeSelectorLen returns the number of items in the list.
func (x PodSpec) NodeSelectorLen(ctx context.Context) int {
    return x.NodeSelectorList(ctx).Len()
}

// NodeSelectorGet returns the item at the given index.
func (x PodSpec) NodeSelectorGet(ctx context.Context, index int) KeyValue {
    s := x.NodeSelectorList(ctx).Get(index)
    return KeyValue{s: s}
}

// NodeSelectorAppend appends items to the list.
func (x PodSpec) NodeSelectorAppend(ctx context.Context, values ...KeyValue) {
    list := x.NodeSelectorList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// NodeSelectorAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) NodeSelectorAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.NodeSelectorList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetNodeSelector() bool{
    return x.s.HasField(8)
}

func (x PodSpec) ServiceAccountName() string {
    return segment.GetString(x.s, 9)
}

func (x PodSpec) SetServiceAccountName(value string) PodSpec {
    segment.SetString(x.s, 9, value)
    return x
}
func (x PodSpec) IsSetServiceAccountName() bool{
    return x.s.HasField(9)
}

func (x PodSpec) AutomountServiceAccountToken() bool {
    return segment.GetBool(x.s, 10)
}

func (x PodSpec) SetAutomountServiceAccountToken(value bool) PodSpec {
    segment.SetBool(x.s, 10, value)
    return x
}
func (x PodSpec) IsSetAutomountServiceAccountToken() bool{
    return x.s.HasField(10)
}

func (x PodSpec) NodeName() string {
    return segment.GetString(x.s, 11)
}

func (x PodSpec) SetNodeName(value string) PodSpec {
    segment.SetString(x.s, 11, value)
    return x
}
func (x PodSpec) IsSetNodeName() bool{
    return x.s.HasField(11)
}

func (x PodSpec) HostNetwork() bool {
    return segment.GetBool(x.s, 12)
}

func (x PodSpec) SetHostNetwork(value bool) PodSpec {
    segment.SetBool(x.s, 12, value)
    return x
}
func (x PodSpec) IsSetHostNetwork() bool{
    return x.s.HasField(12)
}

func (x PodSpec) HostPid() bool {
    return segment.GetBool(x.s, 13)
}

func (x PodSpec) SetHostPid(value bool) PodSpec {
    segment.SetBool(x.s, 13, value)
    return x
}
func (x PodSpec) IsSetHostPid() bool{
    return x.s.HasField(13)
}

func (x PodSpec) HostIpc() bool {
    return segment.GetBool(x.s, 14)
}

func (x PodSpec) SetHostIpc(value bool) PodSpec {
    segment.SetBool(x.s, 14, value)
    return x
}
func (x PodSpec) IsSetHostIpc() bool{
    return x.s.HasField(14)
}

func (x PodSpec) ShareProcessNamespace() bool {
    return segment.GetBool(x.s, 15)
}

func (x PodSpec) SetShareProcessNamespace(value bool) PodSpec {
    segment.SetBool(x.s, 15, value)
    return x
}
func (x PodSpec) IsSetShareProcessNamespace() bool{
    return x.s.HasField(15)
}

func (x PodSpec) SecurityContext() PodSecurityContext {
    s := segment.GetNestedStruct(x.s, 16, XXXMappingPodSecurityContext)
    return PodSecurityContext{s: s}
}

func (x PodSpec) SetSecurityContext(value PodSecurityContext) PodSpec {
    segment.SetNestedStruct(x.s, 16, value.XXXGetStruct())
    return x
}
func (x PodSpec) IsSetSecurityContext() bool{
    return x.s.HasField(16)
}

// ImagePullSecretsList returns the underlying Structs list for iteration.
// Use NewLocalObjectReference() to create items and Append to add them.
func (x PodSpec) ImagePullSecretsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 17, XXXMappingLocalObjectReference); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 17, XXXMappingLocalObjectReference)
    return structs
}

// ImagePullSecretsLen returns the number of items in the list.
func (x PodSpec) ImagePullSecretsLen(ctx context.Context) int {
    return x.ImagePullSecretsList(ctx).Len()
}

// ImagePullSecretsGet returns the item at the given index.
func (x PodSpec) ImagePullSecretsGet(ctx context.Context, index int) LocalObjectReference {
    s := x.ImagePullSecretsList(ctx).Get(index)
    return LocalObjectReference{s: s}
}

// ImagePullSecretsAppend appends items to the list.
func (x PodSpec) ImagePullSecretsAppend(ctx context.Context, values ...LocalObjectReference) {
    list := x.ImagePullSecretsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ImagePullSecretsAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) ImagePullSecretsAppendRaw(ctx context.Context, values ...*LocalObjectReferenceRaw) {
    list := x.ImagePullSecretsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewLocalObjectReferenceFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetImagePullSecrets() bool{
    return x.s.HasField(17)
}

func (x PodSpec) Hostname() string {
    return segment.GetString(x.s, 18)
}

func (x PodSpec) SetHostname(value string) PodSpec {
    segment.SetString(x.s, 18, value)
    return x
}
func (x PodSpec) IsSetHostname() bool{
    return x.s.HasField(18)
}

func (x PodSpec) Subdomain() string {
    return segment.GetString(x.s, 19)
}

func (x PodSpec) SetSubdomain(value string) PodSpec {
    segment.SetString(x.s, 19, value)
    return x
}
func (x PodSpec) IsSetSubdomain() bool{
    return x.s.HasField(19)
}

func (x PodSpec) Affinity() Affinity {
    s := segment.GetNestedStruct(x.s, 20, XXXMappingAffinity)
    return Affinity{s: s}
}

func (x PodSpec) SetAffinity(value Affinity) PodSpec {
    segment.SetNestedStruct(x.s, 20, value.XXXGetStruct())
    return x
}
func (x PodSpec) IsSetAffinity() bool{
    return x.s.HasField(20)
}

func (x PodSpec) SchedulerName() string {
    return segment.GetString(x.s, 21)
}

func (x PodSpec) SetSchedulerName(value string) PodSpec {
    segment.SetString(x.s, 21, value)
    return x
}
func (x PodSpec) IsSetSchedulerName() bool{
    return x.s.HasField(21)
}

// TolerationsList returns the underlying Structs list for iteration.
// Use NewToleration() to create items and Append to add them.
func (x PodSpec) TolerationsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 22, XXXMappingToleration); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 22, XXXMappingToleration)
    return structs
}

// TolerationsLen returns the number of items in the list.
func (x PodSpec) TolerationsLen(ctx context.Context) int {
    return x.TolerationsList(ctx).Len()
}

// TolerationsGet returns the item at the given index.
func (x PodSpec) TolerationsGet(ctx context.Context, index int) Toleration {
    s := x.TolerationsList(ctx).Get(index)
    return Toleration{s: s}
}

// TolerationsAppend appends items to the list.
func (x PodSpec) TolerationsAppend(ctx context.Context, values ...Toleration) {
    list := x.TolerationsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// TolerationsAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) TolerationsAppendRaw(ctx context.Context, values ...*TolerationRaw) {
    list := x.TolerationsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewTolerationFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetTolerations() bool{
    return x.s.HasField(22)
}

// HostAliasesList returns the underlying Structs list for iteration.
// Use NewHostAlias() to create items and Append to add them.
func (x PodSpec) HostAliasesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 23, XXXMappingHostAlias); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 23, XXXMappingHostAlias)
    return structs
}

// HostAliasesLen returns the number of items in the list.
func (x PodSpec) HostAliasesLen(ctx context.Context) int {
    return x.HostAliasesList(ctx).Len()
}

// HostAliasesGet returns the item at the given index.
func (x PodSpec) HostAliasesGet(ctx context.Context, index int) HostAlias {
    s := x.HostAliasesList(ctx).Get(index)
    return HostAlias{s: s}
}

// HostAliasesAppend appends items to the list.
func (x PodSpec) HostAliasesAppend(ctx context.Context, values ...HostAlias) {
    list := x.HostAliasesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// HostAliasesAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) HostAliasesAppendRaw(ctx context.Context, values ...*HostAliasRaw) {
    list := x.HostAliasesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewHostAliasFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetHostAliases() bool{
    return x.s.HasField(23)
}

func (x PodSpec) PriorityClassName() string {
    return segment.GetString(x.s, 24)
}

func (x PodSpec) SetPriorityClassName(value string) PodSpec {
    segment.SetString(x.s, 24, value)
    return x
}
func (x PodSpec) IsSetPriorityClassName() bool{
    return x.s.HasField(24)
}

func (x PodSpec) Priority() int32 {
    return segment.GetInt32(x.s, 25)
}

func (x PodSpec) SetPriority(value int32) PodSpec {
    segment.SetInt32(x.s, 25, value)
    return x
}
func (x PodSpec) IsSetPriority() bool{
    return x.s.HasField(25)
}

func (x PodSpec) DnsConfig() PodDNSConfig {
    s := segment.GetNestedStruct(x.s, 26, XXXMappingPodDNSConfig)
    return PodDNSConfig{s: s}
}

func (x PodSpec) SetDnsConfig(value PodDNSConfig) PodSpec {
    segment.SetNestedStruct(x.s, 26, value.XXXGetStruct())
    return x
}
func (x PodSpec) IsSetDnsConfig() bool{
    return x.s.HasField(26)
}

// ReadinessGatesList returns the underlying Structs list for iteration.
// Use NewPodReadinessGate() to create items and Append to add them.
func (x PodSpec) ReadinessGatesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 27, XXXMappingPodReadinessGate); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 27, XXXMappingPodReadinessGate)
    return structs
}

// ReadinessGatesLen returns the number of items in the list.
func (x PodSpec) ReadinessGatesLen(ctx context.Context) int {
    return x.ReadinessGatesList(ctx).Len()
}

// ReadinessGatesGet returns the item at the given index.
func (x PodSpec) ReadinessGatesGet(ctx context.Context, index int) PodReadinessGate {
    s := x.ReadinessGatesList(ctx).Get(index)
    return PodReadinessGate{s: s}
}

// ReadinessGatesAppend appends items to the list.
func (x PodSpec) ReadinessGatesAppend(ctx context.Context, values ...PodReadinessGate) {
    list := x.ReadinessGatesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ReadinessGatesAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) ReadinessGatesAppendRaw(ctx context.Context, values ...*PodReadinessGateRaw) {
    list := x.ReadinessGatesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodReadinessGateFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetReadinessGates() bool{
    return x.s.HasField(27)
}

func (x PodSpec) RuntimeClassName() string {
    return segment.GetString(x.s, 28)
}

func (x PodSpec) SetRuntimeClassName(value string) PodSpec {
    segment.SetString(x.s, 28, value)
    return x
}
func (x PodSpec) IsSetRuntimeClassName() bool{
    return x.s.HasField(28)
}

func (x PodSpec) EnableServiceLinks() bool {
    return segment.GetBool(x.s, 29)
}

func (x PodSpec) SetEnableServiceLinks(value bool) PodSpec {
    segment.SetBool(x.s, 29, value)
    return x
}
func (x PodSpec) IsSetEnableServiceLinks() bool{
    return x.s.HasField(29)
}

func (x PodSpec) PreemptionPolicy() PreemptionPolicy {
    return PreemptionPolicy(segment.GetUint8(x.s, 30))
}

func (x PodSpec) SetPreemptionPolicy(value PreemptionPolicy) PodSpec {
    segment.SetUint8(x.s, 30, uint8(value))
    return x
}
func (x PodSpec) IsSetPreemptionPolicy() bool{
    return x.s.HasField(30)
}

// OverheadList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x PodSpec) OverheadList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 31, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 31, XXXMappingKeyValue)
    return structs
}

// OverheadLen returns the number of items in the list.
func (x PodSpec) OverheadLen(ctx context.Context) int {
    return x.OverheadList(ctx).Len()
}

// OverheadGet returns the item at the given index.
func (x PodSpec) OverheadGet(ctx context.Context, index int) KeyValue {
    s := x.OverheadList(ctx).Get(index)
    return KeyValue{s: s}
}

// OverheadAppend appends items to the list.
func (x PodSpec) OverheadAppend(ctx context.Context, values ...KeyValue) {
    list := x.OverheadList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// OverheadAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) OverheadAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.OverheadList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetOverhead() bool{
    return x.s.HasField(31)
}

// TopologySpreadConstraintsList returns the underlying Structs list for iteration.
// Use NewTopologySpreadConstraint() to create items and Append to add them.
func (x PodSpec) TopologySpreadConstraintsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 32, XXXMappingTopologySpreadConstraint); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 32, XXXMappingTopologySpreadConstraint)
    return structs
}

// TopologySpreadConstraintsLen returns the number of items in the list.
func (x PodSpec) TopologySpreadConstraintsLen(ctx context.Context) int {
    return x.TopologySpreadConstraintsList(ctx).Len()
}

// TopologySpreadConstraintsGet returns the item at the given index.
func (x PodSpec) TopologySpreadConstraintsGet(ctx context.Context, index int) TopologySpreadConstraint {
    s := x.TopologySpreadConstraintsList(ctx).Get(index)
    return TopologySpreadConstraint{s: s}
}

// TopologySpreadConstraintsAppend appends items to the list.
func (x PodSpec) TopologySpreadConstraintsAppend(ctx context.Context, values ...TopologySpreadConstraint) {
    list := x.TopologySpreadConstraintsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// TopologySpreadConstraintsAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) TopologySpreadConstraintsAppendRaw(ctx context.Context, values ...*TopologySpreadConstraintRaw) {
    list := x.TopologySpreadConstraintsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewTopologySpreadConstraintFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetTopologySpreadConstraints() bool{
    return x.s.HasField(32)
}

func (x PodSpec) SetHostnameAsFqdn() bool {
    return segment.GetBool(x.s, 33)
}

func (x PodSpec) SetSetHostnameAsFqdn(value bool) PodSpec {
    segment.SetBool(x.s, 33, value)
    return x
}
func (x PodSpec) IsSetSetHostnameAsFqdn() bool{
    return x.s.HasField(33)
}

func (x PodSpec) Os() PodOS {
    s := segment.GetNestedStruct(x.s, 34, XXXMappingPodOS)
    return PodOS{s: s}
}

func (x PodSpec) SetOs(value PodOS) PodSpec {
    segment.SetNestedStruct(x.s, 34, value.XXXGetStruct())
    return x
}
func (x PodSpec) IsSetOs() bool{
    return x.s.HasField(34)
}

func (x PodSpec) HostUsers() bool {
    return segment.GetBool(x.s, 35)
}

func (x PodSpec) SetHostUsers(value bool) PodSpec {
    segment.SetBool(x.s, 35, value)
    return x
}
func (x PodSpec) IsSetHostUsers() bool{
    return x.s.HasField(35)
}

// SchedulingGatesList returns the underlying Structs list for iteration.
// Use NewPodSchedulingGate() to create items and Append to add them.
func (x PodSpec) SchedulingGatesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 36, XXXMappingPodSchedulingGate); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 36, XXXMappingPodSchedulingGate)
    return structs
}

// SchedulingGatesLen returns the number of items in the list.
func (x PodSpec) SchedulingGatesLen(ctx context.Context) int {
    return x.SchedulingGatesList(ctx).Len()
}

// SchedulingGatesGet returns the item at the given index.
func (x PodSpec) SchedulingGatesGet(ctx context.Context, index int) PodSchedulingGate {
    s := x.SchedulingGatesList(ctx).Get(index)
    return PodSchedulingGate{s: s}
}

// SchedulingGatesAppend appends items to the list.
func (x PodSpec) SchedulingGatesAppend(ctx context.Context, values ...PodSchedulingGate) {
    list := x.SchedulingGatesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// SchedulingGatesAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) SchedulingGatesAppendRaw(ctx context.Context, values ...*PodSchedulingGateRaw) {
    list := x.SchedulingGatesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodSchedulingGateFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetSchedulingGates() bool{
    return x.s.HasField(36)
}

// ResourceClaimsList returns the underlying Structs list for iteration.
// Use NewPodResourceClaim() to create items and Append to add them.
func (x PodSpec) ResourceClaimsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 37, XXXMappingPodResourceClaim); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 37, XXXMappingPodResourceClaim)
    return structs
}

// ResourceClaimsLen returns the number of items in the list.
func (x PodSpec) ResourceClaimsLen(ctx context.Context) int {
    return x.ResourceClaimsList(ctx).Len()
}

// ResourceClaimsGet returns the item at the given index.
func (x PodSpec) ResourceClaimsGet(ctx context.Context, index int) PodResourceClaim {
    s := x.ResourceClaimsList(ctx).Get(index)
    return PodResourceClaim{s: s}
}

// ResourceClaimsAppend appends items to the list.
func (x PodSpec) ResourceClaimsAppend(ctx context.Context, values ...PodResourceClaim) {
    list := x.ResourceClaimsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ResourceClaimsAppendRaw appends items to the list using Raw struct representations.
func (x PodSpec) ResourceClaimsAppendRaw(ctx context.Context, values ...*PodResourceClaimRaw) {
    list := x.ResourceClaimsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodResourceClaimFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodSpec) IsSetResourceClaims() bool{
    return x.s.HasField(37)
}

func (x PodSpec) Resources() ResourceRequirements {
    s := segment.GetNestedStruct(x.s, 38, XXXMappingResourceRequirements)
    return ResourceRequirements{s: s}
}

func (x PodSpec) SetResources(value ResourceRequirements) PodSpec {
    segment.SetNestedStruct(x.s, 38, value.XXXGetStruct())
    return x
}
func (x PodSpec) IsSetResources() bool{
    return x.s.HasField(38)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodSpec) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodSpec) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodSpec) XXXTypeHash() [16]byte {
    return XXXTypeHashPodSpec
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodSpec) SetRecording(enabled bool) PodSpec {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodSpec) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodSpec) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodSpec) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodSpecRaw is a plain Go struct representation of PodSpec.
// Zero values are not set (sparse encoding).
type PodSpecRaw struct {
    Volumes []*VolumeRaw
    InitContainers []*ContainerRaw
    Containers []*ContainerRaw
    EphemeralContainers []*EphemeralContainerRaw
    RestartPolicy RestartPolicy
    TerminationGracePeriodSeconds int64
    ActiveDeadlineSeconds int64
    DnsPolicy DNSPolicy
    NodeSelector []*KeyValueRaw
    ServiceAccountName string
    AutomountServiceAccountToken bool
    NodeName string
    HostNetwork bool
    HostPid bool
    HostIpc bool
    ShareProcessNamespace bool
    SecurityContext *PodSecurityContextRaw
    ImagePullSecrets []*LocalObjectReferenceRaw
    Hostname string
    Subdomain string
    Affinity *AffinityRaw
    SchedulerName string
    Tolerations []*TolerationRaw
    HostAliases []*HostAliasRaw
    PriorityClassName string
    Priority int32
    DnsConfig *PodDNSConfigRaw
    ReadinessGates []*PodReadinessGateRaw
    RuntimeClassName string
    EnableServiceLinks bool
    PreemptionPolicy PreemptionPolicy
    Overhead []*KeyValueRaw
    TopologySpreadConstraints []*TopologySpreadConstraintRaw
    SetHostnameAsFqdn bool
    Os *PodOSRaw
    HostUsers bool
    SchedulingGates []*PodSchedulingGateRaw
    ResourceClaims []*PodResourceClaimRaw
    Resources *ResourceRequirementsRaw
}

// NewPodSpecFromRaw creates a new PodSpec from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodSpecFromRaw(ctx context.Context, raw PodSpecRaw) PodSpec {
    x := NewPodSpec(ctx)
    if raw.Volumes != nil {
        list := x.VolumesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Volumes))
        for _, r := range raw.Volumes {
            if r != nil {
                items = append(items, NewVolumeFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.InitContainers != nil {
        list := x.InitContainersList(ctx)
        items := make([]*segment.Struct, 0, len(raw.InitContainers))
        for _, r := range raw.InitContainers {
            if r != nil {
                items = append(items, NewContainerFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Containers != nil {
        list := x.ContainersList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Containers))
        for _, r := range raw.Containers {
            if r != nil {
                items = append(items, NewContainerFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.EphemeralContainers != nil {
        list := x.EphemeralContainersList(ctx)
        items := make([]*segment.Struct, 0, len(raw.EphemeralContainers))
        for _, r := range raw.EphemeralContainers {
            if r != nil {
                items = append(items, NewEphemeralContainerFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.RestartPolicy != 0 {
        x.SetRestartPolicy(raw.RestartPolicy)
    }
    if raw.TerminationGracePeriodSeconds != 0 {
        x.SetTerminationGracePeriodSeconds(raw.TerminationGracePeriodSeconds)
    }
    if raw.ActiveDeadlineSeconds != 0 {
        x.SetActiveDeadlineSeconds(raw.ActiveDeadlineSeconds)
    }
    if raw.DnsPolicy != 0 {
        x.SetDnsPolicy(raw.DnsPolicy)
    }
    if raw.NodeSelector != nil {
        list := x.NodeSelectorList(ctx)
        items := make([]*segment.Struct, 0, len(raw.NodeSelector))
        for _, r := range raw.NodeSelector {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.ServiceAccountName != "" {
        x.SetServiceAccountName(raw.ServiceAccountName)
    }
    if raw.AutomountServiceAccountToken {
        x.SetAutomountServiceAccountToken(raw.AutomountServiceAccountToken)
    }
    if raw.NodeName != "" {
        x.SetNodeName(raw.NodeName)
    }
    if raw.HostNetwork {
        x.SetHostNetwork(raw.HostNetwork)
    }
    if raw.HostPid {
        x.SetHostPid(raw.HostPid)
    }
    if raw.HostIpc {
        x.SetHostIpc(raw.HostIpc)
    }
    if raw.ShareProcessNamespace {
        x.SetShareProcessNamespace(raw.ShareProcessNamespace)
    }
    if raw.SecurityContext != nil {
        x.SetSecurityContext(NewPodSecurityContextFromRaw(ctx, *raw.SecurityContext))
    }
    if raw.ImagePullSecrets != nil {
        list := x.ImagePullSecretsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.ImagePullSecrets))
        for _, r := range raw.ImagePullSecrets {
            if r != nil {
                items = append(items, NewLocalObjectReferenceFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Hostname != "" {
        x.SetHostname(raw.Hostname)
    }
    if raw.Subdomain != "" {
        x.SetSubdomain(raw.Subdomain)
    }
    if raw.Affinity != nil {
        x.SetAffinity(NewAffinityFromRaw(ctx, *raw.Affinity))
    }
    if raw.SchedulerName != "" {
        x.SetSchedulerName(raw.SchedulerName)
    }
    if raw.Tolerations != nil {
        list := x.TolerationsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Tolerations))
        for _, r := range raw.Tolerations {
            if r != nil {
                items = append(items, NewTolerationFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.HostAliases != nil {
        list := x.HostAliasesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.HostAliases))
        for _, r := range raw.HostAliases {
            if r != nil {
                items = append(items, NewHostAliasFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.PriorityClassName != "" {
        x.SetPriorityClassName(raw.PriorityClassName)
    }
    if raw.Priority != 0 {
        x.SetPriority(raw.Priority)
    }
    if raw.DnsConfig != nil {
        x.SetDnsConfig(NewPodDNSConfigFromRaw(ctx, *raw.DnsConfig))
    }
    if raw.ReadinessGates != nil {
        list := x.ReadinessGatesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.ReadinessGates))
        for _, r := range raw.ReadinessGates {
            if r != nil {
                items = append(items, NewPodReadinessGateFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.RuntimeClassName != "" {
        x.SetRuntimeClassName(raw.RuntimeClassName)
    }
    if raw.EnableServiceLinks {
        x.SetEnableServiceLinks(raw.EnableServiceLinks)
    }
    if raw.PreemptionPolicy != 0 {
        x.SetPreemptionPolicy(raw.PreemptionPolicy)
    }
    if raw.Overhead != nil {
        list := x.OverheadList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Overhead))
        for _, r := range raw.Overhead {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.TopologySpreadConstraints != nil {
        list := x.TopologySpreadConstraintsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.TopologySpreadConstraints))
        for _, r := range raw.TopologySpreadConstraints {
            if r != nil {
                items = append(items, NewTopologySpreadConstraintFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.SetHostnameAsFqdn {
        x.SetSetHostnameAsFqdn(raw.SetHostnameAsFqdn)
    }
    if raw.Os != nil {
        x.SetOs(NewPodOSFromRaw(ctx, *raw.Os))
    }
    if raw.HostUsers {
        x.SetHostUsers(raw.HostUsers)
    }
    if raw.SchedulingGates != nil {
        list := x.SchedulingGatesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.SchedulingGates))
        for _, r := range raw.SchedulingGates {
            if r != nil {
                items = append(items, NewPodSchedulingGateFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.ResourceClaims != nil {
        list := x.ResourceClaimsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.ResourceClaims))
        for _, r := range raw.ResourceClaims {
            if r != nil {
                items = append(items, NewPodResourceClaimFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Resources != nil {
        x.SetResources(NewResourceRequirementsFromRaw(ctx, *raw.Resources))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodSpec) ToRaw(ctx context.Context) PodSpecRaw {
    raw := PodSpecRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Volumes = make([]*VolumeRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Volume{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Volumes[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.VolumesList(ctx)
        raw.Volumes = make([]*VolumeRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Volume{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Volumes[i] = &itemRaw
        }
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.InitContainers = make([]*ContainerRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Container{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.InitContainers[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.InitContainersList(ctx)
        raw.InitContainers = make([]*ContainerRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Container{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.InitContainers[i] = &itemRaw
        }
    }
    if l := x.s.GetList(2); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Containers = make([]*ContainerRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Container{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Containers[i] = &itemRaw
        }
    } else if x.s.HasField(2) {
        list := x.ContainersList(ctx)
        raw.Containers = make([]*ContainerRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Container{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Containers[i] = &itemRaw
        }
    }
    if l := x.s.GetList(3); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.EphemeralContainers = make([]*EphemeralContainerRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EphemeralContainer{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.EphemeralContainers[i] = &itemRaw
        }
    } else if x.s.HasField(3) {
        list := x.EphemeralContainersList(ctx)
        raw.EphemeralContainers = make([]*EphemeralContainerRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := EphemeralContainer{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.EphemeralContainers[i] = &itemRaw
        }
    }
    raw.RestartPolicy = x.RestartPolicy()
    raw.TerminationGracePeriodSeconds = x.TerminationGracePeriodSeconds()
    raw.ActiveDeadlineSeconds = x.ActiveDeadlineSeconds()
    raw.DnsPolicy = x.DnsPolicy()
    if l := x.s.GetList(8); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.NodeSelector = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.NodeSelector[i] = &itemRaw
        }
    } else if x.s.HasField(8) {
        list := x.NodeSelectorList(ctx)
        raw.NodeSelector = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.NodeSelector[i] = &itemRaw
        }
    }
    raw.ServiceAccountName = x.ServiceAccountName()
    raw.AutomountServiceAccountToken = x.AutomountServiceAccountToken()
    raw.NodeName = x.NodeName()
    raw.HostNetwork = x.HostNetwork()
    raw.HostPid = x.HostPid()
    raw.HostIpc = x.HostIpc()
    raw.ShareProcessNamespace = x.ShareProcessNamespace()
    if x.s.HasField(16) {
        nestedRaw := x.SecurityContext().ToRaw(ctx)
        raw.SecurityContext = &nestedRaw
    }
    if l := x.s.GetList(17); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.ImagePullSecrets = make([]*LocalObjectReferenceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := LocalObjectReference{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ImagePullSecrets[i] = &itemRaw
        }
    } else if x.s.HasField(17) {
        list := x.ImagePullSecretsList(ctx)
        raw.ImagePullSecrets = make([]*LocalObjectReferenceRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := LocalObjectReference{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ImagePullSecrets[i] = &itemRaw
        }
    }
    raw.Hostname = x.Hostname()
    raw.Subdomain = x.Subdomain()
    if x.s.HasField(20) {
        nestedRaw := x.Affinity().ToRaw(ctx)
        raw.Affinity = &nestedRaw
    }
    raw.SchedulerName = x.SchedulerName()
    if l := x.s.GetList(22); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Tolerations = make([]*TolerationRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Toleration{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Tolerations[i] = &itemRaw
        }
    } else if x.s.HasField(22) {
        list := x.TolerationsList(ctx)
        raw.Tolerations = make([]*TolerationRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := Toleration{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Tolerations[i] = &itemRaw
        }
    }
    if l := x.s.GetList(23); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.HostAliases = make([]*HostAliasRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := HostAlias{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.HostAliases[i] = &itemRaw
        }
    } else if x.s.HasField(23) {
        list := x.HostAliasesList(ctx)
        raw.HostAliases = make([]*HostAliasRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := HostAlias{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.HostAliases[i] = &itemRaw
        }
    }
    raw.PriorityClassName = x.PriorityClassName()
    raw.Priority = x.Priority()
    if x.s.HasField(26) {
        nestedRaw := x.DnsConfig().ToRaw(ctx)
        raw.DnsConfig = &nestedRaw
    }
    if l := x.s.GetList(27); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.ReadinessGates = make([]*PodReadinessGateRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodReadinessGate{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ReadinessGates[i] = &itemRaw
        }
    } else if x.s.HasField(27) {
        list := x.ReadinessGatesList(ctx)
        raw.ReadinessGates = make([]*PodReadinessGateRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodReadinessGate{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ReadinessGates[i] = &itemRaw
        }
    }
    raw.RuntimeClassName = x.RuntimeClassName()
    raw.EnableServiceLinks = x.EnableServiceLinks()
    raw.PreemptionPolicy = x.PreemptionPolicy()
    if l := x.s.GetList(31); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Overhead = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Overhead[i] = &itemRaw
        }
    } else if x.s.HasField(31) {
        list := x.OverheadList(ctx)
        raw.Overhead = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Overhead[i] = &itemRaw
        }
    }
    if l := x.s.GetList(32); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.TopologySpreadConstraints = make([]*TopologySpreadConstraintRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := TopologySpreadConstraint{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.TopologySpreadConstraints[i] = &itemRaw
        }
    } else if x.s.HasField(32) {
        list := x.TopologySpreadConstraintsList(ctx)
        raw.TopologySpreadConstraints = make([]*TopologySpreadConstraintRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := TopologySpreadConstraint{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.TopologySpreadConstraints[i] = &itemRaw
        }
    }
    raw.SetHostnameAsFqdn = x.SetHostnameAsFqdn()
    if x.s.HasField(34) {
        nestedRaw := x.Os().ToRaw(ctx)
        raw.Os = &nestedRaw
    }
    raw.HostUsers = x.HostUsers()
    if l := x.s.GetList(36); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.SchedulingGates = make([]*PodSchedulingGateRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodSchedulingGate{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.SchedulingGates[i] = &itemRaw
        }
    } else if x.s.HasField(36) {
        list := x.SchedulingGatesList(ctx)
        raw.SchedulingGates = make([]*PodSchedulingGateRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodSchedulingGate{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.SchedulingGates[i] = &itemRaw
        }
    }
    if l := x.s.GetList(37); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.ResourceClaims = make([]*PodResourceClaimRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodResourceClaim{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ResourceClaims[i] = &itemRaw
        }
    } else if x.s.HasField(37) {
        list := x.ResourceClaimsList(ctx)
        raw.ResourceClaims = make([]*PodResourceClaimRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodResourceClaim{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ResourceClaims[i] = &itemRaw
        }
    }
    if x.s.HasField(38) {
        nestedRaw := x.Resources().ToRaw(ctx)
        raw.Resources = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodSpec) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(69)
}

// PodStatus represents information about the status of a pod.
type PodStatus struct {
   s *segment.Struct
}

// NewPodStatus creates a new pooled instance of PodStatus.
// Call Release() when done to return it to the pool for reuse.
func NewPodStatus(ctx context.Context) PodStatus {
    s := segment.New(ctx, XXXMappingPodStatus)
    s.SetIsSetEnabled(true)
    return PodStatus{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PodStatus) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPodStatusFrom creates a new PodStatus from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPodStatusFrom(s *segment.Struct) PodStatus {
    return PodStatus{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PodStatus) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PodStatus) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PodStatus) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PodStatus) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PodStatus) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PodStatus) Phase() PodPhase {
    return PodPhase(segment.GetUint8(x.s, 0))
}

func (x PodStatus) SetPhase(value PodPhase) PodStatus {
    segment.SetUint8(x.s, 0, uint8(value))
    return x
}
func (x PodStatus) IsSetPhase() bool{
    return x.s.HasField(0)
}

// ConditionsList returns the underlying Structs list for iteration.
// Use NewPodCondition() to create items and Append to add them.
func (x PodStatus) ConditionsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingPodCondition); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingPodCondition)
    return structs
}

// ConditionsLen returns the number of items in the list.
func (x PodStatus) ConditionsLen(ctx context.Context) int {
    return x.ConditionsList(ctx).Len()
}

// ConditionsGet returns the item at the given index.
func (x PodStatus) ConditionsGet(ctx context.Context, index int) PodCondition {
    s := x.ConditionsList(ctx).Get(index)
    return PodCondition{s: s}
}

// ConditionsAppend appends items to the list.
func (x PodStatus) ConditionsAppend(ctx context.Context, values ...PodCondition) {
    list := x.ConditionsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ConditionsAppendRaw appends items to the list using Raw struct representations.
func (x PodStatus) ConditionsAppendRaw(ctx context.Context, values ...*PodConditionRaw) {
    list := x.ConditionsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodConditionFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodStatus) IsSetConditions() bool{
    return x.s.HasField(1)
}

func (x PodStatus) Message() string {
    return segment.GetString(x.s, 2)
}

func (x PodStatus) SetMessage(value string) PodStatus {
    segment.SetString(x.s, 2, value)
    return x
}
func (x PodStatus) IsSetMessage() bool{
    return x.s.HasField(2)
}

func (x PodStatus) Reason() string {
    return segment.GetString(x.s, 3)
}

func (x PodStatus) SetReason(value string) PodStatus {
    segment.SetString(x.s, 3, value)
    return x
}
func (x PodStatus) IsSetReason() bool{
    return x.s.HasField(3)
}

func (x PodStatus) NominatedNodeName() string {
    return segment.GetString(x.s, 4)
}

func (x PodStatus) SetNominatedNodeName(value string) PodStatus {
    segment.SetString(x.s, 4, value)
    return x
}
func (x PodStatus) IsSetNominatedNodeName() bool{
    return x.s.HasField(4)
}

func (x PodStatus) HostIp() string {
    return segment.GetString(x.s, 5)
}

func (x PodStatus) SetHostIp(value string) PodStatus {
    segment.SetString(x.s, 5, value)
    return x
}
func (x PodStatus) IsSetHostIp() bool{
    return x.s.HasField(5)
}

// HostIpsList returns the underlying Structs list for iteration.
// Use NewHostIP() to create items and Append to add them.
func (x PodStatus) HostIpsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 6, XXXMappingHostIP); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 6, XXXMappingHostIP)
    return structs
}

// HostIpsLen returns the number of items in the list.
func (x PodStatus) HostIpsLen(ctx context.Context) int {
    return x.HostIpsList(ctx).Len()
}

// HostIpsGet returns the item at the given index.
func (x PodStatus) HostIpsGet(ctx context.Context, index int) HostIP {
    s := x.HostIpsList(ctx).Get(index)
    return HostIP{s: s}
}

// HostIpsAppend appends items to the list.
func (x PodStatus) HostIpsAppend(ctx context.Context, values ...HostIP) {
    list := x.HostIpsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// HostIpsAppendRaw appends items to the list using Raw struct representations.
func (x PodStatus) HostIpsAppendRaw(ctx context.Context, values ...*HostIPRaw) {
    list := x.HostIpsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewHostIPFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodStatus) IsSetHostIps() bool{
    return x.s.HasField(6)
}

func (x PodStatus) PodIp() string {
    return segment.GetString(x.s, 7)
}

func (x PodStatus) SetPodIp(value string) PodStatus {
    segment.SetString(x.s, 7, value)
    return x
}
func (x PodStatus) IsSetPodIp() bool{
    return x.s.HasField(7)
}

// PodIpsList returns the underlying Structs list for iteration.
// Use NewPodIP() to create items and Append to add them.
func (x PodStatus) PodIpsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 8, XXXMappingPodIP); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 8, XXXMappingPodIP)
    return structs
}

// PodIpsLen returns the number of items in the list.
func (x PodStatus) PodIpsLen(ctx context.Context) int {
    return x.PodIpsList(ctx).Len()
}

// PodIpsGet returns the item at the given index.
func (x PodStatus) PodIpsGet(ctx context.Context, index int) PodIP {
    s := x.PodIpsList(ctx).Get(index)
    return PodIP{s: s}
}

// PodIpsAppend appends items to the list.
func (x PodStatus) PodIpsAppend(ctx context.Context, values ...PodIP) {
    list := x.PodIpsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// PodIpsAppendRaw appends items to the list using Raw struct representations.
func (x PodStatus) PodIpsAppendRaw(ctx context.Context, values ...*PodIPRaw) {
    list := x.PodIpsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodIPFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodStatus) IsSetPodIps() bool{
    return x.s.HasField(8)
}

func (x PodStatus) StartTime() Time {
    s := segment.GetNestedStruct(x.s, 9, XXXMappingTime)
    return Time{s: s}
}

func (x PodStatus) SetStartTime(value Time) PodStatus {
    segment.SetNestedStruct(x.s, 9, value.XXXGetStruct())
    return x
}
func (x PodStatus) IsSetStartTime() bool{
    return x.s.HasField(9)
}

// InitContainerStatusesList returns the underlying Structs list for iteration.
// Use NewContainerStatus() to create items and Append to add them.
func (x PodStatus) InitContainerStatusesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 10, XXXMappingContainerStatus); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 10, XXXMappingContainerStatus)
    return structs
}

// InitContainerStatusesLen returns the number of items in the list.
func (x PodStatus) InitContainerStatusesLen(ctx context.Context) int {
    return x.InitContainerStatusesList(ctx).Len()
}

// InitContainerStatusesGet returns the item at the given index.
func (x PodStatus) InitContainerStatusesGet(ctx context.Context, index int) ContainerStatus {
    s := x.InitContainerStatusesList(ctx).Get(index)
    return ContainerStatus{s: s}
}

// InitContainerStatusesAppend appends items to the list.
func (x PodStatus) InitContainerStatusesAppend(ctx context.Context, values ...ContainerStatus) {
    list := x.InitContainerStatusesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// InitContainerStatusesAppendRaw appends items to the list using Raw struct representations.
func (x PodStatus) InitContainerStatusesAppendRaw(ctx context.Context, values ...*ContainerStatusRaw) {
    list := x.InitContainerStatusesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewContainerStatusFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodStatus) IsSetInitContainerStatuses() bool{
    return x.s.HasField(10)
}

// ContainerStatusesList returns the underlying Structs list for iteration.
// Use NewContainerStatus() to create items and Append to add them.
func (x PodStatus) ContainerStatusesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 11, XXXMappingContainerStatus); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 11, XXXMappingContainerStatus)
    return structs
}

// ContainerStatusesLen returns the number of items in the list.
func (x PodStatus) ContainerStatusesLen(ctx context.Context) int {
    return x.ContainerStatusesList(ctx).Len()
}

// ContainerStatusesGet returns the item at the given index.
func (x PodStatus) ContainerStatusesGet(ctx context.Context, index int) ContainerStatus {
    s := x.ContainerStatusesList(ctx).Get(index)
    return ContainerStatus{s: s}
}

// ContainerStatusesAppend appends items to the list.
func (x PodStatus) ContainerStatusesAppend(ctx context.Context, values ...ContainerStatus) {
    list := x.ContainerStatusesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ContainerStatusesAppendRaw appends items to the list using Raw struct representations.
func (x PodStatus) ContainerStatusesAppendRaw(ctx context.Context, values ...*ContainerStatusRaw) {
    list := x.ContainerStatusesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewContainerStatusFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodStatus) IsSetContainerStatuses() bool{
    return x.s.HasField(11)
}

func (x PodStatus) QosClass() PodQOSClass {
    return PodQOSClass(segment.GetUint8(x.s, 12))
}

func (x PodStatus) SetQosClass(value PodQOSClass) PodStatus {
    segment.SetUint8(x.s, 12, uint8(value))
    return x
}
func (x PodStatus) IsSetQosClass() bool{
    return x.s.HasField(12)
}

// EphemeralContainerStatusesList returns the underlying Structs list for iteration.
// Use NewContainerStatus() to create items and Append to add them.
func (x PodStatus) EphemeralContainerStatusesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 13, XXXMappingContainerStatus); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 13, XXXMappingContainerStatus)
    return structs
}

// EphemeralContainerStatusesLen returns the number of items in the list.
func (x PodStatus) EphemeralContainerStatusesLen(ctx context.Context) int {
    return x.EphemeralContainerStatusesList(ctx).Len()
}

// EphemeralContainerStatusesGet returns the item at the given index.
func (x PodStatus) EphemeralContainerStatusesGet(ctx context.Context, index int) ContainerStatus {
    s := x.EphemeralContainerStatusesList(ctx).Get(index)
    return ContainerStatus{s: s}
}

// EphemeralContainerStatusesAppend appends items to the list.
func (x PodStatus) EphemeralContainerStatusesAppend(ctx context.Context, values ...ContainerStatus) {
    list := x.EphemeralContainerStatusesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// EphemeralContainerStatusesAppendRaw appends items to the list using Raw struct representations.
func (x PodStatus) EphemeralContainerStatusesAppendRaw(ctx context.Context, values ...*ContainerStatusRaw) {
    list := x.EphemeralContainerStatusesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewContainerStatusFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodStatus) IsSetEphemeralContainerStatuses() bool{
    return x.s.HasField(13)
}

func (x PodStatus) Resize() PodResizeStatus {
    return PodResizeStatus(segment.GetUint8(x.s, 14))
}

func (x PodStatus) SetResize(value PodResizeStatus) PodStatus {
    segment.SetUint8(x.s, 14, uint8(value))
    return x
}
func (x PodStatus) IsSetResize() bool{
    return x.s.HasField(14)
}

// ResourceClaimStatusesList returns the underlying Structs list for iteration.
// Use NewPodResourceClaimStatus() to create items and Append to add them.
func (x PodStatus) ResourceClaimStatusesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 15, XXXMappingPodResourceClaimStatus); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 15, XXXMappingPodResourceClaimStatus)
    return structs
}

// ResourceClaimStatusesLen returns the number of items in the list.
func (x PodStatus) ResourceClaimStatusesLen(ctx context.Context) int {
    return x.ResourceClaimStatusesList(ctx).Len()
}

// ResourceClaimStatusesGet returns the item at the given index.
func (x PodStatus) ResourceClaimStatusesGet(ctx context.Context, index int) PodResourceClaimStatus {
    s := x.ResourceClaimStatusesList(ctx).Get(index)
    return PodResourceClaimStatus{s: s}
}

// ResourceClaimStatusesAppend appends items to the list.
func (x PodStatus) ResourceClaimStatusesAppend(ctx context.Context, values ...PodResourceClaimStatus) {
    list := x.ResourceClaimStatusesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ResourceClaimStatusesAppendRaw appends items to the list using Raw struct representations.
func (x PodStatus) ResourceClaimStatusesAppendRaw(ctx context.Context, values ...*PodResourceClaimStatusRaw) {
    list := x.ResourceClaimStatusesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewPodResourceClaimStatusFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x PodStatus) IsSetResourceClaimStatuses() bool{
    return x.s.HasField(15)
}

func (x PodStatus) ObservedGeneration() int64 {
    return segment.GetInt64(x.s, 16)
}

func (x PodStatus) SetObservedGeneration(value int64) PodStatus {
    segment.SetInt64(x.s, 16, value)
    return x
}
func (x PodStatus) IsSetObservedGeneration() bool{
    return x.s.HasField(16)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PodStatus) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PodStatus) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PodStatus) XXXTypeHash() [16]byte {
    return XXXTypeHashPodStatus
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PodStatus) SetRecording(enabled bool) PodStatus {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PodStatus) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PodStatus) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PodStatus) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PodStatusRaw is a plain Go struct representation of PodStatus.
// Zero values are not set (sparse encoding).
type PodStatusRaw struct {
    Phase PodPhase
    Conditions []*PodConditionRaw
    Message string
    Reason string
    NominatedNodeName string
    HostIp string
    HostIps []*HostIPRaw
    PodIp string
    PodIps []*PodIPRaw
    StartTime *TimeRaw
    InitContainerStatuses []*ContainerStatusRaw
    ContainerStatuses []*ContainerStatusRaw
    QosClass PodQOSClass
    EphemeralContainerStatuses []*ContainerStatusRaw
    Resize PodResizeStatus
    ResourceClaimStatuses []*PodResourceClaimStatusRaw
    ObservedGeneration int64
}

// NewPodStatusFromRaw creates a new PodStatus from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPodStatusFromRaw(ctx context.Context, raw PodStatusRaw) PodStatus {
    x := NewPodStatus(ctx)
    if raw.Phase != 0 {
        x.SetPhase(raw.Phase)
    }
    if raw.Conditions != nil {
        list := x.ConditionsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Conditions))
        for _, r := range raw.Conditions {
            if r != nil {
                items = append(items, NewPodConditionFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Message != "" {
        x.SetMessage(raw.Message)
    }
    if raw.Reason != "" {
        x.SetReason(raw.Reason)
    }
    if raw.NominatedNodeName != "" {
        x.SetNominatedNodeName(raw.NominatedNodeName)
    }
    if raw.HostIp != "" {
        x.SetHostIp(raw.HostIp)
    }
    if raw.HostIps != nil {
        list := x.HostIpsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.HostIps))
        for _, r := range raw.HostIps {
            if r != nil {
                items = append(items, NewHostIPFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.PodIp != "" {
        x.SetPodIp(raw.PodIp)
    }
    if raw.PodIps != nil {
        list := x.PodIpsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.PodIps))
        for _, r := range raw.PodIps {
            if r != nil {
                items = append(items, NewPodIPFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.StartTime != nil {
        x.SetStartTime(NewTimeFromRaw(ctx, *raw.StartTime))
    }
    if raw.InitContainerStatuses != nil {
        list := x.InitContainerStatusesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.InitContainerStatuses))
        for _, r := range raw.InitContainerStatuses {
            if r != nil {
                items = append(items, NewContainerStatusFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.ContainerStatuses != nil {
        list := x.ContainerStatusesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.ContainerStatuses))
        for _, r := range raw.ContainerStatuses {
            if r != nil {
                items = append(items, NewContainerStatusFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.QosClass != 0 {
        x.SetQosClass(raw.QosClass)
    }
    if raw.EphemeralContainerStatuses != nil {
        list := x.EphemeralContainerStatusesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.EphemeralContainerStatuses))
        for _, r := range raw.EphemeralContainerStatuses {
            if r != nil {
                items = append(items, NewContainerStatusFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Resize != 0 {
        x.SetResize(raw.Resize)
    }
    if raw.ResourceClaimStatuses != nil {
        list := x.ResourceClaimStatusesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.ResourceClaimStatuses))
        for _, r := range raw.ResourceClaimStatuses {
            if r != nil {
                items = append(items, NewPodResourceClaimStatusFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.ObservedGeneration != 0 {
        x.SetObservedGeneration(raw.ObservedGeneration)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PodStatus) ToRaw(ctx context.Context) PodStatusRaw {
    raw := PodStatusRaw{}
    raw.Phase = x.Phase()
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Conditions = make([]*PodConditionRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodCondition{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Conditions[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.ConditionsList(ctx)
        raw.Conditions = make([]*PodConditionRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodCondition{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Conditions[i] = &itemRaw
        }
    }
    raw.Message = x.Message()
    raw.Reason = x.Reason()
    raw.NominatedNodeName = x.NominatedNodeName()
    raw.HostIp = x.HostIp()
    if l := x.s.GetList(6); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.HostIps = make([]*HostIPRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := HostIP{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.HostIps[i] = &itemRaw
        }
    } else if x.s.HasField(6) {
        list := x.HostIpsList(ctx)
        raw.HostIps = make([]*HostIPRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := HostIP{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.HostIps[i] = &itemRaw
        }
    }
    raw.PodIp = x.PodIp()
    if l := x.s.GetList(8); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.PodIps = make([]*PodIPRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodIP{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.PodIps[i] = &itemRaw
        }
    } else if x.s.HasField(8) {
        list := x.PodIpsList(ctx)
        raw.PodIps = make([]*PodIPRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodIP{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.PodIps[i] = &itemRaw
        }
    }
    if x.s.HasField(9) {
        nestedRaw := x.StartTime().ToRaw(ctx)
        raw.StartTime = &nestedRaw
    }
    if l := x.s.GetList(10); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.InitContainerStatuses = make([]*ContainerStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.InitContainerStatuses[i] = &itemRaw
        }
    } else if x.s.HasField(10) {
        list := x.InitContainerStatusesList(ctx)
        raw.InitContainerStatuses = make([]*ContainerStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.InitContainerStatuses[i] = &itemRaw
        }
    }
    if l := x.s.GetList(11); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.ContainerStatuses = make([]*ContainerStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ContainerStatuses[i] = &itemRaw
        }
    } else if x.s.HasField(11) {
        list := x.ContainerStatusesList(ctx)
        raw.ContainerStatuses = make([]*ContainerStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ContainerStatuses[i] = &itemRaw
        }
    }
    raw.QosClass = x.QosClass()
    if l := x.s.GetList(13); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.EphemeralContainerStatuses = make([]*ContainerStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.EphemeralContainerStatuses[i] = &itemRaw
        }
    } else if x.s.HasField(13) {
        list := x.EphemeralContainerStatusesList(ctx)
        raw.EphemeralContainerStatuses = make([]*ContainerStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ContainerStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.EphemeralContainerStatuses[i] = &itemRaw
        }
    }
    raw.Resize = x.Resize()
    if l := x.s.GetList(15); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.ResourceClaimStatuses = make([]*PodResourceClaimStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodResourceClaimStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ResourceClaimStatuses[i] = &itemRaw
        }
    } else if x.s.HasField(15) {
        list := x.ResourceClaimStatusesList(ctx)
        raw.ResourceClaimStatuses = make([]*PodResourceClaimStatusRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := PodResourceClaimStatus{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.ResourceClaimStatuses[i] = &itemRaw
        }
    }
    raw.ObservedGeneration = x.ObservedGeneration()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PodStatus) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(70)
}

// PreferredSchedulingTerm is a scheduling term with weight.
type PreferredSchedulingTerm struct {
   s *segment.Struct
}

// NewPreferredSchedulingTerm creates a new pooled instance of PreferredSchedulingTerm.
// Call Release() when done to return it to the pool for reuse.
func NewPreferredSchedulingTerm(ctx context.Context) PreferredSchedulingTerm {
    s := segment.New(ctx, XXXMappingPreferredSchedulingTerm)
    s.SetIsSetEnabled(true)
    return PreferredSchedulingTerm{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x PreferredSchedulingTerm) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewPreferredSchedulingTermFrom creates a new PreferredSchedulingTerm from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewPreferredSchedulingTermFrom(s *segment.Struct) PreferredSchedulingTerm {
    return PreferredSchedulingTerm{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x PreferredSchedulingTerm) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x PreferredSchedulingTerm) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x PreferredSchedulingTerm) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x PreferredSchedulingTerm) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x PreferredSchedulingTerm) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x PreferredSchedulingTerm) Weight() int32 {
    return segment.GetInt32(x.s, 0)
}

func (x PreferredSchedulingTerm) SetWeight(value int32) PreferredSchedulingTerm {
    segment.SetInt32(x.s, 0, value)
    return x
}
func (x PreferredSchedulingTerm) IsSetWeight() bool{
    return x.s.HasField(0)
}

func (x PreferredSchedulingTerm) Preference() NodeSelectorTerm {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingNodeSelectorTerm)
    return NodeSelectorTerm{s: s}
}

func (x PreferredSchedulingTerm) SetPreference(value NodeSelectorTerm) PreferredSchedulingTerm {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x PreferredSchedulingTerm) IsSetPreference() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x PreferredSchedulingTerm) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x PreferredSchedulingTerm) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x PreferredSchedulingTerm) XXXTypeHash() [16]byte {
    return XXXTypeHashPreferredSchedulingTerm
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x PreferredSchedulingTerm) SetRecording(enabled bool) PreferredSchedulingTerm {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x PreferredSchedulingTerm) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x PreferredSchedulingTerm) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x PreferredSchedulingTerm) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// PreferredSchedulingTermRaw is a plain Go struct representation of PreferredSchedulingTerm.
// Zero values are not set (sparse encoding).
type PreferredSchedulingTermRaw struct {
    Weight int32
    Preference *NodeSelectorTermRaw
}

// NewPreferredSchedulingTermFromRaw creates a new PreferredSchedulingTerm from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewPreferredSchedulingTermFromRaw(ctx context.Context, raw PreferredSchedulingTermRaw) PreferredSchedulingTerm {
    x := NewPreferredSchedulingTerm(ctx)
    if raw.Weight != 0 {
        x.SetWeight(raw.Weight)
    }
    if raw.Preference != nil {
        x.SetPreference(NewNodeSelectorTermFromRaw(ctx, *raw.Preference))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x PreferredSchedulingTerm) ToRaw(ctx context.Context) PreferredSchedulingTermRaw {
    raw := PreferredSchedulingTermRaw{}
    raw.Weight = x.Weight()
    if x.s.HasField(1) {
        nestedRaw := x.Preference().ToRaw(ctx)
        raw.Preference = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x PreferredSchedulingTerm) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(71)
}

// Probe describes a health check to be performed against a container.
type Probe struct {
   s *segment.Struct
}

// NewProbe creates a new pooled instance of Probe.
// Call Release() when done to return it to the pool for reuse.
func NewProbe(ctx context.Context) Probe {
    s := segment.New(ctx, XXXMappingProbe)
    s.SetIsSetEnabled(true)
    return Probe{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Probe) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewProbeFrom creates a new Probe from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewProbeFrom(s *segment.Struct) Probe {
    return Probe{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Probe) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Probe) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Probe) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Probe) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Probe) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Probe) Handler() ProbeHandler {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingProbeHandler)
    return ProbeHandler{s: s}
}

func (x Probe) SetHandler(value ProbeHandler) Probe {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x Probe) IsSetHandler() bool{
    return x.s.HasField(0)
}

func (x Probe) InitialDelaySeconds() int32 {
    return segment.GetInt32(x.s, 1)
}

func (x Probe) SetInitialDelaySeconds(value int32) Probe {
    segment.SetInt32(x.s, 1, value)
    return x
}
func (x Probe) IsSetInitialDelaySeconds() bool{
    return x.s.HasField(1)
}

func (x Probe) TimeoutSeconds() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x Probe) SetTimeoutSeconds(value int32) Probe {
    segment.SetInt32(x.s, 2, value)
    return x
}
func (x Probe) IsSetTimeoutSeconds() bool{
    return x.s.HasField(2)
}

func (x Probe) PeriodSeconds() int32 {
    return segment.GetInt32(x.s, 3)
}

func (x Probe) SetPeriodSeconds(value int32) Probe {
    segment.SetInt32(x.s, 3, value)
    return x
}
func (x Probe) IsSetPeriodSeconds() bool{
    return x.s.HasField(3)
}

func (x Probe) SuccessThreshold() int32 {
    return segment.GetInt32(x.s, 4)
}

func (x Probe) SetSuccessThreshold(value int32) Probe {
    segment.SetInt32(x.s, 4, value)
    return x
}
func (x Probe) IsSetSuccessThreshold() bool{
    return x.s.HasField(4)
}

func (x Probe) FailureThreshold() int32 {
    return segment.GetInt32(x.s, 5)
}

func (x Probe) SetFailureThreshold(value int32) Probe {
    segment.SetInt32(x.s, 5, value)
    return x
}
func (x Probe) IsSetFailureThreshold() bool{
    return x.s.HasField(5)
}

func (x Probe) TerminationGracePeriodSeconds() int64 {
    return segment.GetInt64(x.s, 6)
}

func (x Probe) SetTerminationGracePeriodSeconds(value int64) Probe {
    segment.SetInt64(x.s, 6, value)
    return x
}
func (x Probe) IsSetTerminationGracePeriodSeconds() bool{
    return x.s.HasField(6)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Probe) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Probe) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Probe) XXXTypeHash() [16]byte {
    return XXXTypeHashProbe
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Probe) SetRecording(enabled bool) Probe {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Probe) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Probe) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Probe) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ProbeRaw is a plain Go struct representation of Probe.
// Zero values are not set (sparse encoding).
type ProbeRaw struct {
    Handler *ProbeHandlerRaw
    InitialDelaySeconds int32
    TimeoutSeconds int32
    PeriodSeconds int32
    SuccessThreshold int32
    FailureThreshold int32
    TerminationGracePeriodSeconds int64
}

// NewProbeFromRaw creates a new Probe from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewProbeFromRaw(ctx context.Context, raw ProbeRaw) Probe {
    x := NewProbe(ctx)
    if raw.Handler != nil {
        x.SetHandler(NewProbeHandlerFromRaw(ctx, *raw.Handler))
    }
    if raw.InitialDelaySeconds != 0 {
        x.SetInitialDelaySeconds(raw.InitialDelaySeconds)
    }
    if raw.TimeoutSeconds != 0 {
        x.SetTimeoutSeconds(raw.TimeoutSeconds)
    }
    if raw.PeriodSeconds != 0 {
        x.SetPeriodSeconds(raw.PeriodSeconds)
    }
    if raw.SuccessThreshold != 0 {
        x.SetSuccessThreshold(raw.SuccessThreshold)
    }
    if raw.FailureThreshold != 0 {
        x.SetFailureThreshold(raw.FailureThreshold)
    }
    if raw.TerminationGracePeriodSeconds != 0 {
        x.SetTerminationGracePeriodSeconds(raw.TerminationGracePeriodSeconds)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Probe) ToRaw(ctx context.Context) ProbeRaw {
    raw := ProbeRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.Handler().ToRaw(ctx)
        raw.Handler = &nestedRaw
    }
    raw.InitialDelaySeconds = x.InitialDelaySeconds()
    raw.TimeoutSeconds = x.TimeoutSeconds()
    raw.PeriodSeconds = x.PeriodSeconds()
    raw.SuccessThreshold = x.SuccessThreshold()
    raw.FailureThreshold = x.FailureThreshold()
    raw.TerminationGracePeriodSeconds = x.TerminationGracePeriodSeconds()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Probe) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(72)
}

// ProbeHandler defines a specific action that should be taken.
type ProbeHandler struct {
   s *segment.Struct
}

// NewProbeHandler creates a new pooled instance of ProbeHandler.
// Call Release() when done to return it to the pool for reuse.
func NewProbeHandler(ctx context.Context) ProbeHandler {
    s := segment.New(ctx, XXXMappingProbeHandler)
    s.SetIsSetEnabled(true)
    return ProbeHandler{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ProbeHandler) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewProbeHandlerFrom creates a new ProbeHandler from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewProbeHandlerFrom(s *segment.Struct) ProbeHandler {
    return ProbeHandler{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ProbeHandler) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ProbeHandler) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ProbeHandler) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ProbeHandler) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ProbeHandler) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ProbeHandler) Exec() ExecAction {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingExecAction)
    return ExecAction{s: s}
}

func (x ProbeHandler) SetExec(value ExecAction) ProbeHandler {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x ProbeHandler) IsSetExec() bool{
    return x.s.HasField(0)
}

func (x ProbeHandler) HttpGet() HTTPGetAction {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingHTTPGetAction)
    return HTTPGetAction{s: s}
}

func (x ProbeHandler) SetHttpGet(value HTTPGetAction) ProbeHandler {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x ProbeHandler) IsSetHttpGet() bool{
    return x.s.HasField(1)
}

func (x ProbeHandler) TcpSocket() TCPSocketAction {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingTCPSocketAction)
    return TCPSocketAction{s: s}
}

func (x ProbeHandler) SetTcpSocket(value TCPSocketAction) ProbeHandler {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x ProbeHandler) IsSetTcpSocket() bool{
    return x.s.HasField(2)
}

func (x ProbeHandler) Grpc() GRPCAction {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingGRPCAction)
    return GRPCAction{s: s}
}

func (x ProbeHandler) SetGrpc(value GRPCAction) ProbeHandler {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x ProbeHandler) IsSetGrpc() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ProbeHandler) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ProbeHandler) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ProbeHandler) XXXTypeHash() [16]byte {
    return XXXTypeHashProbeHandler
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ProbeHandler) SetRecording(enabled bool) ProbeHandler {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ProbeHandler) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ProbeHandler) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ProbeHandler) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ProbeHandlerRaw is a plain Go struct representation of ProbeHandler.
// Zero values are not set (sparse encoding).
type ProbeHandlerRaw struct {
    Exec *ExecActionRaw
    HttpGet *HTTPGetActionRaw
    TcpSocket *TCPSocketActionRaw
    Grpc *GRPCActionRaw
}

// NewProbeHandlerFromRaw creates a new ProbeHandler from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewProbeHandlerFromRaw(ctx context.Context, raw ProbeHandlerRaw) ProbeHandler {
    x := NewProbeHandler(ctx)
    if raw.Exec != nil {
        x.SetExec(NewExecActionFromRaw(ctx, *raw.Exec))
    }
    if raw.HttpGet != nil {
        x.SetHttpGet(NewHTTPGetActionFromRaw(ctx, *raw.HttpGet))
    }
    if raw.TcpSocket != nil {
        x.SetTcpSocket(NewTCPSocketActionFromRaw(ctx, *raw.TcpSocket))
    }
    if raw.Grpc != nil {
        x.SetGrpc(NewGRPCActionFromRaw(ctx, *raw.Grpc))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ProbeHandler) ToRaw(ctx context.Context) ProbeHandlerRaw {
    raw := ProbeHandlerRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.Exec().ToRaw(ctx)
        raw.Exec = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.HttpGet().ToRaw(ctx)
        raw.HttpGet = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.TcpSocket().ToRaw(ctx)
        raw.TcpSocket = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.Grpc().ToRaw(ctx)
        raw.Grpc = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ProbeHandler) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(73)
}

// ProjectedVolumeSource represents a projected volume source.
type ProjectedVolumeSource struct {
   s *segment.Struct
}

// NewProjectedVolumeSource creates a new pooled instance of ProjectedVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewProjectedVolumeSource(ctx context.Context) ProjectedVolumeSource {
    s := segment.New(ctx, XXXMappingProjectedVolumeSource)
    s.SetIsSetEnabled(true)
    return ProjectedVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ProjectedVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewProjectedVolumeSourceFrom creates a new ProjectedVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewProjectedVolumeSourceFrom(s *segment.Struct) ProjectedVolumeSource {
    return ProjectedVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ProjectedVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ProjectedVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ProjectedVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ProjectedVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ProjectedVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// SourcesList returns the underlying Structs list for iteration.
// Use NewVolumeProjection() to create items and Append to add them.
func (x ProjectedVolumeSource) SourcesList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingVolumeProjection); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingVolumeProjection)
    return structs
}

// SourcesLen returns the number of items in the list.
func (x ProjectedVolumeSource) SourcesLen(ctx context.Context) int {
    return x.SourcesList(ctx).Len()
}

// SourcesGet returns the item at the given index.
func (x ProjectedVolumeSource) SourcesGet(ctx context.Context, index int) VolumeProjection {
    s := x.SourcesList(ctx).Get(index)
    return VolumeProjection{s: s}
}

// SourcesAppend appends items to the list.
func (x ProjectedVolumeSource) SourcesAppend(ctx context.Context, values ...VolumeProjection) {
    list := x.SourcesList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// SourcesAppendRaw appends items to the list using Raw struct representations.
func (x ProjectedVolumeSource) SourcesAppendRaw(ctx context.Context, values ...*VolumeProjectionRaw) {
    list := x.SourcesList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewVolumeProjectionFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ProjectedVolumeSource) IsSetSources() bool{
    return x.s.HasField(0)
}

func (x ProjectedVolumeSource) DefaultMode() int32 {
    return segment.GetInt32(x.s, 1)
}

func (x ProjectedVolumeSource) SetDefaultMode(value int32) ProjectedVolumeSource {
    segment.SetInt32(x.s, 1, value)
    return x
}
func (x ProjectedVolumeSource) IsSetDefaultMode() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ProjectedVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ProjectedVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ProjectedVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashProjectedVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ProjectedVolumeSource) SetRecording(enabled bool) ProjectedVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ProjectedVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ProjectedVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ProjectedVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ProjectedVolumeSourceRaw is a plain Go struct representation of ProjectedVolumeSource.
// Zero values are not set (sparse encoding).
type ProjectedVolumeSourceRaw struct {
    Sources []*VolumeProjectionRaw
    DefaultMode int32
}

// NewProjectedVolumeSourceFromRaw creates a new ProjectedVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewProjectedVolumeSourceFromRaw(ctx context.Context, raw ProjectedVolumeSourceRaw) ProjectedVolumeSource {
    x := NewProjectedVolumeSource(ctx)
    if raw.Sources != nil {
        list := x.SourcesList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Sources))
        for _, r := range raw.Sources {
            if r != nil {
                items = append(items, NewVolumeProjectionFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.DefaultMode != 0 {
        x.SetDefaultMode(raw.DefaultMode)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ProjectedVolumeSource) ToRaw(ctx context.Context) ProjectedVolumeSourceRaw {
    raw := ProjectedVolumeSourceRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Sources = make([]*VolumeProjectionRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeProjection{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Sources[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.SourcesList(ctx)
        raw.Sources = make([]*VolumeProjectionRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := VolumeProjection{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Sources[i] = &itemRaw
        }
    }
    raw.DefaultMode = x.DefaultMode()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ProjectedVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(74)
}

// ResourceClaim references one entry in PodSpec.ResourceClaims.
type ResourceClaim struct {
   s *segment.Struct
}

// NewResourceClaim creates a new pooled instance of ResourceClaim.
// Call Release() when done to return it to the pool for reuse.
func NewResourceClaim(ctx context.Context) ResourceClaim {
    s := segment.New(ctx, XXXMappingResourceClaim)
    s.SetIsSetEnabled(true)
    return ResourceClaim{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ResourceClaim) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewResourceClaimFrom creates a new ResourceClaim from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewResourceClaimFrom(s *segment.Struct) ResourceClaim {
    return ResourceClaim{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ResourceClaim) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ResourceClaim) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ResourceClaim) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ResourceClaim) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ResourceClaim) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ResourceClaim) Name() string {
    return segment.GetString(x.s, 0)
}

func (x ResourceClaim) SetName(value string) ResourceClaim {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ResourceClaim) IsSetName() bool{
    return x.s.HasField(0)
}

func (x ResourceClaim) Request() string {
    return segment.GetString(x.s, 1)
}

func (x ResourceClaim) SetRequest(value string) ResourceClaim {
    segment.SetString(x.s, 1, value)
    return x
}
func (x ResourceClaim) IsSetRequest() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ResourceClaim) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ResourceClaim) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ResourceClaim) XXXTypeHash() [16]byte {
    return XXXTypeHashResourceClaim
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ResourceClaim) SetRecording(enabled bool) ResourceClaim {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ResourceClaim) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ResourceClaim) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ResourceClaim) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ResourceClaimRaw is a plain Go struct representation of ResourceClaim.
// Zero values are not set (sparse encoding).
type ResourceClaimRaw struct {
    Name string
    Request string
}

// NewResourceClaimFromRaw creates a new ResourceClaim from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewResourceClaimFromRaw(ctx context.Context, raw ResourceClaimRaw) ResourceClaim {
    x := NewResourceClaim(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Request != "" {
        x.SetRequest(raw.Request)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ResourceClaim) ToRaw(ctx context.Context) ResourceClaimRaw {
    raw := ResourceClaimRaw{}
    raw.Name = x.Name()
    raw.Request = x.Request()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ResourceClaim) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(75)
}

// ResourceFieldSelector represents container resources and their output format.
type ResourceFieldSelector struct {
   s *segment.Struct
}

// NewResourceFieldSelector creates a new pooled instance of ResourceFieldSelector.
// Call Release() when done to return it to the pool for reuse.
func NewResourceFieldSelector(ctx context.Context) ResourceFieldSelector {
    s := segment.New(ctx, XXXMappingResourceFieldSelector)
    s.SetIsSetEnabled(true)
    return ResourceFieldSelector{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ResourceFieldSelector) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewResourceFieldSelectorFrom creates a new ResourceFieldSelector from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewResourceFieldSelectorFrom(s *segment.Struct) ResourceFieldSelector {
    return ResourceFieldSelector{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ResourceFieldSelector) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ResourceFieldSelector) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ResourceFieldSelector) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ResourceFieldSelector) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ResourceFieldSelector) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ResourceFieldSelector) ContainerName() string {
    return segment.GetString(x.s, 0)
}

func (x ResourceFieldSelector) SetContainerName(value string) ResourceFieldSelector {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ResourceFieldSelector) IsSetContainerName() bool{
    return x.s.HasField(0)
}

func (x ResourceFieldSelector) Resource() string {
    return segment.GetString(x.s, 1)
}

func (x ResourceFieldSelector) SetResource(value string) ResourceFieldSelector {
    segment.SetString(x.s, 1, value)
    return x
}
func (x ResourceFieldSelector) IsSetResource() bool{
    return x.s.HasField(1)
}

func (x ResourceFieldSelector) Divisor() string {
    return segment.GetString(x.s, 2)
}

func (x ResourceFieldSelector) SetDivisor(value string) ResourceFieldSelector {
    segment.SetString(x.s, 2, value)
    return x
}
func (x ResourceFieldSelector) IsSetDivisor() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ResourceFieldSelector) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ResourceFieldSelector) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ResourceFieldSelector) XXXTypeHash() [16]byte {
    return XXXTypeHashResourceFieldSelector
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ResourceFieldSelector) SetRecording(enabled bool) ResourceFieldSelector {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ResourceFieldSelector) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ResourceFieldSelector) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ResourceFieldSelector) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ResourceFieldSelectorRaw is a plain Go struct representation of ResourceFieldSelector.
// Zero values are not set (sparse encoding).
type ResourceFieldSelectorRaw struct {
    ContainerName string
    Resource string
    Divisor string
}

// NewResourceFieldSelectorFromRaw creates a new ResourceFieldSelector from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewResourceFieldSelectorFromRaw(ctx context.Context, raw ResourceFieldSelectorRaw) ResourceFieldSelector {
    x := NewResourceFieldSelector(ctx)
    if raw.ContainerName != "" {
        x.SetContainerName(raw.ContainerName)
    }
    if raw.Resource != "" {
        x.SetResource(raw.Resource)
    }
    if raw.Divisor != "" {
        x.SetDivisor(raw.Divisor)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ResourceFieldSelector) ToRaw(ctx context.Context) ResourceFieldSelectorRaw {
    raw := ResourceFieldSelectorRaw{}
    raw.ContainerName = x.ContainerName()
    raw.Resource = x.Resource()
    raw.Divisor = x.Divisor()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ResourceFieldSelector) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(76)
}

// ResourceRequirements describes the compute resource requirements.
type ResourceRequirements struct {
   s *segment.Struct
}

// NewResourceRequirements creates a new pooled instance of ResourceRequirements.
// Call Release() when done to return it to the pool for reuse.
func NewResourceRequirements(ctx context.Context) ResourceRequirements {
    s := segment.New(ctx, XXXMappingResourceRequirements)
    s.SetIsSetEnabled(true)
    return ResourceRequirements{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ResourceRequirements) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewResourceRequirementsFrom creates a new ResourceRequirements from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewResourceRequirementsFrom(s *segment.Struct) ResourceRequirements {
    return ResourceRequirements{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ResourceRequirements) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ResourceRequirements) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ResourceRequirements) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ResourceRequirements) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ResourceRequirements) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

// LimitsList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x ResourceRequirements) LimitsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 0, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 0, XXXMappingKeyValue)
    return structs
}

// LimitsLen returns the number of items in the list.
func (x ResourceRequirements) LimitsLen(ctx context.Context) int {
    return x.LimitsList(ctx).Len()
}

// LimitsGet returns the item at the given index.
func (x ResourceRequirements) LimitsGet(ctx context.Context, index int) KeyValue {
    s := x.LimitsList(ctx).Get(index)
    return KeyValue{s: s}
}

// LimitsAppend appends items to the list.
func (x ResourceRequirements) LimitsAppend(ctx context.Context, values ...KeyValue) {
    list := x.LimitsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// LimitsAppendRaw appends items to the list using Raw struct representations.
func (x ResourceRequirements) LimitsAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.LimitsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ResourceRequirements) IsSetLimits() bool{
    return x.s.HasField(0)
}

// RequestsList returns the underlying Structs list for iteration.
// Use NewKeyValue() to create items and Append to add them.
func (x ResourceRequirements) RequestsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingKeyValue); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingKeyValue)
    return structs
}

// RequestsLen returns the number of items in the list.
func (x ResourceRequirements) RequestsLen(ctx context.Context) int {
    return x.RequestsList(ctx).Len()
}

// RequestsGet returns the item at the given index.
func (x ResourceRequirements) RequestsGet(ctx context.Context, index int) KeyValue {
    s := x.RequestsList(ctx).Get(index)
    return KeyValue{s: s}
}

// RequestsAppend appends items to the list.
func (x ResourceRequirements) RequestsAppend(ctx context.Context, values ...KeyValue) {
    list := x.RequestsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// RequestsAppendRaw appends items to the list using Raw struct representations.
func (x ResourceRequirements) RequestsAppendRaw(ctx context.Context, values ...*KeyValueRaw) {
    list := x.RequestsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyValueFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ResourceRequirements) IsSetRequests() bool{
    return x.s.HasField(1)
}

// ClaimsList returns the underlying Structs list for iteration.
// Use NewResourceClaim() to create items and Append to add them.
func (x ResourceRequirements) ClaimsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 2, XXXMappingResourceClaim); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 2, XXXMappingResourceClaim)
    return structs
}

// ClaimsLen returns the number of items in the list.
func (x ResourceRequirements) ClaimsLen(ctx context.Context) int {
    return x.ClaimsList(ctx).Len()
}

// ClaimsGet returns the item at the given index.
func (x ResourceRequirements) ClaimsGet(ctx context.Context, index int) ResourceClaim {
    s := x.ClaimsList(ctx).Get(index)
    return ResourceClaim{s: s}
}

// ClaimsAppend appends items to the list.
func (x ResourceRequirements) ClaimsAppend(ctx context.Context, values ...ResourceClaim) {
    list := x.ClaimsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ClaimsAppendRaw appends items to the list using Raw struct representations.
func (x ResourceRequirements) ClaimsAppendRaw(ctx context.Context, values ...*ResourceClaimRaw) {
    list := x.ClaimsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewResourceClaimFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x ResourceRequirements) IsSetClaims() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ResourceRequirements) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ResourceRequirements) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ResourceRequirements) XXXTypeHash() [16]byte {
    return XXXTypeHashResourceRequirements
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ResourceRequirements) SetRecording(enabled bool) ResourceRequirements {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ResourceRequirements) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ResourceRequirements) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ResourceRequirements) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ResourceRequirementsRaw is a plain Go struct representation of ResourceRequirements.
// Zero values are not set (sparse encoding).
type ResourceRequirementsRaw struct {
    Limits []*KeyValueRaw
    Requests []*KeyValueRaw
    Claims []*ResourceClaimRaw
}

// NewResourceRequirementsFromRaw creates a new ResourceRequirements from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewResourceRequirementsFromRaw(ctx context.Context, raw ResourceRequirementsRaw) ResourceRequirements {
    x := NewResourceRequirements(ctx)
    if raw.Limits != nil {
        list := x.LimitsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Limits))
        for _, r := range raw.Limits {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Requests != nil {
        list := x.RequestsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Requests))
        for _, r := range raw.Requests {
            if r != nil {
                items = append(items, NewKeyValueFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Claims != nil {
        list := x.ClaimsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Claims))
        for _, r := range raw.Claims {
            if r != nil {
                items = append(items, NewResourceClaimFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ResourceRequirements) ToRaw(ctx context.Context) ResourceRequirementsRaw {
    raw := ResourceRequirementsRaw{}
    if l := x.s.GetList(0); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Limits = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Limits[i] = &itemRaw
        }
    } else if x.s.HasField(0) {
        list := x.LimitsList(ctx)
        raw.Limits = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Limits[i] = &itemRaw
        }
    }
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Requests = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Requests[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.RequestsList(ctx)
        raw.Requests = make([]*KeyValueRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyValue{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Requests[i] = &itemRaw
        }
    }
    if l := x.s.GetList(2); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Claims = make([]*ResourceClaimRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ResourceClaim{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Claims[i] = &itemRaw
        }
    } else if x.s.HasField(2) {
        list := x.ClaimsList(ctx)
        raw.Claims = make([]*ResourceClaimRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := ResourceClaim{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Claims[i] = &itemRaw
        }
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ResourceRequirements) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(77)
}

// SELinuxOptions are the labels to be applied to the container.
type SELinuxOptions struct {
   s *segment.Struct
}

// NewSELinuxOptions creates a new pooled instance of SELinuxOptions.
// Call Release() when done to return it to the pool for reuse.
func NewSELinuxOptions(ctx context.Context) SELinuxOptions {
    s := segment.New(ctx, XXXMappingSELinuxOptions)
    s.SetIsSetEnabled(true)
    return SELinuxOptions{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x SELinuxOptions) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSELinuxOptionsFrom creates a new SELinuxOptions from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSELinuxOptionsFrom(s *segment.Struct) SELinuxOptions {
    return SELinuxOptions{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x SELinuxOptions) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x SELinuxOptions) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x SELinuxOptions) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x SELinuxOptions) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x SELinuxOptions) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x SELinuxOptions) User() string {
    return segment.GetString(x.s, 0)
}

func (x SELinuxOptions) SetUser(value string) SELinuxOptions {
    segment.SetString(x.s, 0, value)
    return x
}
func (x SELinuxOptions) IsSetUser() bool{
    return x.s.HasField(0)
}

func (x SELinuxOptions) Role() string {
    return segment.GetString(x.s, 1)
}

func (x SELinuxOptions) SetRole(value string) SELinuxOptions {
    segment.SetString(x.s, 1, value)
    return x
}
func (x SELinuxOptions) IsSetRole() bool{
    return x.s.HasField(1)
}

func (x SELinuxOptions) Type() string {
    return segment.GetString(x.s, 2)
}

func (x SELinuxOptions) SetType(value string) SELinuxOptions {
    segment.SetString(x.s, 2, value)
    return x
}
func (x SELinuxOptions) IsSetType() bool{
    return x.s.HasField(2)
}

func (x SELinuxOptions) Level() string {
    return segment.GetString(x.s, 3)
}

func (x SELinuxOptions) SetLevel(value string) SELinuxOptions {
    segment.SetString(x.s, 3, value)
    return x
}
func (x SELinuxOptions) IsSetLevel() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x SELinuxOptions) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x SELinuxOptions) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x SELinuxOptions) XXXTypeHash() [16]byte {
    return XXXTypeHashSELinuxOptions
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x SELinuxOptions) SetRecording(enabled bool) SELinuxOptions {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x SELinuxOptions) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x SELinuxOptions) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x SELinuxOptions) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SELinuxOptionsRaw is a plain Go struct representation of SELinuxOptions.
// Zero values are not set (sparse encoding).
type SELinuxOptionsRaw struct {
    User string
    Role string
    Type string
    Level string
}

// NewSELinuxOptionsFromRaw creates a new SELinuxOptions from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSELinuxOptionsFromRaw(ctx context.Context, raw SELinuxOptionsRaw) SELinuxOptions {
    x := NewSELinuxOptions(ctx)
    if raw.User != "" {
        x.SetUser(raw.User)
    }
    if raw.Role != "" {
        x.SetRole(raw.Role)
    }
    if raw.Type != "" {
        x.SetType(raw.Type)
    }
    if raw.Level != "" {
        x.SetLevel(raw.Level)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x SELinuxOptions) ToRaw(ctx context.Context) SELinuxOptionsRaw {
    raw := SELinuxOptionsRaw{}
    raw.User = x.User()
    raw.Role = x.Role()
    raw.Type = x.Type()
    raw.Level = x.Level()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x SELinuxOptions) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(78)
}

// SeccompProfile defines a pod/container's seccomp profile settings.
type SeccompProfile struct {
   s *segment.Struct
}

// NewSeccompProfile creates a new pooled instance of SeccompProfile.
// Call Release() when done to return it to the pool for reuse.
func NewSeccompProfile(ctx context.Context) SeccompProfile {
    s := segment.New(ctx, XXXMappingSeccompProfile)
    s.SetIsSetEnabled(true)
    return SeccompProfile{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x SeccompProfile) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSeccompProfileFrom creates a new SeccompProfile from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSeccompProfileFrom(s *segment.Struct) SeccompProfile {
    return SeccompProfile{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x SeccompProfile) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x SeccompProfile) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x SeccompProfile) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x SeccompProfile) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x SeccompProfile) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x SeccompProfile) Type() SeccompProfileType {
    return SeccompProfileType(segment.GetUint8(x.s, 0))
}

func (x SeccompProfile) SetType(value SeccompProfileType) SeccompProfile {
    segment.SetUint8(x.s, 0, uint8(value))
    return x
}
func (x SeccompProfile) IsSetType() bool{
    return x.s.HasField(0)
}

func (x SeccompProfile) LocalhostProfile() string {
    return segment.GetString(x.s, 1)
}

func (x SeccompProfile) SetLocalhostProfile(value string) SeccompProfile {
    segment.SetString(x.s, 1, value)
    return x
}
func (x SeccompProfile) IsSetLocalhostProfile() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x SeccompProfile) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x SeccompProfile) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x SeccompProfile) XXXTypeHash() [16]byte {
    return XXXTypeHashSeccompProfile
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x SeccompProfile) SetRecording(enabled bool) SeccompProfile {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x SeccompProfile) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x SeccompProfile) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x SeccompProfile) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SeccompProfileRaw is a plain Go struct representation of SeccompProfile.
// Zero values are not set (sparse encoding).
type SeccompProfileRaw struct {
    Type SeccompProfileType
    LocalhostProfile string
}

// NewSeccompProfileFromRaw creates a new SeccompProfile from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSeccompProfileFromRaw(ctx context.Context, raw SeccompProfileRaw) SeccompProfile {
    x := NewSeccompProfile(ctx)
    if raw.Type != 0 {
        x.SetType(raw.Type)
    }
    if raw.LocalhostProfile != "" {
        x.SetLocalhostProfile(raw.LocalhostProfile)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x SeccompProfile) ToRaw(ctx context.Context) SeccompProfileRaw {
    raw := SeccompProfileRaw{}
    raw.Type = x.Type()
    raw.LocalhostProfile = x.LocalhostProfile()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x SeccompProfile) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(79)
}

// SecretEnvSource selects a Secret to populate the environment.
type SecretEnvSource struct {
   s *segment.Struct
}

// NewSecretEnvSource creates a new pooled instance of SecretEnvSource.
// Call Release() when done to return it to the pool for reuse.
func NewSecretEnvSource(ctx context.Context) SecretEnvSource {
    s := segment.New(ctx, XXXMappingSecretEnvSource)
    s.SetIsSetEnabled(true)
    return SecretEnvSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x SecretEnvSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSecretEnvSourceFrom creates a new SecretEnvSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSecretEnvSourceFrom(s *segment.Struct) SecretEnvSource {
    return SecretEnvSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x SecretEnvSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x SecretEnvSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x SecretEnvSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x SecretEnvSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x SecretEnvSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x SecretEnvSource) Name() string {
    return segment.GetString(x.s, 0)
}

func (x SecretEnvSource) SetName(value string) SecretEnvSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x SecretEnvSource) IsSetName() bool{
    return x.s.HasField(0)
}

func (x SecretEnvSource) Optional() bool {
    return segment.GetBool(x.s, 1)
}

func (x SecretEnvSource) SetOptional(value bool) SecretEnvSource {
    segment.SetBool(x.s, 1, value)
    return x
}
func (x SecretEnvSource) IsSetOptional() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x SecretEnvSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x SecretEnvSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x SecretEnvSource) XXXTypeHash() [16]byte {
    return XXXTypeHashSecretEnvSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x SecretEnvSource) SetRecording(enabled bool) SecretEnvSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x SecretEnvSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x SecretEnvSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x SecretEnvSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SecretEnvSourceRaw is a plain Go struct representation of SecretEnvSource.
// Zero values are not set (sparse encoding).
type SecretEnvSourceRaw struct {
    Name string
    Optional bool
}

// NewSecretEnvSourceFromRaw creates a new SecretEnvSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSecretEnvSourceFromRaw(ctx context.Context, raw SecretEnvSourceRaw) SecretEnvSource {
    x := NewSecretEnvSource(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x SecretEnvSource) ToRaw(ctx context.Context) SecretEnvSourceRaw {
    raw := SecretEnvSourceRaw{}
    raw.Name = x.Name()
    raw.Optional = x.Optional()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x SecretEnvSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(80)
}

// SecretKeySelector selects a key of a Secret.
type SecretKeySelector struct {
   s *segment.Struct
}

// NewSecretKeySelector creates a new pooled instance of SecretKeySelector.
// Call Release() when done to return it to the pool for reuse.
func NewSecretKeySelector(ctx context.Context) SecretKeySelector {
    s := segment.New(ctx, XXXMappingSecretKeySelector)
    s.SetIsSetEnabled(true)
    return SecretKeySelector{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x SecretKeySelector) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSecretKeySelectorFrom creates a new SecretKeySelector from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSecretKeySelectorFrom(s *segment.Struct) SecretKeySelector {
    return SecretKeySelector{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x SecretKeySelector) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x SecretKeySelector) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x SecretKeySelector) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x SecretKeySelector) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x SecretKeySelector) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x SecretKeySelector) Name() string {
    return segment.GetString(x.s, 0)
}

func (x SecretKeySelector) SetName(value string) SecretKeySelector {
    segment.SetString(x.s, 0, value)
    return x
}
func (x SecretKeySelector) IsSetName() bool{
    return x.s.HasField(0)
}

func (x SecretKeySelector) Key() string {
    return segment.GetString(x.s, 1)
}

func (x SecretKeySelector) SetKey(value string) SecretKeySelector {
    segment.SetString(x.s, 1, value)
    return x
}
func (x SecretKeySelector) IsSetKey() bool{
    return x.s.HasField(1)
}

func (x SecretKeySelector) Optional() bool {
    return segment.GetBool(x.s, 2)
}

func (x SecretKeySelector) SetOptional(value bool) SecretKeySelector {
    segment.SetBool(x.s, 2, value)
    return x
}
func (x SecretKeySelector) IsSetOptional() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x SecretKeySelector) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x SecretKeySelector) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x SecretKeySelector) XXXTypeHash() [16]byte {
    return XXXTypeHashSecretKeySelector
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x SecretKeySelector) SetRecording(enabled bool) SecretKeySelector {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x SecretKeySelector) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x SecretKeySelector) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x SecretKeySelector) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SecretKeySelectorRaw is a plain Go struct representation of SecretKeySelector.
// Zero values are not set (sparse encoding).
type SecretKeySelectorRaw struct {
    Name string
    Key string
    Optional bool
}

// NewSecretKeySelectorFromRaw creates a new SecretKeySelector from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSecretKeySelectorFromRaw(ctx context.Context, raw SecretKeySelectorRaw) SecretKeySelector {
    x := NewSecretKeySelector(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Key != "" {
        x.SetKey(raw.Key)
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x SecretKeySelector) ToRaw(ctx context.Context) SecretKeySelectorRaw {
    raw := SecretKeySelectorRaw{}
    raw.Name = x.Name()
    raw.Key = x.Key()
    raw.Optional = x.Optional()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x SecretKeySelector) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(81)
}

// SecretProjection adapts a secret into a projected volume.
type SecretProjection struct {
   s *segment.Struct
}

// NewSecretProjection creates a new pooled instance of SecretProjection.
// Call Release() when done to return it to the pool for reuse.
func NewSecretProjection(ctx context.Context) SecretProjection {
    s := segment.New(ctx, XXXMappingSecretProjection)
    s.SetIsSetEnabled(true)
    return SecretProjection{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x SecretProjection) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSecretProjectionFrom creates a new SecretProjection from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSecretProjectionFrom(s *segment.Struct) SecretProjection {
    return SecretProjection{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x SecretProjection) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x SecretProjection) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x SecretProjection) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x SecretProjection) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x SecretProjection) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x SecretProjection) Name() string {
    return segment.GetString(x.s, 0)
}

func (x SecretProjection) SetName(value string) SecretProjection {
    segment.SetString(x.s, 0, value)
    return x
}
func (x SecretProjection) IsSetName() bool{
    return x.s.HasField(0)
}

// ItemsList returns the underlying Structs list for iteration.
// Use NewKeyToPath() to create items and Append to add them.
func (x SecretProjection) ItemsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingKeyToPath); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingKeyToPath)
    return structs
}

// ItemsLen returns the number of items in the list.
func (x SecretProjection) ItemsLen(ctx context.Context) int {
    return x.ItemsList(ctx).Len()
}

// ItemsGet returns the item at the given index.
func (x SecretProjection) ItemsGet(ctx context.Context, index int) KeyToPath {
    s := x.ItemsList(ctx).Get(index)
    return KeyToPath{s: s}
}

// ItemsAppend appends items to the list.
func (x SecretProjection) ItemsAppend(ctx context.Context, values ...KeyToPath) {
    list := x.ItemsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ItemsAppendRaw appends items to the list using Raw struct representations.
func (x SecretProjection) ItemsAppendRaw(ctx context.Context, values ...*KeyToPathRaw) {
    list := x.ItemsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyToPathFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x SecretProjection) IsSetItems() bool{
    return x.s.HasField(1)
}

func (x SecretProjection) Optional() bool {
    return segment.GetBool(x.s, 2)
}

func (x SecretProjection) SetOptional(value bool) SecretProjection {
    segment.SetBool(x.s, 2, value)
    return x
}
func (x SecretProjection) IsSetOptional() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x SecretProjection) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x SecretProjection) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x SecretProjection) XXXTypeHash() [16]byte {
    return XXXTypeHashSecretProjection
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x SecretProjection) SetRecording(enabled bool) SecretProjection {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x SecretProjection) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x SecretProjection) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x SecretProjection) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SecretProjectionRaw is a plain Go struct representation of SecretProjection.
// Zero values are not set (sparse encoding).
type SecretProjectionRaw struct {
    Name string
    Items []*KeyToPathRaw
    Optional bool
}

// NewSecretProjectionFromRaw creates a new SecretProjection from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSecretProjectionFromRaw(ctx context.Context, raw SecretProjectionRaw) SecretProjection {
    x := NewSecretProjection(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Items != nil {
        list := x.ItemsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Items))
        for _, r := range raw.Items {
            if r != nil {
                items = append(items, NewKeyToPathFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x SecretProjection) ToRaw(ctx context.Context) SecretProjectionRaw {
    raw := SecretProjectionRaw{}
    raw.Name = x.Name()
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Items = make([]*KeyToPathRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyToPath{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.ItemsList(ctx)
        raw.Items = make([]*KeyToPathRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyToPath{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    }
    raw.Optional = x.Optional()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x SecretProjection) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(82)
}

// SecretVolumeSource adapts a Secret into a volume.
type SecretVolumeSource struct {
   s *segment.Struct
}

// NewSecretVolumeSource creates a new pooled instance of SecretVolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewSecretVolumeSource(ctx context.Context) SecretVolumeSource {
    s := segment.New(ctx, XXXMappingSecretVolumeSource)
    s.SetIsSetEnabled(true)
    return SecretVolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x SecretVolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSecretVolumeSourceFrom creates a new SecretVolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSecretVolumeSourceFrom(s *segment.Struct) SecretVolumeSource {
    return SecretVolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x SecretVolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x SecretVolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x SecretVolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x SecretVolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x SecretVolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x SecretVolumeSource) SecretName() string {
    return segment.GetString(x.s, 0)
}

func (x SecretVolumeSource) SetSecretName(value string) SecretVolumeSource {
    segment.SetString(x.s, 0, value)
    return x
}
func (x SecretVolumeSource) IsSetSecretName() bool{
    return x.s.HasField(0)
}

// ItemsList returns the underlying Structs list for iteration.
// Use NewKeyToPath() to create items and Append to add them.
func (x SecretVolumeSource) ItemsList(ctx context.Context) *segment.Structs {
    // Try to get cached or parse from segment
    if structs := segment.GetListStructs(ctx, x.s, 1, XXXMappingKeyToPath); structs != nil {
        return structs
    }
    // Create new empty list if no data exists
    structs := segment.NewStructs(ctx, x.s, 1, XXXMappingKeyToPath)
    return structs
}

// ItemsLen returns the number of items in the list.
func (x SecretVolumeSource) ItemsLen(ctx context.Context) int {
    return x.ItemsList(ctx).Len()
}

// ItemsGet returns the item at the given index.
func (x SecretVolumeSource) ItemsGet(ctx context.Context, index int) KeyToPath {
    s := x.ItemsList(ctx).Get(index)
    return KeyToPath{s: s}
}

// ItemsAppend appends items to the list.
func (x SecretVolumeSource) ItemsAppend(ctx context.Context, values ...KeyToPath) {
    list := x.ItemsList(ctx)
    for _, v := range values {
        list.Append(v.XXXGetStruct())
    }
}

// ItemsAppendRaw appends items to the list using Raw struct representations.
func (x SecretVolumeSource) ItemsAppendRaw(ctx context.Context, values ...*KeyToPathRaw) {
    list := x.ItemsList(ctx)
    for _, raw := range values {
        if raw != nil {
            list.Append(NewKeyToPathFromRaw(ctx, *raw).XXXGetStruct())
        }
    }
}
func (x SecretVolumeSource) IsSetItems() bool{
    return x.s.HasField(1)
}

func (x SecretVolumeSource) DefaultMode() int32 {
    return segment.GetInt32(x.s, 2)
}

func (x SecretVolumeSource) SetDefaultMode(value int32) SecretVolumeSource {
    segment.SetInt32(x.s, 2, value)
    return x
}
func (x SecretVolumeSource) IsSetDefaultMode() bool{
    return x.s.HasField(2)
}

func (x SecretVolumeSource) Optional() bool {
    return segment.GetBool(x.s, 3)
}

func (x SecretVolumeSource) SetOptional(value bool) SecretVolumeSource {
    segment.SetBool(x.s, 3, value)
    return x
}
func (x SecretVolumeSource) IsSetOptional() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x SecretVolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x SecretVolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x SecretVolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashSecretVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x SecretVolumeSource) SetRecording(enabled bool) SecretVolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x SecretVolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x SecretVolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x SecretVolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SecretVolumeSourceRaw is a plain Go struct representation of SecretVolumeSource.
// Zero values are not set (sparse encoding).
type SecretVolumeSourceRaw struct {
    SecretName string
    Items []*KeyToPathRaw
    DefaultMode int32
    Optional bool
}

// NewSecretVolumeSourceFromRaw creates a new SecretVolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSecretVolumeSourceFromRaw(ctx context.Context, raw SecretVolumeSourceRaw) SecretVolumeSource {
    x := NewSecretVolumeSource(ctx)
    if raw.SecretName != "" {
        x.SetSecretName(raw.SecretName)
    }
    if raw.Items != nil {
        list := x.ItemsList(ctx)
        items := make([]*segment.Struct, 0, len(raw.Items))
        for _, r := range raw.Items {
            if r != nil {
                items = append(items, NewKeyToPathFromRaw(ctx, *r).XXXGetStruct())
            }
        }
        list.SetAll(items)
    }
    if raw.DefaultMode != 0 {
        x.SetDefaultMode(raw.DefaultMode)
    }
    if raw.Optional {
        x.SetOptional(raw.Optional)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x SecretVolumeSource) ToRaw(ctx context.Context) SecretVolumeSourceRaw {
    raw := SecretVolumeSourceRaw{}
    raw.SecretName = x.SecretName()
    if l := x.s.GetList(1); l != nil && l.(*segment.Structs).Len() > 0 {
        list := l.(*segment.Structs)
        raw.Items = make([]*KeyToPathRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyToPath{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    } else if x.s.HasField(1) {
        list := x.ItemsList(ctx)
        raw.Items = make([]*KeyToPathRaw, list.Len())
        for i := 0; i < list.Len(); i++ {
            item := KeyToPath{s: list.Get(i)}
            itemRaw := item.ToRaw(ctx)
            raw.Items[i] = &itemRaw
        }
    }
    raw.DefaultMode = x.DefaultMode()
    raw.Optional = x.Optional()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x SecretVolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(83)
}

// SecurityContext holds security configuration for a container.
type SecurityContext struct {
   s *segment.Struct
}

// NewSecurityContext creates a new pooled instance of SecurityContext.
// Call Release() when done to return it to the pool for reuse.
func NewSecurityContext(ctx context.Context) SecurityContext {
    s := segment.New(ctx, XXXMappingSecurityContext)
    s.SetIsSetEnabled(true)
    return SecurityContext{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x SecurityContext) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSecurityContextFrom creates a new SecurityContext from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSecurityContextFrom(s *segment.Struct) SecurityContext {
    return SecurityContext{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x SecurityContext) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x SecurityContext) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x SecurityContext) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x SecurityContext) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x SecurityContext) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x SecurityContext) Capabilities() Capabilities {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingCapabilities)
    return Capabilities{s: s}
}

func (x SecurityContext) SetCapabilities(value Capabilities) SecurityContext {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x SecurityContext) IsSetCapabilities() bool{
    return x.s.HasField(0)
}

func (x SecurityContext) Privileged() bool {
    return segment.GetBool(x.s, 1)
}

func (x SecurityContext) SetPrivileged(value bool) SecurityContext {
    segment.SetBool(x.s, 1, value)
    return x
}
func (x SecurityContext) IsSetPrivileged() bool{
    return x.s.HasField(1)
}

func (x SecurityContext) SeLinuxOptions() SELinuxOptions {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingSELinuxOptions)
    return SELinuxOptions{s: s}
}

func (x SecurityContext) SetSeLinuxOptions(value SELinuxOptions) SecurityContext {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x SecurityContext) IsSetSeLinuxOptions() bool{
    return x.s.HasField(2)
}

func (x SecurityContext) WindowsOptions() WindowsSecurityContextOptions {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingWindowsSecurityContextOptions)
    return WindowsSecurityContextOptions{s: s}
}

func (x SecurityContext) SetWindowsOptions(value WindowsSecurityContextOptions) SecurityContext {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x SecurityContext) IsSetWindowsOptions() bool{
    return x.s.HasField(3)
}

func (x SecurityContext) RunAsUser() int64 {
    return segment.GetInt64(x.s, 4)
}

func (x SecurityContext) SetRunAsUser(value int64) SecurityContext {
    segment.SetInt64(x.s, 4, value)
    return x
}
func (x SecurityContext) IsSetRunAsUser() bool{
    return x.s.HasField(4)
}

func (x SecurityContext) RunAsGroup() int64 {
    return segment.GetInt64(x.s, 5)
}

func (x SecurityContext) SetRunAsGroup(value int64) SecurityContext {
    segment.SetInt64(x.s, 5, value)
    return x
}
func (x SecurityContext) IsSetRunAsGroup() bool{
    return x.s.HasField(5)
}

func (x SecurityContext) RunAsNonRoot() bool {
    return segment.GetBool(x.s, 6)
}

func (x SecurityContext) SetRunAsNonRoot(value bool) SecurityContext {
    segment.SetBool(x.s, 6, value)
    return x
}
func (x SecurityContext) IsSetRunAsNonRoot() bool{
    return x.s.HasField(6)
}

func (x SecurityContext) ReadOnlyRootFilesystem() bool {
    return segment.GetBool(x.s, 7)
}

func (x SecurityContext) SetReadOnlyRootFilesystem(value bool) SecurityContext {
    segment.SetBool(x.s, 7, value)
    return x
}
func (x SecurityContext) IsSetReadOnlyRootFilesystem() bool{
    return x.s.HasField(7)
}

func (x SecurityContext) AllowPrivilegeEscalation() bool {
    return segment.GetBool(x.s, 8)
}

func (x SecurityContext) SetAllowPrivilegeEscalation(value bool) SecurityContext {
    segment.SetBool(x.s, 8, value)
    return x
}
func (x SecurityContext) IsSetAllowPrivilegeEscalation() bool{
    return x.s.HasField(8)
}

func (x SecurityContext) ProcMount() ProcMountType {
    return ProcMountType(segment.GetUint8(x.s, 9))
}

func (x SecurityContext) SetProcMount(value ProcMountType) SecurityContext {
    segment.SetUint8(x.s, 9, uint8(value))
    return x
}
func (x SecurityContext) IsSetProcMount() bool{
    return x.s.HasField(9)
}

func (x SecurityContext) SeccompProfile() SeccompProfile {
    s := segment.GetNestedStruct(x.s, 10, XXXMappingSeccompProfile)
    return SeccompProfile{s: s}
}

func (x SecurityContext) SetSeccompProfile(value SeccompProfile) SecurityContext {
    segment.SetNestedStruct(x.s, 10, value.XXXGetStruct())
    return x
}
func (x SecurityContext) IsSetSeccompProfile() bool{
    return x.s.HasField(10)
}

func (x SecurityContext) AppArmorProfile() AppArmorProfile {
    s := segment.GetNestedStruct(x.s, 11, XXXMappingAppArmorProfile)
    return AppArmorProfile{s: s}
}

func (x SecurityContext) SetAppArmorProfile(value AppArmorProfile) SecurityContext {
    segment.SetNestedStruct(x.s, 11, value.XXXGetStruct())
    return x
}
func (x SecurityContext) IsSetAppArmorProfile() bool{
    return x.s.HasField(11)
}



// ClawStruct returns a reflection type representing the Struct.
func (x SecurityContext) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x SecurityContext) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x SecurityContext) XXXTypeHash() [16]byte {
    return XXXTypeHashSecurityContext
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x SecurityContext) SetRecording(enabled bool) SecurityContext {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x SecurityContext) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x SecurityContext) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x SecurityContext) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SecurityContextRaw is a plain Go struct representation of SecurityContext.
// Zero values are not set (sparse encoding).
type SecurityContextRaw struct {
    Capabilities *CapabilitiesRaw
    Privileged bool
    SeLinuxOptions *SELinuxOptionsRaw
    WindowsOptions *WindowsSecurityContextOptionsRaw
    RunAsUser int64
    RunAsGroup int64
    RunAsNonRoot bool
    ReadOnlyRootFilesystem bool
    AllowPrivilegeEscalation bool
    ProcMount ProcMountType
    SeccompProfile *SeccompProfileRaw
    AppArmorProfile *AppArmorProfileRaw
}

// NewSecurityContextFromRaw creates a new SecurityContext from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSecurityContextFromRaw(ctx context.Context, raw SecurityContextRaw) SecurityContext {
    x := NewSecurityContext(ctx)
    if raw.Capabilities != nil {
        x.SetCapabilities(NewCapabilitiesFromRaw(ctx, *raw.Capabilities))
    }
    if raw.Privileged {
        x.SetPrivileged(raw.Privileged)
    }
    if raw.SeLinuxOptions != nil {
        x.SetSeLinuxOptions(NewSELinuxOptionsFromRaw(ctx, *raw.SeLinuxOptions))
    }
    if raw.WindowsOptions != nil {
        x.SetWindowsOptions(NewWindowsSecurityContextOptionsFromRaw(ctx, *raw.WindowsOptions))
    }
    if raw.RunAsUser != 0 {
        x.SetRunAsUser(raw.RunAsUser)
    }
    if raw.RunAsGroup != 0 {
        x.SetRunAsGroup(raw.RunAsGroup)
    }
    if raw.RunAsNonRoot {
        x.SetRunAsNonRoot(raw.RunAsNonRoot)
    }
    if raw.ReadOnlyRootFilesystem {
        x.SetReadOnlyRootFilesystem(raw.ReadOnlyRootFilesystem)
    }
    if raw.AllowPrivilegeEscalation {
        x.SetAllowPrivilegeEscalation(raw.AllowPrivilegeEscalation)
    }
    if raw.ProcMount != 0 {
        x.SetProcMount(raw.ProcMount)
    }
    if raw.SeccompProfile != nil {
        x.SetSeccompProfile(NewSeccompProfileFromRaw(ctx, *raw.SeccompProfile))
    }
    if raw.AppArmorProfile != nil {
        x.SetAppArmorProfile(NewAppArmorProfileFromRaw(ctx, *raw.AppArmorProfile))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x SecurityContext) ToRaw(ctx context.Context) SecurityContextRaw {
    raw := SecurityContextRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.Capabilities().ToRaw(ctx)
        raw.Capabilities = &nestedRaw
    }
    raw.Privileged = x.Privileged()
    if x.s.HasField(2) {
        nestedRaw := x.SeLinuxOptions().ToRaw(ctx)
        raw.SeLinuxOptions = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.WindowsOptions().ToRaw(ctx)
        raw.WindowsOptions = &nestedRaw
    }
    raw.RunAsUser = x.RunAsUser()
    raw.RunAsGroup = x.RunAsGroup()
    raw.RunAsNonRoot = x.RunAsNonRoot()
    raw.ReadOnlyRootFilesystem = x.ReadOnlyRootFilesystem()
    raw.AllowPrivilegeEscalation = x.AllowPrivilegeEscalation()
    raw.ProcMount = x.ProcMount()
    if x.s.HasField(10) {
        nestedRaw := x.SeccompProfile().ToRaw(ctx)
        raw.SeccompProfile = &nestedRaw
    }
    if x.s.HasField(11) {
        nestedRaw := x.AppArmorProfile().ToRaw(ctx)
        raw.AppArmorProfile = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x SecurityContext) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(84)
}

// ServiceAccountTokenProjection represents a projected service account token.
type ServiceAccountTokenProjection struct {
   s *segment.Struct
}

// NewServiceAccountTokenProjection creates a new pooled instance of ServiceAccountTokenProjection.
// Call Release() when done to return it to the pool for reuse.
func NewServiceAccountTokenProjection(ctx context.Context) ServiceAccountTokenProjection {
    s := segment.New(ctx, XXXMappingServiceAccountTokenProjection)
    s.SetIsSetEnabled(true)
    return ServiceAccountTokenProjection{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x ServiceAccountTokenProjection) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewServiceAccountTokenProjectionFrom creates a new ServiceAccountTokenProjection from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewServiceAccountTokenProjectionFrom(s *segment.Struct) ServiceAccountTokenProjection {
    return ServiceAccountTokenProjection{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x ServiceAccountTokenProjection) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x ServiceAccountTokenProjection) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x ServiceAccountTokenProjection) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x ServiceAccountTokenProjection) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x ServiceAccountTokenProjection) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x ServiceAccountTokenProjection) Audience() string {
    return segment.GetString(x.s, 0)
}

func (x ServiceAccountTokenProjection) SetAudience(value string) ServiceAccountTokenProjection {
    segment.SetString(x.s, 0, value)
    return x
}
func (x ServiceAccountTokenProjection) IsSetAudience() bool{
    return x.s.HasField(0)
}

func (x ServiceAccountTokenProjection) ExpirationSeconds() int64 {
    return segment.GetInt64(x.s, 1)
}

func (x ServiceAccountTokenProjection) SetExpirationSeconds(value int64) ServiceAccountTokenProjection {
    segment.SetInt64(x.s, 1, value)
    return x
}
func (x ServiceAccountTokenProjection) IsSetExpirationSeconds() bool{
    return x.s.HasField(1)
}

func (x ServiceAccountTokenProjection) Path() string {
    return segment.GetString(x.s, 2)
}

func (x ServiceAccountTokenProjection) SetPath(value string) ServiceAccountTokenProjection {
    segment.SetString(x.s, 2, value)
    return x
}
func (x ServiceAccountTokenProjection) IsSetPath() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x ServiceAccountTokenProjection) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x ServiceAccountTokenProjection) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x ServiceAccountTokenProjection) XXXTypeHash() [16]byte {
    return XXXTypeHashServiceAccountTokenProjection
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x ServiceAccountTokenProjection) SetRecording(enabled bool) ServiceAccountTokenProjection {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x ServiceAccountTokenProjection) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x ServiceAccountTokenProjection) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x ServiceAccountTokenProjection) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// ServiceAccountTokenProjectionRaw is a plain Go struct representation of ServiceAccountTokenProjection.
// Zero values are not set (sparse encoding).
type ServiceAccountTokenProjectionRaw struct {
    Audience string
    ExpirationSeconds int64
    Path string
}

// NewServiceAccountTokenProjectionFromRaw creates a new ServiceAccountTokenProjection from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewServiceAccountTokenProjectionFromRaw(ctx context.Context, raw ServiceAccountTokenProjectionRaw) ServiceAccountTokenProjection {
    x := NewServiceAccountTokenProjection(ctx)
    if raw.Audience != "" {
        x.SetAudience(raw.Audience)
    }
    if raw.ExpirationSeconds != 0 {
        x.SetExpirationSeconds(raw.ExpirationSeconds)
    }
    if raw.Path != "" {
        x.SetPath(raw.Path)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x ServiceAccountTokenProjection) ToRaw(ctx context.Context) ServiceAccountTokenProjectionRaw {
    raw := ServiceAccountTokenProjectionRaw{}
    raw.Audience = x.Audience()
    raw.ExpirationSeconds = x.ExpirationSeconds()
    raw.Path = x.Path()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x ServiceAccountTokenProjection) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(85)
}

// SleepAction is for sleeping in lifecycle hooks.
type SleepAction struct {
   s *segment.Struct
}

// NewSleepAction creates a new pooled instance of SleepAction.
// Call Release() when done to return it to the pool for reuse.
func NewSleepAction(ctx context.Context) SleepAction {
    s := segment.New(ctx, XXXMappingSleepAction)
    s.SetIsSetEnabled(true)
    return SleepAction{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x SleepAction) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSleepActionFrom creates a new SleepAction from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSleepActionFrom(s *segment.Struct) SleepAction {
    return SleepAction{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x SleepAction) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x SleepAction) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x SleepAction) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x SleepAction) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x SleepAction) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x SleepAction) Seconds() int64 {
    return segment.GetInt64(x.s, 0)
}

func (x SleepAction) SetSeconds(value int64) SleepAction {
    segment.SetInt64(x.s, 0, value)
    return x
}
func (x SleepAction) IsSetSeconds() bool{
    return x.s.HasField(0)
}



// ClawStruct returns a reflection type representing the Struct.
func (x SleepAction) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x SleepAction) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x SleepAction) XXXTypeHash() [16]byte {
    return XXXTypeHashSleepAction
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x SleepAction) SetRecording(enabled bool) SleepAction {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x SleepAction) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x SleepAction) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x SleepAction) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SleepActionRaw is a plain Go struct representation of SleepAction.
// Zero values are not set (sparse encoding).
type SleepActionRaw struct {
    Seconds int64
}

// NewSleepActionFromRaw creates a new SleepAction from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSleepActionFromRaw(ctx context.Context, raw SleepActionRaw) SleepAction {
    x := NewSleepAction(ctx)
    if raw.Seconds != 0 {
        x.SetSeconds(raw.Seconds)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x SleepAction) ToRaw(ctx context.Context) SleepActionRaw {
    raw := SleepActionRaw{}
    raw.Seconds = x.Seconds()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x SleepAction) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(86)
}

// Sysctl defines a kernel parameter to be set.
type Sysctl struct {
   s *segment.Struct
}

// NewSysctl creates a new pooled instance of Sysctl.
// Call Release() when done to return it to the pool for reuse.
func NewSysctl(ctx context.Context) Sysctl {
    s := segment.New(ctx, XXXMappingSysctl)
    s.SetIsSetEnabled(true)
    return Sysctl{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Sysctl) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewSysctlFrom creates a new Sysctl from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewSysctlFrom(s *segment.Struct) Sysctl {
    return Sysctl{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Sysctl) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Sysctl) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Sysctl) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Sysctl) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Sysctl) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Sysctl) Name() string {
    return segment.GetString(x.s, 0)
}

func (x Sysctl) SetName(value string) Sysctl {
    segment.SetString(x.s, 0, value)
    return x
}
func (x Sysctl) IsSetName() bool{
    return x.s.HasField(0)
}

func (x Sysctl) Value() string {
    return segment.GetString(x.s, 1)
}

func (x Sysctl) SetValue(value string) Sysctl {
    segment.SetString(x.s, 1, value)
    return x
}
func (x Sysctl) IsSetValue() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Sysctl) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Sysctl) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Sysctl) XXXTypeHash() [16]byte {
    return XXXTypeHashSysctl
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Sysctl) SetRecording(enabled bool) Sysctl {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Sysctl) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Sysctl) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Sysctl) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// SysctlRaw is a plain Go struct representation of Sysctl.
// Zero values are not set (sparse encoding).
type SysctlRaw struct {
    Name string
    Value string
}

// NewSysctlFromRaw creates a new Sysctl from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewSysctlFromRaw(ctx context.Context, raw SysctlRaw) Sysctl {
    x := NewSysctl(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Value != "" {
        x.SetValue(raw.Value)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Sysctl) ToRaw(ctx context.Context) SysctlRaw {
    raw := SysctlRaw{}
    raw.Name = x.Name()
    raw.Value = x.Value()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Sysctl) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(87)
}

// TCPSocketAction describes an action based on opening a socket.
type TCPSocketAction struct {
   s *segment.Struct
}

// NewTCPSocketAction creates a new pooled instance of TCPSocketAction.
// Call Release() when done to return it to the pool for reuse.
func NewTCPSocketAction(ctx context.Context) TCPSocketAction {
    s := segment.New(ctx, XXXMappingTCPSocketAction)
    s.SetIsSetEnabled(true)
    return TCPSocketAction{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x TCPSocketAction) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewTCPSocketActionFrom creates a new TCPSocketAction from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewTCPSocketActionFrom(s *segment.Struct) TCPSocketAction {
    return TCPSocketAction{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x TCPSocketAction) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x TCPSocketAction) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x TCPSocketAction) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x TCPSocketAction) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x TCPSocketAction) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x TCPSocketAction) Port() IntOrString {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingIntOrString)
    return IntOrString{s: s}
}

func (x TCPSocketAction) SetPort(value IntOrString) TCPSocketAction {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x TCPSocketAction) IsSetPort() bool{
    return x.s.HasField(0)
}

func (x TCPSocketAction) Host() string {
    return segment.GetString(x.s, 1)
}

func (x TCPSocketAction) SetHost(value string) TCPSocketAction {
    segment.SetString(x.s, 1, value)
    return x
}
func (x TCPSocketAction) IsSetHost() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x TCPSocketAction) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x TCPSocketAction) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x TCPSocketAction) XXXTypeHash() [16]byte {
    return XXXTypeHashTCPSocketAction
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x TCPSocketAction) SetRecording(enabled bool) TCPSocketAction {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x TCPSocketAction) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x TCPSocketAction) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x TCPSocketAction) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// TCPSocketActionRaw is a plain Go struct representation of TCPSocketAction.
// Zero values are not set (sparse encoding).
type TCPSocketActionRaw struct {
    Port *IntOrStringRaw
    Host string
}

// NewTCPSocketActionFromRaw creates a new TCPSocketAction from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewTCPSocketActionFromRaw(ctx context.Context, raw TCPSocketActionRaw) TCPSocketAction {
    x := NewTCPSocketAction(ctx)
    if raw.Port != nil {
        x.SetPort(NewIntOrStringFromRaw(ctx, *raw.Port))
    }
    if raw.Host != "" {
        x.SetHost(raw.Host)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x TCPSocketAction) ToRaw(ctx context.Context) TCPSocketActionRaw {
    raw := TCPSocketActionRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.Port().ToRaw(ctx)
        raw.Port = &nestedRaw
    }
    raw.Host = x.Host()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x TCPSocketAction) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(88)
}

// Time represents a timestamp.
type Time struct {
   s *segment.Struct
}

// NewTime creates a new pooled instance of Time.
// Call Release() when done to return it to the pool for reuse.
func NewTime(ctx context.Context) Time {
    s := segment.New(ctx, XXXMappingTime)
    s.SetIsSetEnabled(true)
    return Time{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Time) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewTimeFrom creates a new Time from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewTimeFrom(s *segment.Struct) Time {
    return Time{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Time) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Time) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Time) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Time) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Time) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Time) Seconds() int64 {
    return segment.GetInt64(x.s, 0)
}

func (x Time) SetSeconds(value int64) Time {
    segment.SetInt64(x.s, 0, value)
    return x
}
func (x Time) IsSetSeconds() bool{
    return x.s.HasField(0)
}

func (x Time) Nanos() int32 {
    return segment.GetInt32(x.s, 1)
}

func (x Time) SetNanos(value int32) Time {
    segment.SetInt32(x.s, 1, value)
    return x
}
func (x Time) IsSetNanos() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Time) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Time) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Time) XXXTypeHash() [16]byte {
    return XXXTypeHashTime
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Time) SetRecording(enabled bool) Time {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Time) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Time) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Time) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// TimeRaw is a plain Go struct representation of Time.
// Zero values are not set (sparse encoding).
type TimeRaw struct {
    Seconds int64
    Nanos int32
}

// NewTimeFromRaw creates a new Time from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewTimeFromRaw(ctx context.Context, raw TimeRaw) Time {
    x := NewTime(ctx)
    if raw.Seconds != 0 {
        x.SetSeconds(raw.Seconds)
    }
    if raw.Nanos != 0 {
        x.SetNanos(raw.Nanos)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Time) ToRaw(ctx context.Context) TimeRaw {
    raw := TimeRaw{}
    raw.Seconds = x.Seconds()
    raw.Nanos = x.Nanos()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Time) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(89)
}

// Toleration defines that a pod tolerates a taint.
type Toleration struct {
   s *segment.Struct
}

// NewToleration creates a new pooled instance of Toleration.
// Call Release() when done to return it to the pool for reuse.
func NewToleration(ctx context.Context) Toleration {
    s := segment.New(ctx, XXXMappingToleration)
    s.SetIsSetEnabled(true)
    return Toleration{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Toleration) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewTolerationFrom creates a new Toleration from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewTolerationFrom(s *segment.Struct) Toleration {
    return Toleration{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Toleration) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Toleration) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Toleration) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Toleration) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Toleration) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Toleration) Key() string {
    return segment.GetString(x.s, 0)
}

func (x Toleration) SetKey(value string) Toleration {
    segment.SetString(x.s, 0, value)
    return x
}
func (x Toleration) IsSetKey() bool{
    return x.s.HasField(0)
}

func (x Toleration) Operator() TolerationOperator {
    return TolerationOperator(segment.GetUint8(x.s, 1))
}

func (x Toleration) SetOperator(value TolerationOperator) Toleration {
    segment.SetUint8(x.s, 1, uint8(value))
    return x
}
func (x Toleration) IsSetOperator() bool{
    return x.s.HasField(1)
}

func (x Toleration) Value() string {
    return segment.GetString(x.s, 2)
}

func (x Toleration) SetValue(value string) Toleration {
    segment.SetString(x.s, 2, value)
    return x
}
func (x Toleration) IsSetValue() bool{
    return x.s.HasField(2)
}

func (x Toleration) Effect() TaintEffect {
    return TaintEffect(segment.GetUint8(x.s, 3))
}

func (x Toleration) SetEffect(value TaintEffect) Toleration {
    segment.SetUint8(x.s, 3, uint8(value))
    return x
}
func (x Toleration) IsSetEffect() bool{
    return x.s.HasField(3)
}

func (x Toleration) TolerationSeconds() int64 {
    return segment.GetInt64(x.s, 4)
}

func (x Toleration) SetTolerationSeconds(value int64) Toleration {
    segment.SetInt64(x.s, 4, value)
    return x
}
func (x Toleration) IsSetTolerationSeconds() bool{
    return x.s.HasField(4)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Toleration) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Toleration) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Toleration) XXXTypeHash() [16]byte {
    return XXXTypeHashToleration
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Toleration) SetRecording(enabled bool) Toleration {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Toleration) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Toleration) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Toleration) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// TolerationRaw is a plain Go struct representation of Toleration.
// Zero values are not set (sparse encoding).
type TolerationRaw struct {
    Key string
    Operator TolerationOperator
    Value string
    Effect TaintEffect
    TolerationSeconds int64
}

// NewTolerationFromRaw creates a new Toleration from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewTolerationFromRaw(ctx context.Context, raw TolerationRaw) Toleration {
    x := NewToleration(ctx)
    if raw.Key != "" {
        x.SetKey(raw.Key)
    }
    if raw.Operator != 0 {
        x.SetOperator(raw.Operator)
    }
    if raw.Value != "" {
        x.SetValue(raw.Value)
    }
    if raw.Effect != 0 {
        x.SetEffect(raw.Effect)
    }
    if raw.TolerationSeconds != 0 {
        x.SetTolerationSeconds(raw.TolerationSeconds)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Toleration) ToRaw(ctx context.Context) TolerationRaw {
    raw := TolerationRaw{}
    raw.Key = x.Key()
    raw.Operator = x.Operator()
    raw.Value = x.Value()
    raw.Effect = x.Effect()
    raw.TolerationSeconds = x.TolerationSeconds()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Toleration) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(90)
}

// TopologySpreadConstraint specifies how to spread matching pods.
type TopologySpreadConstraint struct {
   s *segment.Struct
}

// NewTopologySpreadConstraint creates a new pooled instance of TopologySpreadConstraint.
// Call Release() when done to return it to the pool for reuse.
func NewTopologySpreadConstraint(ctx context.Context) TopologySpreadConstraint {
    s := segment.New(ctx, XXXMappingTopologySpreadConstraint)
    s.SetIsSetEnabled(true)
    return TopologySpreadConstraint{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x TopologySpreadConstraint) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewTopologySpreadConstraintFrom creates a new TopologySpreadConstraint from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewTopologySpreadConstraintFrom(s *segment.Struct) TopologySpreadConstraint {
    return TopologySpreadConstraint{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x TopologySpreadConstraint) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x TopologySpreadConstraint) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x TopologySpreadConstraint) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x TopologySpreadConstraint) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x TopologySpreadConstraint) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x TopologySpreadConstraint) MaxSkew() int32 {
    return segment.GetInt32(x.s, 0)
}

func (x TopologySpreadConstraint) SetMaxSkew(value int32) TopologySpreadConstraint {
    segment.SetInt32(x.s, 0, value)
    return x
}
func (x TopologySpreadConstraint) IsSetMaxSkew() bool{
    return x.s.HasField(0)
}

func (x TopologySpreadConstraint) TopologyKey() string {
    return segment.GetString(x.s, 1)
}

func (x TopologySpreadConstraint) SetTopologyKey(value string) TopologySpreadConstraint {
    segment.SetString(x.s, 1, value)
    return x
}
func (x TopologySpreadConstraint) IsSetTopologyKey() bool{
    return x.s.HasField(1)
}

func (x TopologySpreadConstraint) WhenUnsatisfiable() UnsatisfiableConstraintAction {
    return UnsatisfiableConstraintAction(segment.GetUint8(x.s, 2))
}

func (x TopologySpreadConstraint) SetWhenUnsatisfiable(value UnsatisfiableConstraintAction) TopologySpreadConstraint {
    segment.SetUint8(x.s, 2, uint8(value))
    return x
}
func (x TopologySpreadConstraint) IsSetWhenUnsatisfiable() bool{
    return x.s.HasField(2)
}

func (x TopologySpreadConstraint) LabelSelector() LabelSelector {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingLabelSelector)
    return LabelSelector{s: s}
}

func (x TopologySpreadConstraint) SetLabelSelector(value LabelSelector) TopologySpreadConstraint {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x TopologySpreadConstraint) IsSetLabelSelector() bool{
    return x.s.HasField(3)
}

func (x TopologySpreadConstraint) MinDomains() int32 {
    return segment.GetInt32(x.s, 4)
}

func (x TopologySpreadConstraint) SetMinDomains(value int32) TopologySpreadConstraint {
    segment.SetInt32(x.s, 4, value)
    return x
}
func (x TopologySpreadConstraint) IsSetMinDomains() bool{
    return x.s.HasField(4)
}

func (x TopologySpreadConstraint) NodeAffinityPolicy() NodeInclusionPolicy {
    return NodeInclusionPolicy(segment.GetUint8(x.s, 5))
}

func (x TopologySpreadConstraint) SetNodeAffinityPolicy(value NodeInclusionPolicy) TopologySpreadConstraint {
    segment.SetUint8(x.s, 5, uint8(value))
    return x
}
func (x TopologySpreadConstraint) IsSetNodeAffinityPolicy() bool{
    return x.s.HasField(5)
}

func (x TopologySpreadConstraint) NodeTaintsPolicy() NodeInclusionPolicy {
    return NodeInclusionPolicy(segment.GetUint8(x.s, 6))
}

func (x TopologySpreadConstraint) SetNodeTaintsPolicy(value NodeInclusionPolicy) TopologySpreadConstraint {
    segment.SetUint8(x.s, 6, uint8(value))
    return x
}
func (x TopologySpreadConstraint) IsSetNodeTaintsPolicy() bool{
    return x.s.HasField(6)
}

func (x TopologySpreadConstraint) MatchLabelKeys() *segment.Strings {
    // Try to get cached or parse from segment
    if strs := segment.GetListStrings(x.s, 7); strs != nil {
        return strs
    }
    // Create new empty list if no data exists
    strs := segment.NewStrings(x.s, 7)
    return strs
}

// SetMatchLabelKeys replaces all values in the string list.
func (x TopologySpreadConstraint) SetMatchLabelKeys(v ...string) TopologySpreadConstraint {
    strs := x.MatchLabelKeys()
    strs.SetAll(v)
    return x
}
func (x TopologySpreadConstraint) IsSetMatchLabelKeys() bool{
    return x.s.HasField(7)
}



// ClawStruct returns a reflection type representing the Struct.
func (x TopologySpreadConstraint) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x TopologySpreadConstraint) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x TopologySpreadConstraint) XXXTypeHash() [16]byte {
    return XXXTypeHashTopologySpreadConstraint
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x TopologySpreadConstraint) SetRecording(enabled bool) TopologySpreadConstraint {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x TopologySpreadConstraint) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x TopologySpreadConstraint) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x TopologySpreadConstraint) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// TopologySpreadConstraintRaw is a plain Go struct representation of TopologySpreadConstraint.
// Zero values are not set (sparse encoding).
type TopologySpreadConstraintRaw struct {
    MaxSkew int32
    TopologyKey string
    WhenUnsatisfiable UnsatisfiableConstraintAction
    LabelSelector *LabelSelectorRaw
    MinDomains int32
    NodeAffinityPolicy NodeInclusionPolicy
    NodeTaintsPolicy NodeInclusionPolicy
    MatchLabelKeys []string
}

// NewTopologySpreadConstraintFromRaw creates a new TopologySpreadConstraint from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewTopologySpreadConstraintFromRaw(ctx context.Context, raw TopologySpreadConstraintRaw) TopologySpreadConstraint {
    x := NewTopologySpreadConstraint(ctx)
    if raw.MaxSkew != 0 {
        x.SetMaxSkew(raw.MaxSkew)
    }
    if raw.TopologyKey != "" {
        x.SetTopologyKey(raw.TopologyKey)
    }
    if raw.WhenUnsatisfiable != 0 {
        x.SetWhenUnsatisfiable(raw.WhenUnsatisfiable)
    }
    if raw.LabelSelector != nil {
        x.SetLabelSelector(NewLabelSelectorFromRaw(ctx, *raw.LabelSelector))
    }
    if raw.MinDomains != 0 {
        x.SetMinDomains(raw.MinDomains)
    }
    if raw.NodeAffinityPolicy != 0 {
        x.SetNodeAffinityPolicy(raw.NodeAffinityPolicy)
    }
    if raw.NodeTaintsPolicy != 0 {
        x.SetNodeTaintsPolicy(raw.NodeTaintsPolicy)
    }
    if raw.MatchLabelKeys != nil {
        x.SetMatchLabelKeys(raw.MatchLabelKeys...)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x TopologySpreadConstraint) ToRaw(ctx context.Context) TopologySpreadConstraintRaw {
    raw := TopologySpreadConstraintRaw{}
    raw.MaxSkew = x.MaxSkew()
    raw.TopologyKey = x.TopologyKey()
    raw.WhenUnsatisfiable = x.WhenUnsatisfiable()
    if x.s.HasField(3) {
        nestedRaw := x.LabelSelector().ToRaw(ctx)
        raw.LabelSelector = &nestedRaw
    }
    raw.MinDomains = x.MinDomains()
    raw.NodeAffinityPolicy = x.NodeAffinityPolicy()
    raw.NodeTaintsPolicy = x.NodeTaintsPolicy()
    if l := x.s.GetList(7); l != nil && l.(*segment.Strings).Len() > 0 {
        raw.MatchLabelKeys = l.(*segment.Strings).Slice()
    } else if x.s.HasField(7) {
        raw.MatchLabelKeys = x.MatchLabelKeys().Slice()
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x TopologySpreadConstraint) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(91)
}

// TypeMeta describes an individual object in an API response or request.
type TypeMeta struct {
   s *segment.Struct
}

// NewTypeMeta creates a new pooled instance of TypeMeta.
// Call Release() when done to return it to the pool for reuse.
func NewTypeMeta(ctx context.Context) TypeMeta {
    s := segment.New(ctx, XXXMappingTypeMeta)
    s.SetIsSetEnabled(true)
    return TypeMeta{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x TypeMeta) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewTypeMetaFrom creates a new TypeMeta from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewTypeMetaFrom(s *segment.Struct) TypeMeta {
    return TypeMeta{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x TypeMeta) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x TypeMeta) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x TypeMeta) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x TypeMeta) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x TypeMeta) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x TypeMeta) Kind() string {
    return segment.GetString(x.s, 0)
}

func (x TypeMeta) SetKind(value string) TypeMeta {
    segment.SetString(x.s, 0, value)
    return x
}
func (x TypeMeta) IsSetKind() bool{
    return x.s.HasField(0)
}

func (x TypeMeta) ApiVersion() string {
    return segment.GetString(x.s, 1)
}

func (x TypeMeta) SetApiVersion(value string) TypeMeta {
    segment.SetString(x.s, 1, value)
    return x
}
func (x TypeMeta) IsSetApiVersion() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x TypeMeta) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x TypeMeta) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x TypeMeta) XXXTypeHash() [16]byte {
    return XXXTypeHashTypeMeta
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x TypeMeta) SetRecording(enabled bool) TypeMeta {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x TypeMeta) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x TypeMeta) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x TypeMeta) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// TypeMetaRaw is a plain Go struct representation of TypeMeta.
// Zero values are not set (sparse encoding).
type TypeMetaRaw struct {
    Kind string
    ApiVersion string
}

// NewTypeMetaFromRaw creates a new TypeMeta from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewTypeMetaFromRaw(ctx context.Context, raw TypeMetaRaw) TypeMeta {
    x := NewTypeMeta(ctx)
    if raw.Kind != "" {
        x.SetKind(raw.Kind)
    }
    if raw.ApiVersion != "" {
        x.SetApiVersion(raw.ApiVersion)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x TypeMeta) ToRaw(ctx context.Context) TypeMetaRaw {
    raw := TypeMetaRaw{}
    raw.Kind = x.Kind()
    raw.ApiVersion = x.ApiVersion()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x TypeMeta) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(92)
}

// TypedLocalObjectReference contains enough information to locate the typed referenced object.
type TypedLocalObjectReference struct {
   s *segment.Struct
}

// NewTypedLocalObjectReference creates a new pooled instance of TypedLocalObjectReference.
// Call Release() when done to return it to the pool for reuse.
func NewTypedLocalObjectReference(ctx context.Context) TypedLocalObjectReference {
    s := segment.New(ctx, XXXMappingTypedLocalObjectReference)
    s.SetIsSetEnabled(true)
    return TypedLocalObjectReference{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x TypedLocalObjectReference) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewTypedLocalObjectReferenceFrom creates a new TypedLocalObjectReference from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewTypedLocalObjectReferenceFrom(s *segment.Struct) TypedLocalObjectReference {
    return TypedLocalObjectReference{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x TypedLocalObjectReference) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x TypedLocalObjectReference) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x TypedLocalObjectReference) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x TypedLocalObjectReference) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x TypedLocalObjectReference) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x TypedLocalObjectReference) ApiGroup() string {
    return segment.GetString(x.s, 0)
}

func (x TypedLocalObjectReference) SetApiGroup(value string) TypedLocalObjectReference {
    segment.SetString(x.s, 0, value)
    return x
}
func (x TypedLocalObjectReference) IsSetApiGroup() bool{
    return x.s.HasField(0)
}

func (x TypedLocalObjectReference) Kind() string {
    return segment.GetString(x.s, 1)
}

func (x TypedLocalObjectReference) SetKind(value string) TypedLocalObjectReference {
    segment.SetString(x.s, 1, value)
    return x
}
func (x TypedLocalObjectReference) IsSetKind() bool{
    return x.s.HasField(1)
}

func (x TypedLocalObjectReference) Name() string {
    return segment.GetString(x.s, 2)
}

func (x TypedLocalObjectReference) SetName(value string) TypedLocalObjectReference {
    segment.SetString(x.s, 2, value)
    return x
}
func (x TypedLocalObjectReference) IsSetName() bool{
    return x.s.HasField(2)
}



// ClawStruct returns a reflection type representing the Struct.
func (x TypedLocalObjectReference) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x TypedLocalObjectReference) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x TypedLocalObjectReference) XXXTypeHash() [16]byte {
    return XXXTypeHashTypedLocalObjectReference
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x TypedLocalObjectReference) SetRecording(enabled bool) TypedLocalObjectReference {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x TypedLocalObjectReference) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x TypedLocalObjectReference) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x TypedLocalObjectReference) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// TypedLocalObjectReferenceRaw is a plain Go struct representation of TypedLocalObjectReference.
// Zero values are not set (sparse encoding).
type TypedLocalObjectReferenceRaw struct {
    ApiGroup string
    Kind string
    Name string
}

// NewTypedLocalObjectReferenceFromRaw creates a new TypedLocalObjectReference from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewTypedLocalObjectReferenceFromRaw(ctx context.Context, raw TypedLocalObjectReferenceRaw) TypedLocalObjectReference {
    x := NewTypedLocalObjectReference(ctx)
    if raw.ApiGroup != "" {
        x.SetApiGroup(raw.ApiGroup)
    }
    if raw.Kind != "" {
        x.SetKind(raw.Kind)
    }
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x TypedLocalObjectReference) ToRaw(ctx context.Context) TypedLocalObjectReferenceRaw {
    raw := TypedLocalObjectReferenceRaw{}
    raw.ApiGroup = x.ApiGroup()
    raw.Kind = x.Kind()
    raw.Name = x.Name()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x TypedLocalObjectReference) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(93)
}

// TypedObjectReference contains enough information to locate the typed referenced object.
type TypedObjectReference struct {
   s *segment.Struct
}

// NewTypedObjectReference creates a new pooled instance of TypedObjectReference.
// Call Release() when done to return it to the pool for reuse.
func NewTypedObjectReference(ctx context.Context) TypedObjectReference {
    s := segment.New(ctx, XXXMappingTypedObjectReference)
    s.SetIsSetEnabled(true)
    return TypedObjectReference{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x TypedObjectReference) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewTypedObjectReferenceFrom creates a new TypedObjectReference from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewTypedObjectReferenceFrom(s *segment.Struct) TypedObjectReference {
    return TypedObjectReference{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x TypedObjectReference) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x TypedObjectReference) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x TypedObjectReference) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x TypedObjectReference) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x TypedObjectReference) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x TypedObjectReference) ApiGroup() string {
    return segment.GetString(x.s, 0)
}

func (x TypedObjectReference) SetApiGroup(value string) TypedObjectReference {
    segment.SetString(x.s, 0, value)
    return x
}
func (x TypedObjectReference) IsSetApiGroup() bool{
    return x.s.HasField(0)
}

func (x TypedObjectReference) Kind() string {
    return segment.GetString(x.s, 1)
}

func (x TypedObjectReference) SetKind(value string) TypedObjectReference {
    segment.SetString(x.s, 1, value)
    return x
}
func (x TypedObjectReference) IsSetKind() bool{
    return x.s.HasField(1)
}

func (x TypedObjectReference) Name() string {
    return segment.GetString(x.s, 2)
}

func (x TypedObjectReference) SetName(value string) TypedObjectReference {
    segment.SetString(x.s, 2, value)
    return x
}
func (x TypedObjectReference) IsSetName() bool{
    return x.s.HasField(2)
}

func (x TypedObjectReference) Namespace() string {
    return segment.GetString(x.s, 3)
}

func (x TypedObjectReference) SetNamespace(value string) TypedObjectReference {
    segment.SetString(x.s, 3, value)
    return x
}
func (x TypedObjectReference) IsSetNamespace() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x TypedObjectReference) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x TypedObjectReference) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x TypedObjectReference) XXXTypeHash() [16]byte {
    return XXXTypeHashTypedObjectReference
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x TypedObjectReference) SetRecording(enabled bool) TypedObjectReference {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x TypedObjectReference) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x TypedObjectReference) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x TypedObjectReference) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// TypedObjectReferenceRaw is a plain Go struct representation of TypedObjectReference.
// Zero values are not set (sparse encoding).
type TypedObjectReferenceRaw struct {
    ApiGroup string
    Kind string
    Name string
    Namespace string
}

// NewTypedObjectReferenceFromRaw creates a new TypedObjectReference from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewTypedObjectReferenceFromRaw(ctx context.Context, raw TypedObjectReferenceRaw) TypedObjectReference {
    x := NewTypedObjectReference(ctx)
    if raw.ApiGroup != "" {
        x.SetApiGroup(raw.ApiGroup)
    }
    if raw.Kind != "" {
        x.SetKind(raw.Kind)
    }
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.Namespace != "" {
        x.SetNamespace(raw.Namespace)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x TypedObjectReference) ToRaw(ctx context.Context) TypedObjectReferenceRaw {
    raw := TypedObjectReferenceRaw{}
    raw.ApiGroup = x.ApiGroup()
    raw.Kind = x.Kind()
    raw.Name = x.Name()
    raw.Namespace = x.Namespace()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x TypedObjectReference) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(94)
}

// Volume represents a named volume in a pod.
type Volume struct {
   s *segment.Struct
}

// NewVolume creates a new pooled instance of Volume.
// Call Release() when done to return it to the pool for reuse.
func NewVolume(ctx context.Context) Volume {
    s := segment.New(ctx, XXXMappingVolume)
    s.SetIsSetEnabled(true)
    return Volume{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x Volume) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewVolumeFrom creates a new Volume from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewVolumeFrom(s *segment.Struct) Volume {
    return Volume{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x Volume) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x Volume) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x Volume) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x Volume) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x Volume) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x Volume) Name() string {
    return segment.GetString(x.s, 0)
}

func (x Volume) SetName(value string) Volume {
    segment.SetString(x.s, 0, value)
    return x
}
func (x Volume) IsSetName() bool{
    return x.s.HasField(0)
}

func (x Volume) VolumeSource() VolumeSource {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingVolumeSource)
    return VolumeSource{s: s}
}

func (x Volume) SetVolumeSource(value VolumeSource) Volume {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x Volume) IsSetVolumeSource() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x Volume) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x Volume) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x Volume) XXXTypeHash() [16]byte {
    return XXXTypeHashVolume
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x Volume) SetRecording(enabled bool) Volume {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x Volume) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x Volume) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x Volume) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// VolumeRaw is a plain Go struct representation of Volume.
// Zero values are not set (sparse encoding).
type VolumeRaw struct {
    Name string
    VolumeSource *VolumeSourceRaw
}

// NewVolumeFromRaw creates a new Volume from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewVolumeFromRaw(ctx context.Context, raw VolumeRaw) Volume {
    x := NewVolume(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.VolumeSource != nil {
        x.SetVolumeSource(NewVolumeSourceFromRaw(ctx, *raw.VolumeSource))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x Volume) ToRaw(ctx context.Context) VolumeRaw {
    raw := VolumeRaw{}
    raw.Name = x.Name()
    if x.s.HasField(1) {
        nestedRaw := x.VolumeSource().ToRaw(ctx)
        raw.VolumeSource = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x Volume) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(95)
}

// VolumeDevice describes a mapping of a raw block device within a container.
type VolumeDevice struct {
   s *segment.Struct
}

// NewVolumeDevice creates a new pooled instance of VolumeDevice.
// Call Release() when done to return it to the pool for reuse.
func NewVolumeDevice(ctx context.Context) VolumeDevice {
    s := segment.New(ctx, XXXMappingVolumeDevice)
    s.SetIsSetEnabled(true)
    return VolumeDevice{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x VolumeDevice) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewVolumeDeviceFrom creates a new VolumeDevice from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewVolumeDeviceFrom(s *segment.Struct) VolumeDevice {
    return VolumeDevice{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x VolumeDevice) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x VolumeDevice) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x VolumeDevice) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x VolumeDevice) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x VolumeDevice) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x VolumeDevice) Name() string {
    return segment.GetString(x.s, 0)
}

func (x VolumeDevice) SetName(value string) VolumeDevice {
    segment.SetString(x.s, 0, value)
    return x
}
func (x VolumeDevice) IsSetName() bool{
    return x.s.HasField(0)
}

func (x VolumeDevice) DevicePath() string {
    return segment.GetString(x.s, 1)
}

func (x VolumeDevice) SetDevicePath(value string) VolumeDevice {
    segment.SetString(x.s, 1, value)
    return x
}
func (x VolumeDevice) IsSetDevicePath() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x VolumeDevice) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x VolumeDevice) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x VolumeDevice) XXXTypeHash() [16]byte {
    return XXXTypeHashVolumeDevice
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x VolumeDevice) SetRecording(enabled bool) VolumeDevice {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x VolumeDevice) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x VolumeDevice) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x VolumeDevice) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// VolumeDeviceRaw is a plain Go struct representation of VolumeDevice.
// Zero values are not set (sparse encoding).
type VolumeDeviceRaw struct {
    Name string
    DevicePath string
}

// NewVolumeDeviceFromRaw creates a new VolumeDevice from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewVolumeDeviceFromRaw(ctx context.Context, raw VolumeDeviceRaw) VolumeDevice {
    x := NewVolumeDevice(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.DevicePath != "" {
        x.SetDevicePath(raw.DevicePath)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x VolumeDevice) ToRaw(ctx context.Context) VolumeDeviceRaw {
    raw := VolumeDeviceRaw{}
    raw.Name = x.Name()
    raw.DevicePath = x.DevicePath()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x VolumeDevice) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(96)
}

// VolumeMount describes a mounting of a Volume within a container.
type VolumeMount struct {
   s *segment.Struct
}

// NewVolumeMount creates a new pooled instance of VolumeMount.
// Call Release() when done to return it to the pool for reuse.
func NewVolumeMount(ctx context.Context) VolumeMount {
    s := segment.New(ctx, XXXMappingVolumeMount)
    s.SetIsSetEnabled(true)
    return VolumeMount{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x VolumeMount) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewVolumeMountFrom creates a new VolumeMount from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewVolumeMountFrom(s *segment.Struct) VolumeMount {
    return VolumeMount{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x VolumeMount) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x VolumeMount) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x VolumeMount) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x VolumeMount) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x VolumeMount) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x VolumeMount) Name() string {
    return segment.GetString(x.s, 0)
}

func (x VolumeMount) SetName(value string) VolumeMount {
    segment.SetString(x.s, 0, value)
    return x
}
func (x VolumeMount) IsSetName() bool{
    return x.s.HasField(0)
}

func (x VolumeMount) ReadOnly() bool {
    return segment.GetBool(x.s, 1)
}

func (x VolumeMount) SetReadOnly(value bool) VolumeMount {
    segment.SetBool(x.s, 1, value)
    return x
}
func (x VolumeMount) IsSetReadOnly() bool{
    return x.s.HasField(1)
}

func (x VolumeMount) RecursiveReadOnly() RecursiveReadOnlyMode {
    return RecursiveReadOnlyMode(segment.GetUint8(x.s, 2))
}

func (x VolumeMount) SetRecursiveReadOnly(value RecursiveReadOnlyMode) VolumeMount {
    segment.SetUint8(x.s, 2, uint8(value))
    return x
}
func (x VolumeMount) IsSetRecursiveReadOnly() bool{
    return x.s.HasField(2)
}

func (x VolumeMount) MountPath() string {
    return segment.GetString(x.s, 3)
}

func (x VolumeMount) SetMountPath(value string) VolumeMount {
    segment.SetString(x.s, 3, value)
    return x
}
func (x VolumeMount) IsSetMountPath() bool{
    return x.s.HasField(3)
}

func (x VolumeMount) SubPath() string {
    return segment.GetString(x.s, 4)
}

func (x VolumeMount) SetSubPath(value string) VolumeMount {
    segment.SetString(x.s, 4, value)
    return x
}
func (x VolumeMount) IsSetSubPath() bool{
    return x.s.HasField(4)
}

func (x VolumeMount) MountPropagation() MountPropagationMode {
    return MountPropagationMode(segment.GetUint8(x.s, 5))
}

func (x VolumeMount) SetMountPropagation(value MountPropagationMode) VolumeMount {
    segment.SetUint8(x.s, 5, uint8(value))
    return x
}
func (x VolumeMount) IsSetMountPropagation() bool{
    return x.s.HasField(5)
}

func (x VolumeMount) SubPathExpr() string {
    return segment.GetString(x.s, 6)
}

func (x VolumeMount) SetSubPathExpr(value string) VolumeMount {
    segment.SetString(x.s, 6, value)
    return x
}
func (x VolumeMount) IsSetSubPathExpr() bool{
    return x.s.HasField(6)
}



// ClawStruct returns a reflection type representing the Struct.
func (x VolumeMount) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x VolumeMount) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x VolumeMount) XXXTypeHash() [16]byte {
    return XXXTypeHashVolumeMount
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x VolumeMount) SetRecording(enabled bool) VolumeMount {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x VolumeMount) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x VolumeMount) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x VolumeMount) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// VolumeMountRaw is a plain Go struct representation of VolumeMount.
// Zero values are not set (sparse encoding).
type VolumeMountRaw struct {
    Name string
    ReadOnly bool
    RecursiveReadOnly RecursiveReadOnlyMode
    MountPath string
    SubPath string
    MountPropagation MountPropagationMode
    SubPathExpr string
}

// NewVolumeMountFromRaw creates a new VolumeMount from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewVolumeMountFromRaw(ctx context.Context, raw VolumeMountRaw) VolumeMount {
    x := NewVolumeMount(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.ReadOnly {
        x.SetReadOnly(raw.ReadOnly)
    }
    if raw.RecursiveReadOnly != 0 {
        x.SetRecursiveReadOnly(raw.RecursiveReadOnly)
    }
    if raw.MountPath != "" {
        x.SetMountPath(raw.MountPath)
    }
    if raw.SubPath != "" {
        x.SetSubPath(raw.SubPath)
    }
    if raw.MountPropagation != 0 {
        x.SetMountPropagation(raw.MountPropagation)
    }
    if raw.SubPathExpr != "" {
        x.SetSubPathExpr(raw.SubPathExpr)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x VolumeMount) ToRaw(ctx context.Context) VolumeMountRaw {
    raw := VolumeMountRaw{}
    raw.Name = x.Name()
    raw.ReadOnly = x.ReadOnly()
    raw.RecursiveReadOnly = x.RecursiveReadOnly()
    raw.MountPath = x.MountPath()
    raw.SubPath = x.SubPath()
    raw.MountPropagation = x.MountPropagation()
    raw.SubPathExpr = x.SubPathExpr()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x VolumeMount) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(97)
}

// VolumeMountStatus shows status of a mount.
type VolumeMountStatus struct {
   s *segment.Struct
}

// NewVolumeMountStatus creates a new pooled instance of VolumeMountStatus.
// Call Release() when done to return it to the pool for reuse.
func NewVolumeMountStatus(ctx context.Context) VolumeMountStatus {
    s := segment.New(ctx, XXXMappingVolumeMountStatus)
    s.SetIsSetEnabled(true)
    return VolumeMountStatus{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x VolumeMountStatus) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewVolumeMountStatusFrom creates a new VolumeMountStatus from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewVolumeMountStatusFrom(s *segment.Struct) VolumeMountStatus {
    return VolumeMountStatus{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x VolumeMountStatus) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x VolumeMountStatus) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x VolumeMountStatus) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x VolumeMountStatus) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x VolumeMountStatus) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x VolumeMountStatus) Name() string {
    return segment.GetString(x.s, 0)
}

func (x VolumeMountStatus) SetName(value string) VolumeMountStatus {
    segment.SetString(x.s, 0, value)
    return x
}
func (x VolumeMountStatus) IsSetName() bool{
    return x.s.HasField(0)
}

func (x VolumeMountStatus) MountPath() string {
    return segment.GetString(x.s, 1)
}

func (x VolumeMountStatus) SetMountPath(value string) VolumeMountStatus {
    segment.SetString(x.s, 1, value)
    return x
}
func (x VolumeMountStatus) IsSetMountPath() bool{
    return x.s.HasField(1)
}

func (x VolumeMountStatus) ReadOnly() bool {
    return segment.GetBool(x.s, 2)
}

func (x VolumeMountStatus) SetReadOnly(value bool) VolumeMountStatus {
    segment.SetBool(x.s, 2, value)
    return x
}
func (x VolumeMountStatus) IsSetReadOnly() bool{
    return x.s.HasField(2)
}

func (x VolumeMountStatus) RecursiveReadOnly() RecursiveReadOnlyMode {
    return RecursiveReadOnlyMode(segment.GetUint8(x.s, 3))
}

func (x VolumeMountStatus) SetRecursiveReadOnly(value RecursiveReadOnlyMode) VolumeMountStatus {
    segment.SetUint8(x.s, 3, uint8(value))
    return x
}
func (x VolumeMountStatus) IsSetRecursiveReadOnly() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x VolumeMountStatus) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x VolumeMountStatus) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x VolumeMountStatus) XXXTypeHash() [16]byte {
    return XXXTypeHashVolumeMountStatus
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x VolumeMountStatus) SetRecording(enabled bool) VolumeMountStatus {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x VolumeMountStatus) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x VolumeMountStatus) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x VolumeMountStatus) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// VolumeMountStatusRaw is a plain Go struct representation of VolumeMountStatus.
// Zero values are not set (sparse encoding).
type VolumeMountStatusRaw struct {
    Name string
    MountPath string
    ReadOnly bool
    RecursiveReadOnly RecursiveReadOnlyMode
}

// NewVolumeMountStatusFromRaw creates a new VolumeMountStatus from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewVolumeMountStatusFromRaw(ctx context.Context, raw VolumeMountStatusRaw) VolumeMountStatus {
    x := NewVolumeMountStatus(ctx)
    if raw.Name != "" {
        x.SetName(raw.Name)
    }
    if raw.MountPath != "" {
        x.SetMountPath(raw.MountPath)
    }
    if raw.ReadOnly {
        x.SetReadOnly(raw.ReadOnly)
    }
    if raw.RecursiveReadOnly != 0 {
        x.SetRecursiveReadOnly(raw.RecursiveReadOnly)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x VolumeMountStatus) ToRaw(ctx context.Context) VolumeMountStatusRaw {
    raw := VolumeMountStatusRaw{}
    raw.Name = x.Name()
    raw.MountPath = x.MountPath()
    raw.ReadOnly = x.ReadOnly()
    raw.RecursiveReadOnly = x.RecursiveReadOnly()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x VolumeMountStatus) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(98)
}

// VolumeProjection contains the projected volume sources.
type VolumeProjection struct {
   s *segment.Struct
}

// NewVolumeProjection creates a new pooled instance of VolumeProjection.
// Call Release() when done to return it to the pool for reuse.
func NewVolumeProjection(ctx context.Context) VolumeProjection {
    s := segment.New(ctx, XXXMappingVolumeProjection)
    s.SetIsSetEnabled(true)
    return VolumeProjection{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x VolumeProjection) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewVolumeProjectionFrom creates a new VolumeProjection from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewVolumeProjectionFrom(s *segment.Struct) VolumeProjection {
    return VolumeProjection{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x VolumeProjection) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x VolumeProjection) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x VolumeProjection) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x VolumeProjection) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x VolumeProjection) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x VolumeProjection) Secret() SecretProjection {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingSecretProjection)
    return SecretProjection{s: s}
}

func (x VolumeProjection) SetSecret(value SecretProjection) VolumeProjection {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x VolumeProjection) IsSetSecret() bool{
    return x.s.HasField(0)
}

func (x VolumeProjection) DownwardApi() DownwardAPIProjection {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingDownwardAPIProjection)
    return DownwardAPIProjection{s: s}
}

func (x VolumeProjection) SetDownwardApi(value DownwardAPIProjection) VolumeProjection {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x VolumeProjection) IsSetDownwardApi() bool{
    return x.s.HasField(1)
}

func (x VolumeProjection) ConfigMap() ConfigMapProjection {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingConfigMapProjection)
    return ConfigMapProjection{s: s}
}

func (x VolumeProjection) SetConfigMap(value ConfigMapProjection) VolumeProjection {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x VolumeProjection) IsSetConfigMap() bool{
    return x.s.HasField(2)
}

func (x VolumeProjection) ServiceAccountToken() ServiceAccountTokenProjection {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingServiceAccountTokenProjection)
    return ServiceAccountTokenProjection{s: s}
}

func (x VolumeProjection) SetServiceAccountToken(value ServiceAccountTokenProjection) VolumeProjection {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x VolumeProjection) IsSetServiceAccountToken() bool{
    return x.s.HasField(3)
}

func (x VolumeProjection) ClusterTrustBundle() ClusterTrustBundleProjection {
    s := segment.GetNestedStruct(x.s, 4, XXXMappingClusterTrustBundleProjection)
    return ClusterTrustBundleProjection{s: s}
}

func (x VolumeProjection) SetClusterTrustBundle(value ClusterTrustBundleProjection) VolumeProjection {
    segment.SetNestedStruct(x.s, 4, value.XXXGetStruct())
    return x
}
func (x VolumeProjection) IsSetClusterTrustBundle() bool{
    return x.s.HasField(4)
}



// ClawStruct returns a reflection type representing the Struct.
func (x VolumeProjection) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x VolumeProjection) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x VolumeProjection) XXXTypeHash() [16]byte {
    return XXXTypeHashVolumeProjection
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x VolumeProjection) SetRecording(enabled bool) VolumeProjection {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x VolumeProjection) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x VolumeProjection) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x VolumeProjection) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// VolumeProjectionRaw is a plain Go struct representation of VolumeProjection.
// Zero values are not set (sparse encoding).
type VolumeProjectionRaw struct {
    Secret *SecretProjectionRaw
    DownwardApi *DownwardAPIProjectionRaw
    ConfigMap *ConfigMapProjectionRaw
    ServiceAccountToken *ServiceAccountTokenProjectionRaw
    ClusterTrustBundle *ClusterTrustBundleProjectionRaw
}

// NewVolumeProjectionFromRaw creates a new VolumeProjection from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewVolumeProjectionFromRaw(ctx context.Context, raw VolumeProjectionRaw) VolumeProjection {
    x := NewVolumeProjection(ctx)
    if raw.Secret != nil {
        x.SetSecret(NewSecretProjectionFromRaw(ctx, *raw.Secret))
    }
    if raw.DownwardApi != nil {
        x.SetDownwardApi(NewDownwardAPIProjectionFromRaw(ctx, *raw.DownwardApi))
    }
    if raw.ConfigMap != nil {
        x.SetConfigMap(NewConfigMapProjectionFromRaw(ctx, *raw.ConfigMap))
    }
    if raw.ServiceAccountToken != nil {
        x.SetServiceAccountToken(NewServiceAccountTokenProjectionFromRaw(ctx, *raw.ServiceAccountToken))
    }
    if raw.ClusterTrustBundle != nil {
        x.SetClusterTrustBundle(NewClusterTrustBundleProjectionFromRaw(ctx, *raw.ClusterTrustBundle))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x VolumeProjection) ToRaw(ctx context.Context) VolumeProjectionRaw {
    raw := VolumeProjectionRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.Secret().ToRaw(ctx)
        raw.Secret = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.DownwardApi().ToRaw(ctx)
        raw.DownwardApi = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.ConfigMap().ToRaw(ctx)
        raw.ConfigMap = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.ServiceAccountToken().ToRaw(ctx)
        raw.ServiceAccountToken = &nestedRaw
    }
    if x.s.HasField(4) {
        nestedRaw := x.ClusterTrustBundle().ToRaw(ctx)
        raw.ClusterTrustBundle = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x VolumeProjection) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(99)
}

// VolumeSource represents the source location of a volume to mount.
type VolumeSource struct {
   s *segment.Struct
}

// NewVolumeSource creates a new pooled instance of VolumeSource.
// Call Release() when done to return it to the pool for reuse.
func NewVolumeSource(ctx context.Context) VolumeSource {
    s := segment.New(ctx, XXXMappingVolumeSource)
    s.SetIsSetEnabled(true)
    return VolumeSource{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x VolumeSource) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewVolumeSourceFrom creates a new VolumeSource from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewVolumeSourceFrom(s *segment.Struct) VolumeSource {
    return VolumeSource{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x VolumeSource) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x VolumeSource) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x VolumeSource) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x VolumeSource) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x VolumeSource) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x VolumeSource) HostPath() HostPathVolumeSource {
    s := segment.GetNestedStruct(x.s, 0, XXXMappingHostPathVolumeSource)
    return HostPathVolumeSource{s: s}
}

func (x VolumeSource) SetHostPath(value HostPathVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 0, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetHostPath() bool{
    return x.s.HasField(0)
}

func (x VolumeSource) EmptyDir() EmptyDirVolumeSource {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingEmptyDirVolumeSource)
    return EmptyDirVolumeSource{s: s}
}

func (x VolumeSource) SetEmptyDir(value EmptyDirVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetEmptyDir() bool{
    return x.s.HasField(1)
}

func (x VolumeSource) GcePersistentDisk() GCEPersistentDiskVolumeSource {
    s := segment.GetNestedStruct(x.s, 2, XXXMappingGCEPersistentDiskVolumeSource)
    return GCEPersistentDiskVolumeSource{s: s}
}

func (x VolumeSource) SetGcePersistentDisk(value GCEPersistentDiskVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 2, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetGcePersistentDisk() bool{
    return x.s.HasField(2)
}

func (x VolumeSource) AwsElasticBlockStore() AWSElasticBlockStoreVolumeSource {
    s := segment.GetNestedStruct(x.s, 3, XXXMappingAWSElasticBlockStoreVolumeSource)
    return AWSElasticBlockStoreVolumeSource{s: s}
}

func (x VolumeSource) SetAwsElasticBlockStore(value AWSElasticBlockStoreVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 3, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetAwsElasticBlockStore() bool{
    return x.s.HasField(3)
}

func (x VolumeSource) Secret() SecretVolumeSource {
    s := segment.GetNestedStruct(x.s, 4, XXXMappingSecretVolumeSource)
    return SecretVolumeSource{s: s}
}

func (x VolumeSource) SetSecret(value SecretVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 4, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetSecret() bool{
    return x.s.HasField(4)
}

func (x VolumeSource) Nfs() NFSVolumeSource {
    s := segment.GetNestedStruct(x.s, 5, XXXMappingNFSVolumeSource)
    return NFSVolumeSource{s: s}
}

func (x VolumeSource) SetNfs(value NFSVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 5, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetNfs() bool{
    return x.s.HasField(5)
}

func (x VolumeSource) PersistentVolumeClaim() PersistentVolumeClaimVolumeSource {
    s := segment.GetNestedStruct(x.s, 6, XXXMappingPersistentVolumeClaimVolumeSource)
    return PersistentVolumeClaimVolumeSource{s: s}
}

func (x VolumeSource) SetPersistentVolumeClaim(value PersistentVolumeClaimVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 6, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetPersistentVolumeClaim() bool{
    return x.s.HasField(6)
}

func (x VolumeSource) DownwardApi() DownwardAPIVolumeSource {
    s := segment.GetNestedStruct(x.s, 7, XXXMappingDownwardAPIVolumeSource)
    return DownwardAPIVolumeSource{s: s}
}

func (x VolumeSource) SetDownwardApi(value DownwardAPIVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 7, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetDownwardApi() bool{
    return x.s.HasField(7)
}

func (x VolumeSource) ConfigMap() ConfigMapVolumeSource {
    s := segment.GetNestedStruct(x.s, 8, XXXMappingConfigMapVolumeSource)
    return ConfigMapVolumeSource{s: s}
}

func (x VolumeSource) SetConfigMap(value ConfigMapVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 8, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetConfigMap() bool{
    return x.s.HasField(8)
}

func (x VolumeSource) Projected() ProjectedVolumeSource {
    s := segment.GetNestedStruct(x.s, 9, XXXMappingProjectedVolumeSource)
    return ProjectedVolumeSource{s: s}
}

func (x VolumeSource) SetProjected(value ProjectedVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 9, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetProjected() bool{
    return x.s.HasField(9)
}

func (x VolumeSource) Csi() CSIVolumeSource {
    s := segment.GetNestedStruct(x.s, 10, XXXMappingCSIVolumeSource)
    return CSIVolumeSource{s: s}
}

func (x VolumeSource) SetCsi(value CSIVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 10, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetCsi() bool{
    return x.s.HasField(10)
}

func (x VolumeSource) Ephemeral() EphemeralVolumeSource {
    s := segment.GetNestedStruct(x.s, 11, XXXMappingEphemeralVolumeSource)
    return EphemeralVolumeSource{s: s}
}

func (x VolumeSource) SetEphemeral(value EphemeralVolumeSource) VolumeSource {
    segment.SetNestedStruct(x.s, 11, value.XXXGetStruct())
    return x
}
func (x VolumeSource) IsSetEphemeral() bool{
    return x.s.HasField(11)
}



// ClawStruct returns a reflection type representing the Struct.
func (x VolumeSource) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x VolumeSource) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x VolumeSource) XXXTypeHash() [16]byte {
    return XXXTypeHashVolumeSource
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x VolumeSource) SetRecording(enabled bool) VolumeSource {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x VolumeSource) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x VolumeSource) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x VolumeSource) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// VolumeSourceRaw is a plain Go struct representation of VolumeSource.
// Zero values are not set (sparse encoding).
type VolumeSourceRaw struct {
    HostPath *HostPathVolumeSourceRaw
    EmptyDir *EmptyDirVolumeSourceRaw
    GcePersistentDisk *GCEPersistentDiskVolumeSourceRaw
    AwsElasticBlockStore *AWSElasticBlockStoreVolumeSourceRaw
    Secret *SecretVolumeSourceRaw
    Nfs *NFSVolumeSourceRaw
    PersistentVolumeClaim *PersistentVolumeClaimVolumeSourceRaw
    DownwardApi *DownwardAPIVolumeSourceRaw
    ConfigMap *ConfigMapVolumeSourceRaw
    Projected *ProjectedVolumeSourceRaw
    Csi *CSIVolumeSourceRaw
    Ephemeral *EphemeralVolumeSourceRaw
}

// NewVolumeSourceFromRaw creates a new VolumeSource from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewVolumeSourceFromRaw(ctx context.Context, raw VolumeSourceRaw) VolumeSource {
    x := NewVolumeSource(ctx)
    if raw.HostPath != nil {
        x.SetHostPath(NewHostPathVolumeSourceFromRaw(ctx, *raw.HostPath))
    }
    if raw.EmptyDir != nil {
        x.SetEmptyDir(NewEmptyDirVolumeSourceFromRaw(ctx, *raw.EmptyDir))
    }
    if raw.GcePersistentDisk != nil {
        x.SetGcePersistentDisk(NewGCEPersistentDiskVolumeSourceFromRaw(ctx, *raw.GcePersistentDisk))
    }
    if raw.AwsElasticBlockStore != nil {
        x.SetAwsElasticBlockStore(NewAWSElasticBlockStoreVolumeSourceFromRaw(ctx, *raw.AwsElasticBlockStore))
    }
    if raw.Secret != nil {
        x.SetSecret(NewSecretVolumeSourceFromRaw(ctx, *raw.Secret))
    }
    if raw.Nfs != nil {
        x.SetNfs(NewNFSVolumeSourceFromRaw(ctx, *raw.Nfs))
    }
    if raw.PersistentVolumeClaim != nil {
        x.SetPersistentVolumeClaim(NewPersistentVolumeClaimVolumeSourceFromRaw(ctx, *raw.PersistentVolumeClaim))
    }
    if raw.DownwardApi != nil {
        x.SetDownwardApi(NewDownwardAPIVolumeSourceFromRaw(ctx, *raw.DownwardApi))
    }
    if raw.ConfigMap != nil {
        x.SetConfigMap(NewConfigMapVolumeSourceFromRaw(ctx, *raw.ConfigMap))
    }
    if raw.Projected != nil {
        x.SetProjected(NewProjectedVolumeSourceFromRaw(ctx, *raw.Projected))
    }
    if raw.Csi != nil {
        x.SetCsi(NewCSIVolumeSourceFromRaw(ctx, *raw.Csi))
    }
    if raw.Ephemeral != nil {
        x.SetEphemeral(NewEphemeralVolumeSourceFromRaw(ctx, *raw.Ephemeral))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x VolumeSource) ToRaw(ctx context.Context) VolumeSourceRaw {
    raw := VolumeSourceRaw{}
    if x.s.HasField(0) {
        nestedRaw := x.HostPath().ToRaw(ctx)
        raw.HostPath = &nestedRaw
    }
    if x.s.HasField(1) {
        nestedRaw := x.EmptyDir().ToRaw(ctx)
        raw.EmptyDir = &nestedRaw
    }
    if x.s.HasField(2) {
        nestedRaw := x.GcePersistentDisk().ToRaw(ctx)
        raw.GcePersistentDisk = &nestedRaw
    }
    if x.s.HasField(3) {
        nestedRaw := x.AwsElasticBlockStore().ToRaw(ctx)
        raw.AwsElasticBlockStore = &nestedRaw
    }
    if x.s.HasField(4) {
        nestedRaw := x.Secret().ToRaw(ctx)
        raw.Secret = &nestedRaw
    }
    if x.s.HasField(5) {
        nestedRaw := x.Nfs().ToRaw(ctx)
        raw.Nfs = &nestedRaw
    }
    if x.s.HasField(6) {
        nestedRaw := x.PersistentVolumeClaim().ToRaw(ctx)
        raw.PersistentVolumeClaim = &nestedRaw
    }
    if x.s.HasField(7) {
        nestedRaw := x.DownwardApi().ToRaw(ctx)
        raw.DownwardApi = &nestedRaw
    }
    if x.s.HasField(8) {
        nestedRaw := x.ConfigMap().ToRaw(ctx)
        raw.ConfigMap = &nestedRaw
    }
    if x.s.HasField(9) {
        nestedRaw := x.Projected().ToRaw(ctx)
        raw.Projected = &nestedRaw
    }
    if x.s.HasField(10) {
        nestedRaw := x.Csi().ToRaw(ctx)
        raw.Csi = &nestedRaw
    }
    if x.s.HasField(11) {
        nestedRaw := x.Ephemeral().ToRaw(ctx)
        raw.Ephemeral = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x VolumeSource) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(100)
}

// WeightedPodAffinityTerm represents a pod affinity term with a weight.
type WeightedPodAffinityTerm struct {
   s *segment.Struct
}

// NewWeightedPodAffinityTerm creates a new pooled instance of WeightedPodAffinityTerm.
// Call Release() when done to return it to the pool for reuse.
func NewWeightedPodAffinityTerm(ctx context.Context) WeightedPodAffinityTerm {
    s := segment.New(ctx, XXXMappingWeightedPodAffinityTerm)
    s.SetIsSetEnabled(true)
    return WeightedPodAffinityTerm{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x WeightedPodAffinityTerm) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewWeightedPodAffinityTermFrom creates a new WeightedPodAffinityTerm from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewWeightedPodAffinityTermFrom(s *segment.Struct) WeightedPodAffinityTerm {
    return WeightedPodAffinityTerm{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x WeightedPodAffinityTerm) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x WeightedPodAffinityTerm) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x WeightedPodAffinityTerm) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x WeightedPodAffinityTerm) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x WeightedPodAffinityTerm) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x WeightedPodAffinityTerm) Weight() int32 {
    return segment.GetInt32(x.s, 0)
}

func (x WeightedPodAffinityTerm) SetWeight(value int32) WeightedPodAffinityTerm {
    segment.SetInt32(x.s, 0, value)
    return x
}
func (x WeightedPodAffinityTerm) IsSetWeight() bool{
    return x.s.HasField(0)
}

func (x WeightedPodAffinityTerm) PodAffinityTerm() PodAffinityTerm {
    s := segment.GetNestedStruct(x.s, 1, XXXMappingPodAffinityTerm)
    return PodAffinityTerm{s: s}
}

func (x WeightedPodAffinityTerm) SetPodAffinityTerm(value PodAffinityTerm) WeightedPodAffinityTerm {
    segment.SetNestedStruct(x.s, 1, value.XXXGetStruct())
    return x
}
func (x WeightedPodAffinityTerm) IsSetPodAffinityTerm() bool{
    return x.s.HasField(1)
}



// ClawStruct returns a reflection type representing the Struct.
func (x WeightedPodAffinityTerm) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x WeightedPodAffinityTerm) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x WeightedPodAffinityTerm) XXXTypeHash() [16]byte {
    return XXXTypeHashWeightedPodAffinityTerm
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x WeightedPodAffinityTerm) SetRecording(enabled bool) WeightedPodAffinityTerm {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x WeightedPodAffinityTerm) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x WeightedPodAffinityTerm) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x WeightedPodAffinityTerm) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// WeightedPodAffinityTermRaw is a plain Go struct representation of WeightedPodAffinityTerm.
// Zero values are not set (sparse encoding).
type WeightedPodAffinityTermRaw struct {
    Weight int32
    PodAffinityTerm *PodAffinityTermRaw
}

// NewWeightedPodAffinityTermFromRaw creates a new WeightedPodAffinityTerm from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewWeightedPodAffinityTermFromRaw(ctx context.Context, raw WeightedPodAffinityTermRaw) WeightedPodAffinityTerm {
    x := NewWeightedPodAffinityTerm(ctx)
    if raw.Weight != 0 {
        x.SetWeight(raw.Weight)
    }
    if raw.PodAffinityTerm != nil {
        x.SetPodAffinityTerm(NewPodAffinityTermFromRaw(ctx, *raw.PodAffinityTerm))
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x WeightedPodAffinityTerm) ToRaw(ctx context.Context) WeightedPodAffinityTermRaw {
    raw := WeightedPodAffinityTermRaw{}
    raw.Weight = x.Weight()
    if x.s.HasField(1) {
        nestedRaw := x.PodAffinityTerm().ToRaw(ctx)
        raw.PodAffinityTerm = &nestedRaw
    }
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x WeightedPodAffinityTerm) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(101)
}

// WindowsSecurityContextOptions contain Windows-specific options.
type WindowsSecurityContextOptions struct {
   s *segment.Struct
}

// NewWindowsSecurityContextOptions creates a new pooled instance of WindowsSecurityContextOptions.
// Call Release() when done to return it to the pool for reuse.
func NewWindowsSecurityContextOptions(ctx context.Context) WindowsSecurityContextOptions {
    s := segment.New(ctx, XXXMappingWindowsSecurityContextOptions)
    s.SetIsSetEnabled(true)
    return WindowsSecurityContextOptions{
        s: s,
    }
}

// Release returns the struct to the pool for reuse.
// After calling Release, the struct should not be used.
func (x WindowsSecurityContextOptions) Release(ctx context.Context) {
    x.s.Release(ctx)
}

// XXXNewWindowsSecurityContextOptionsFrom creates a new WindowsSecurityContextOptions from our internal Struct representation.
// As with all things marked XXX*, this should not be used and has not compatibility
// guarantees.
//
// Deprecated: This is not actually deprecated, but it should not be used directly nor
// show up in any documentation.
func XXXNewWindowsSecurityContextOptionsFrom(s *segment.Struct) WindowsSecurityContextOptions {
    return WindowsSecurityContextOptions{s: s}
}

// Marshal marshal's the Struct to []byte. The returned slice is shared by Struct,
// so Struct must not be modified after this call. If Struct needs to be modified,
// use MarshalSafe() instead.
func (x WindowsSecurityContextOptions) Marshal() ([]byte, error) {
    return x.s.Marshal()
}

// MarshalSafe marshal's the Struct to []byte. The returned slice is a copy
// and safe to modify.
func (x WindowsSecurityContextOptions) MarshalSafe() ([]byte, error) {
    return x.s.MarshalSafe()
}

// MarshalWriter marshals to an io.Writer.
func (x WindowsSecurityContextOptions) MarshalWriter(w io.Writer) (n int, err error) {
    return x.s.MarshalWriter(w)
}

// Unmarshal unmarshals b into the Struct.
func (x WindowsSecurityContextOptions) Unmarshal(b []byte) error {
    return x.s.Unmarshal(b)
}

// UnmarshalReader unmarshals a Struct from an io.Reader.
func (x WindowsSecurityContextOptions) UnmarshalReader (r io.Reader) (int, error) {
    return x.s.UnmarshalReader(r)
}

func (x WindowsSecurityContextOptions) GmsaCredentialSpecName() string {
    return segment.GetString(x.s, 0)
}

func (x WindowsSecurityContextOptions) SetGmsaCredentialSpecName(value string) WindowsSecurityContextOptions {
    segment.SetString(x.s, 0, value)
    return x
}
func (x WindowsSecurityContextOptions) IsSetGmsaCredentialSpecName() bool{
    return x.s.HasField(0)
}

func (x WindowsSecurityContextOptions) GmsaCredentialSpec() string {
    return segment.GetString(x.s, 1)
}

func (x WindowsSecurityContextOptions) SetGmsaCredentialSpec(value string) WindowsSecurityContextOptions {
    segment.SetString(x.s, 1, value)
    return x
}
func (x WindowsSecurityContextOptions) IsSetGmsaCredentialSpec() bool{
    return x.s.HasField(1)
}

func (x WindowsSecurityContextOptions) RunAsUserName() string {
    return segment.GetString(x.s, 2)
}

func (x WindowsSecurityContextOptions) SetRunAsUserName(value string) WindowsSecurityContextOptions {
    segment.SetString(x.s, 2, value)
    return x
}
func (x WindowsSecurityContextOptions) IsSetRunAsUserName() bool{
    return x.s.HasField(2)
}

func (x WindowsSecurityContextOptions) HostProcess() bool {
    return segment.GetBool(x.s, 3)
}

func (x WindowsSecurityContextOptions) SetHostProcess(value bool) WindowsSecurityContextOptions {
    segment.SetBool(x.s, 3, value)
    return x
}
func (x WindowsSecurityContextOptions) IsSetHostProcess() bool{
    return x.s.HasField(3)
}



// ClawStruct returns a reflection type representing the Struct.
func (x WindowsSecurityContextOptions) ClawStruct() reflect.Struct{
    return reflect.XXXNewStruct(x.s, x.XXXDescr())
}

// XXXGetStruct returns the internal Struct representation. Like all XXX* types/methods,
// this should not be used and has no compatibility guarantees.
//
// Deprecated: Not deprectated, but should not be used and should not show up in documentation.
func (x WindowsSecurityContextOptions) XXXGetStruct() *segment.Struct {
    return x.s
}

// XXXTypeHash returns the SHAKE128 hash (128 bits) of this type's identity.
// Used for Any type serialization to identify the concrete type.
//
// Deprecated: Not deprecated, but should not be used directly and should not show up in documentation.
func (x WindowsSecurityContextOptions) XXXTypeHash() [16]byte {
    return XXXTypeHashWindowsSecurityContextOptions
}

// SetRecording enables or disables mutation recording for patch generation.
// When enabled, all Set* operations and list mutations are recorded.
func (x WindowsSecurityContextOptions) SetRecording(enabled bool) WindowsSecurityContextOptions {
    x.s.SetRecording(enabled)
    return x
}

// Recording returns whether mutation recording is enabled.
func (x WindowsSecurityContextOptions) Recording() bool {
    return x.s.Recording()
}

// DrainRecordedOps returns all recorded operations since recording was enabled
// (or since the last DrainRecordedOps call) and clears the internal list.
// Use patch.NewPatchFromOps() to convert these to a Patch for application.
func (x WindowsSecurityContextOptions) DrainRecordedOps() []segment.RecordedOp {
    return x.s.DrainRecordedOps()
}

// RecordedOpsLen returns the number of recorded operations.
func (x WindowsSecurityContextOptions) RecordedOpsLen() int {
    return x.s.RecordedOpsLen()
}

// WindowsSecurityContextOptionsRaw is a plain Go struct representation of WindowsSecurityContextOptions.
// Zero values are not set (sparse encoding).
type WindowsSecurityContextOptionsRaw struct {
    GmsaCredentialSpecName string
    GmsaCredentialSpec string
    RunAsUserName string
    HostProcess bool
}

// NewWindowsSecurityContextOptionsFromRaw creates a new WindowsSecurityContextOptions from a Raw struct representation.
// Only non-zero values are set (sparse encoding).
func NewWindowsSecurityContextOptionsFromRaw(ctx context.Context, raw WindowsSecurityContextOptionsRaw) WindowsSecurityContextOptions {
    x := NewWindowsSecurityContextOptions(ctx)
    if raw.GmsaCredentialSpecName != "" {
        x.SetGmsaCredentialSpecName(raw.GmsaCredentialSpecName)
    }
    if raw.GmsaCredentialSpec != "" {
        x.SetGmsaCredentialSpec(raw.GmsaCredentialSpec)
    }
    if raw.RunAsUserName != "" {
        x.SetRunAsUserName(raw.RunAsUserName)
    }
    if raw.HostProcess {
        x.SetHostProcess(raw.HostProcess)
    }
    return x
}

// ToRaw converts the struct to a plain Go struct representation.
func (x WindowsSecurityContextOptions) ToRaw(ctx context.Context) WindowsSecurityContextOptionsRaw {
    raw := WindowsSecurityContextOptionsRaw{}
    raw.GmsaCredentialSpecName = x.GmsaCredentialSpecName()
    raw.GmsaCredentialSpec = x.GmsaCredentialSpec()
    raw.RunAsUserName = x.RunAsUserName()
    raw.HostProcess = x.HostProcess()
    return raw
}
 

// XXXDescr returns the Struct's descriptor. This should only be used
// by the reflect package and is has no compatibility promises like all XXX fields.
//
// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
func (x WindowsSecurityContextOptions) XXXDescr() reflect.StructDescr {
    return XXXPackageDescr.Structs().Get(102)
} 

// Everything below this line is internal details.

// Type hash constants for Any type support.
// These are SHAKE128 hashes (128 bits) of the full type path + name.
// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashAWSElasticBlockStoreVolumeSource = [16]byte{0x1c, 0x72, 0xa7, 0x36, 0xda, 0x6f, 0xec, 0x7d, 0xdb, 0x33, 0xfe, 0xe1, 0xa9, 0x5f, 0x1a, 0x4d}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashAffinity = [16]byte{0x54, 0x2d, 0x0b, 0xf0, 0x0e, 0x70, 0xca, 0x7d, 0xb2, 0x23, 0x4b, 0x01, 0xff, 0x60, 0x91, 0xc8}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashAppArmorProfile = [16]byte{0x59, 0x3b, 0x5e, 0xe3, 0x97, 0xaf, 0xac, 0xc7, 0xb1, 0xb5, 0x2f, 0x69, 0xd6, 0xbd, 0xeb, 0x49}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashCSIVolumeSource = [16]byte{0x3c, 0xec, 0xf5, 0xfc, 0x7a, 0xbf, 0x27, 0x1c, 0x96, 0xee, 0x27, 0xcf, 0x86, 0x19, 0x1f, 0xa0}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashCapabilities = [16]byte{0x9a, 0x76, 0x0c, 0x09, 0x6e, 0xb1, 0xf7, 0x6a, 0xe2, 0x3f, 0x18, 0xbc, 0x13, 0x8f, 0x8d, 0x4c}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashClusterTrustBundleProjection = [16]byte{0xc0, 0xa0, 0xba, 0xa3, 0x18, 0x3d, 0x18, 0xca, 0x6f, 0xb7, 0x09, 0x6d, 0x7e, 0x96, 0x58, 0x06}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashConfigMapEnvSource = [16]byte{0x20, 0x84, 0x6a, 0x2b, 0x72, 0xb5, 0xb7, 0x49, 0xc2, 0x86, 0x9b, 0xfd, 0xd7, 0x5f, 0x89, 0x26}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashConfigMapKeySelector = [16]byte{0x9a, 0xe6, 0x80, 0x5a, 0x1d, 0x86, 0x59, 0x36, 0x0a, 0xbf, 0x3e, 0xac, 0xc3, 0x2a, 0x19, 0xd2}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashConfigMapProjection = [16]byte{0x69, 0x5e, 0x85, 0xe2, 0xe4, 0x7d, 0x6e, 0x44, 0xeb, 0xbc, 0x29, 0xc4, 0x7f, 0xa2, 0x89, 0x7a}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashConfigMapVolumeSource = [16]byte{0x0e, 0xeb, 0xeb, 0x32, 0x61, 0x42, 0x8a, 0xd3, 0x68, 0xc5, 0x39, 0x8f, 0x84, 0x5d, 0x7c, 0xd8}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashContainer = [16]byte{0xd9, 0xe5, 0x5a, 0x99, 0x4f, 0x97, 0x4f, 0x9b, 0xc9, 0xfa, 0xfb, 0x70, 0x45, 0x80, 0x5c, 0x91}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashContainerPort = [16]byte{0xe1, 0x6b, 0x3d, 0x12, 0xf8, 0x1f, 0x39, 0x35, 0x7f, 0x03, 0x9a, 0xad, 0xd5, 0x37, 0x5d, 0x47}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashContainerResizePolicy = [16]byte{0x78, 0x96, 0xa6, 0x12, 0x9b, 0xc6, 0xbe, 0x37, 0xba, 0x9a, 0xfd, 0x18, 0xeb, 0x0d, 0xeb, 0xbb}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashContainerState = [16]byte{0xcd, 0xa0, 0x1e, 0x0e, 0x04, 0x66, 0xb0, 0x05, 0x35, 0xcc, 0xd6, 0xa1, 0xfb, 0xb6, 0x1b, 0x23}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashContainerStateRunning = [16]byte{0x57, 0x70, 0xcc, 0xe4, 0x10, 0x0a, 0xff, 0x6d, 0xcd, 0x91, 0x94, 0xb6, 0x3e, 0x95, 0x67, 0x35}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashContainerStateTerminated = [16]byte{0x67, 0x6d, 0x78, 0x17, 0x1b, 0x33, 0xad, 0xbb, 0x75, 0xac, 0xb1, 0xb2, 0x4b, 0x18, 0xd6, 0x00}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashContainerStateWaiting = [16]byte{0x79, 0xe2, 0xce, 0xd1, 0xb9, 0x1b, 0x84, 0x0b, 0x9a, 0x7c, 0x27, 0x85, 0x3b, 0x11, 0x89, 0xdd}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashContainerStatus = [16]byte{0xf2, 0x4b, 0xe2, 0x0b, 0x08, 0xe4, 0xbb, 0x5b, 0x18, 0x26, 0x5f, 0xcf, 0xbe, 0x0b, 0x48, 0xca}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashDownwardAPIProjection = [16]byte{0xe9, 0xcc, 0xa4, 0xe4, 0x16, 0x8f, 0x0e, 0xbc, 0xc6, 0x20, 0xd6, 0x34, 0xa9, 0x11, 0x7d, 0x5a}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashDownwardAPIVolumeFile = [16]byte{0x19, 0xbd, 0x9a, 0x8f, 0xf5, 0xd0, 0xa0, 0x64, 0x6a, 0x12, 0xf9, 0x29, 0x4c, 0xf8, 0x57, 0x17}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashDownwardAPIVolumeSource = [16]byte{0x36, 0xe2, 0xf1, 0x6c, 0x6a, 0xd4, 0xa9, 0x06, 0x3d, 0xf2, 0xd6, 0x26, 0x8c, 0xdb, 0x11, 0x1d}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashEmptyDirVolumeSource = [16]byte{0x8f, 0xce, 0xdb, 0x9a, 0x84, 0xaf, 0x6e, 0x87, 0xa7, 0xdc, 0x19, 0x81, 0x57, 0xd7, 0xda, 0x60}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashEnvFromSource = [16]byte{0x08, 0xfa, 0x76, 0x4b, 0x52, 0x00, 0xa3, 0x59, 0xf8, 0x03, 0xc1, 0xd2, 0xd1, 0xdb, 0x1e, 0xcb}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashEnvVar = [16]byte{0xcd, 0xe1, 0x3c, 0x9e, 0xb2, 0x80, 0xf3, 0x0f, 0x38, 0xbf, 0xcd, 0x35, 0x51, 0x34, 0x73, 0xce}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashEnvVarSource = [16]byte{0x4b, 0x61, 0xfe, 0xe3, 0x64, 0xb5, 0x6b, 0x2b, 0x21, 0xcc, 0x7b, 0x96, 0xe5, 0x5a, 0xcc, 0xd1}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashEphemeralContainer = [16]byte{0xd2, 0x72, 0x19, 0xe6, 0x1d, 0x64, 0xbe, 0x16, 0x91, 0x86, 0xf2, 0x28, 0x08, 0x52, 0xb8, 0x48}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashEphemeralVolumeSource = [16]byte{0x33, 0xb0, 0x78, 0x5f, 0x44, 0xdf, 0x3f, 0x88, 0x4a, 0xc9, 0x67, 0x56, 0x7f, 0x09, 0xdb, 0xe3}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashExecAction = [16]byte{0x91, 0x1c, 0x8c, 0xd0, 0x85, 0xb7, 0x9a, 0x7d, 0x38, 0xc6, 0xb3, 0xb4, 0x41, 0x60, 0xa9, 0x98}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashGCEPersistentDiskVolumeSource = [16]byte{0xd7, 0x0d, 0xb5, 0x8b, 0x87, 0x4d, 0x1f, 0x42, 0xff, 0x28, 0x84, 0x15, 0x88, 0x92, 0xbb, 0x1d}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashGRPCAction = [16]byte{0xcc, 0x7a, 0xbe, 0xe8, 0x00, 0x56, 0x51, 0x58, 0xca, 0x28, 0x7e, 0x65, 0x7b, 0x53, 0xbe, 0x81}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashHTTPGetAction = [16]byte{0x66, 0x4c, 0xe5, 0x89, 0xeb, 0x7d, 0x72, 0x66, 0x29, 0x1b, 0xd8, 0x2d, 0x01, 0xbe, 0x60, 0x65}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashHTTPHeader = [16]byte{0x67, 0x11, 0x2a, 0x4c, 0x26, 0x17, 0x42, 0xa1, 0xc3, 0x62, 0xe3, 0x1c, 0x48, 0x8c, 0x4f, 0xc1}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashHostAlias = [16]byte{0xe3, 0x8b, 0x33, 0x1d, 0xf6, 0xa9, 0xd2, 0x12, 0x85, 0x25, 0xcd, 0x9d, 0x71, 0x16, 0xf3, 0xa2}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashHostIP = [16]byte{0x38, 0x8b, 0x22, 0x02, 0x5c, 0x7e, 0x79, 0x26, 0xa3, 0x7f, 0x2c, 0x68, 0x63, 0x73, 0x28, 0x5b}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashHostPathVolumeSource = [16]byte{0x5d, 0xe2, 0x07, 0x71, 0x90, 0xfc, 0xee, 0x80, 0x25, 0x29, 0x9b, 0xf6, 0x2d, 0x39, 0x2c, 0xb7}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashIntOrString = [16]byte{0x80, 0x55, 0x9d, 0x19, 0xbc, 0x08, 0xfc, 0xc0, 0x3e, 0x97, 0x5f, 0x35, 0xd4, 0x03, 0x7e, 0x03}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashKeyToPath = [16]byte{0xcf, 0xc7, 0xf5, 0x60, 0x76, 0x75, 0x85, 0xa4, 0x4d, 0x4f, 0x92, 0x2b, 0x24, 0xc5, 0x0a, 0x95}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashKeyValue = [16]byte{0x81, 0x5e, 0xdd, 0xb3, 0x8d, 0x35, 0x8d, 0xb0, 0xc4, 0xa0, 0x40, 0xdb, 0x26, 0x03, 0xa6, 0xdb}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashLabelSelector = [16]byte{0xed, 0x7e, 0x6e, 0xbd, 0x91, 0x3d, 0x09, 0x6e, 0xdf, 0x51, 0xff, 0x21, 0x2f, 0x08, 0x7f, 0xb7}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashLabelSelectorRequirement = [16]byte{0x0a, 0x5a, 0xa1, 0xce, 0x5a, 0xfe, 0x53, 0x82, 0x7b, 0x94, 0x6d, 0xe9, 0x33, 0x14, 0xf4, 0x8e}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashLifecycle = [16]byte{0x15, 0x7a, 0xf2, 0x71, 0x37, 0x8a, 0xed, 0x19, 0x30, 0xa8, 0x11, 0x09, 0x92, 0x77, 0x7e, 0xbf}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashLifecycleHandler = [16]byte{0xca, 0x2b, 0x50, 0x25, 0x84, 0x28, 0xba, 0x2b, 0xe9, 0x2f, 0x8d, 0xd6, 0x4d, 0x57, 0x9a, 0x19}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashLocalObjectReference = [16]byte{0x9d, 0x64, 0x56, 0x8d, 0xa8, 0x27, 0x5f, 0x2e, 0x41, 0xff, 0x25, 0x14, 0xe0, 0xe0, 0x82, 0xf6}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashManagedFieldsEntry = [16]byte{0x9b, 0x29, 0x0c, 0x56, 0x8c, 0x90, 0x8d, 0xcb, 0x99, 0x0b, 0x3b, 0x33, 0x40, 0x97, 0xd7, 0x65}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashNFSVolumeSource = [16]byte{0x5a, 0x67, 0x03, 0x9c, 0x97, 0xff, 0x3b, 0x60, 0x1f, 0x02, 0x95, 0xe9, 0x09, 0x28, 0xb3, 0x1f}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashNodeAffinity = [16]byte{0x37, 0x90, 0x8c, 0x67, 0xf2, 0x18, 0x8a, 0x49, 0xde, 0x28, 0x06, 0x8b, 0x9b, 0x7c, 0x68, 0xbf}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashNodeSelector = [16]byte{0xe3, 0x65, 0xdd, 0x02, 0x37, 0xeb, 0x8e, 0xf1, 0xb2, 0xa2, 0xd5, 0xda, 0xec, 0x06, 0x3d, 0xcc}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashNodeSelectorRequirement = [16]byte{0x25, 0xd5, 0xaa, 0x13, 0xd3, 0x45, 0xd8, 0xf4, 0xc9, 0x67, 0xb1, 0x4b, 0xbc, 0x95, 0x49, 0xae}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashNodeSelectorTerm = [16]byte{0x6a, 0x6e, 0x6b, 0xef, 0x7d, 0xb7, 0x5f, 0xd4, 0x98, 0xa6, 0x2d, 0xac, 0x01, 0xeb, 0xf5, 0x87}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashObjectFieldSelector = [16]byte{0x40, 0xd7, 0xff, 0x08, 0x80, 0xb2, 0xe9, 0x99, 0x11, 0xd1, 0x4d, 0x4f, 0x60, 0x4c, 0xfa, 0x46}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashObjectMeta = [16]byte{0xa0, 0x31, 0x66, 0xf5, 0x8c, 0x01, 0x31, 0x58, 0x11, 0x27, 0x09, 0x2c, 0x98, 0xa5, 0x5a, 0xe0}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashOwnerReference = [16]byte{0x2f, 0x12, 0xfb, 0xe2, 0xf5, 0x60, 0x0a, 0x8b, 0x83, 0xd2, 0xb5, 0x6a, 0x24, 0x5c, 0xc1, 0x98}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPersistentVolumeClaimSpec = [16]byte{0xac, 0xc8, 0x30, 0x0c, 0xf0, 0xe8, 0xa2, 0x1f, 0x57, 0xf3, 0xf1, 0x8f, 0x1c, 0x72, 0xa5, 0xc1}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPersistentVolumeClaimTemplate = [16]byte{0x2a, 0x59, 0xe1, 0x3b, 0xdf, 0x55, 0x91, 0xcd, 0xe3, 0xa4, 0x1a, 0xef, 0xbe, 0x16, 0x21, 0x62}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPersistentVolumeClaimVolumeSource = [16]byte{0x2d, 0x96, 0xdb, 0x3f, 0x77, 0x7f, 0xbf, 0x35, 0x30, 0xd9, 0xb2, 0x0e, 0xdd, 0xd2, 0x34, 0x38}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPod = [16]byte{0x3d, 0x62, 0x4c, 0x0b, 0x96, 0xa5, 0x92, 0xdc, 0xb0, 0x62, 0x17, 0x44, 0x17, 0xeb, 0xc5, 0x4a}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodAffinity = [16]byte{0x75, 0x02, 0x3a, 0x01, 0xc9, 0x50, 0x66, 0x3e, 0xb4, 0x37, 0x02, 0xe7, 0x6f, 0x0c, 0x39, 0xd4}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodAffinityTerm = [16]byte{0x75, 0x5e, 0xe6, 0x80, 0x44, 0xf8, 0x15, 0x40, 0xdd, 0x52, 0xab, 0x68, 0x6e, 0xcd, 0xe4, 0x1b}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodAntiAffinity = [16]byte{0x4d, 0xcf, 0x4f, 0xc6, 0xeb, 0x95, 0xf1, 0xc1, 0x69, 0xe4, 0x38, 0xb6, 0x48, 0x03, 0x01, 0x57}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodCondition = [16]byte{0xc2, 0x34, 0xea, 0xbf, 0xac, 0x03, 0xb7, 0x71, 0x8f, 0xd6, 0x41, 0x93, 0x4e, 0x8d, 0x83, 0x71}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodDNSConfig = [16]byte{0x95, 0xd5, 0x44, 0x91, 0x3c, 0x4b, 0xa5, 0x92, 0x04, 0x96, 0x9f, 0x9c, 0x4f, 0xb3, 0x8a, 0x76}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodDNSConfigOption = [16]byte{0x8f, 0x6a, 0xa9, 0x89, 0xfa, 0x44, 0xba, 0x4f, 0x1e, 0xd7, 0x18, 0x7e, 0xd4, 0xba, 0xae, 0x02}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodIP = [16]byte{0x6f, 0x99, 0x48, 0xd3, 0xae, 0xa0, 0x9e, 0x44, 0x8d, 0x4c, 0x27, 0x64, 0xc8, 0xb1, 0x66, 0xed}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodOS = [16]byte{0x88, 0x3e, 0xa9, 0xb0, 0x20, 0xa0, 0xa5, 0xdf, 0x84, 0xca, 0x4e, 0xa4, 0x67, 0x99, 0x81, 0x22}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodReadinessGate = [16]byte{0x5e, 0xb4, 0x35, 0x5d, 0xe1, 0xa3, 0x77, 0xd9, 0x0a, 0x6a, 0x9a, 0x98, 0xc0, 0xb7, 0xf7, 0x24}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodResourceClaim = [16]byte{0x2c, 0xc3, 0xdc, 0x46, 0xb6, 0xf2, 0xdb, 0xd6, 0xe1, 0x62, 0x12, 0x2d, 0x47, 0x2b, 0x09, 0x54}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodResourceClaimStatus = [16]byte{0x34, 0xfd, 0x49, 0x61, 0x04, 0xd3, 0xfa, 0xec, 0xd7, 0xf1, 0x0d, 0x7f, 0x1f, 0x6b, 0x53, 0xe6}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodSchedulingGate = [16]byte{0xd6, 0x02, 0xf0, 0xd6, 0xf8, 0xd6, 0x96, 0x14, 0x8c, 0x27, 0x7b, 0xcb, 0xff, 0x37, 0x1f, 0x14}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodSecurityContext = [16]byte{0x67, 0x74, 0x14, 0x0a, 0x88, 0x99, 0xd3, 0x3a, 0xa8, 0x91, 0x80, 0x37, 0xaa, 0xab, 0x4f, 0x96}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodSpec = [16]byte{0x45, 0x66, 0xac, 0x1f, 0x7d, 0x40, 0x50, 0x84, 0xaa, 0x4b, 0xb0, 0x92, 0xaf, 0xf4, 0xc4, 0xe1}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPodStatus = [16]byte{0xa6, 0x04, 0xde, 0x26, 0x47, 0x43, 0xde, 0x65, 0x63, 0x9e, 0xb2, 0x43, 0x28, 0xc5, 0x90, 0xc5}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashPreferredSchedulingTerm = [16]byte{0x11, 0x08, 0x5c, 0xa4, 0x98, 0x41, 0xfc, 0x30, 0xe6, 0x7c, 0x7c, 0x64, 0x56, 0x8c, 0x8a, 0xc4}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashProbe = [16]byte{0x76, 0xa9, 0x69, 0x51, 0x27, 0xe7, 0xdb, 0x00, 0x68, 0x99, 0xd1, 0xd3, 0xb9, 0x88, 0xf7, 0xdf}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashProbeHandler = [16]byte{0x51, 0x1f, 0x2f, 0x56, 0x21, 0xc8, 0xff, 0xea, 0x0e, 0xd9, 0xac, 0x25, 0x0e, 0xa7, 0x9b, 0x88}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashProjectedVolumeSource = [16]byte{0x7e, 0x87, 0xc4, 0xe4, 0x8a, 0x64, 0xe4, 0xc2, 0x48, 0x2b, 0xb4, 0x09, 0xd0, 0xb5, 0xec, 0xc8}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashResourceClaim = [16]byte{0x66, 0x86, 0xfe, 0x46, 0x4c, 0x12, 0x11, 0xbe, 0x34, 0xc7, 0xe0, 0xae, 0x90, 0xe0, 0x10, 0xae}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashResourceFieldSelector = [16]byte{0xaf, 0x12, 0x32, 0xf5, 0x6c, 0x2e, 0x40, 0x8e, 0xbd, 0x24, 0xe6, 0x50, 0x77, 0x46, 0xd4, 0x3d}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashResourceRequirements = [16]byte{0xe0, 0x9a, 0x1b, 0xe2, 0xc5, 0xc7, 0x32, 0x4f, 0x17, 0x2d, 0x44, 0x21, 0x07, 0x1d, 0x94, 0x9c}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSELinuxOptions = [16]byte{0x5f, 0x1d, 0x97, 0x28, 0xd7, 0x74, 0xb4, 0xef, 0x21, 0x17, 0x0a, 0x88, 0xdb, 0x6a, 0xeb, 0x8e}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSeccompProfile = [16]byte{0x12, 0x71, 0xa4, 0xc8, 0xcb, 0x8e, 0x4b, 0xe1, 0x1a, 0x9a, 0xd1, 0x96, 0x1d, 0xc6, 0x35, 0x22}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSecretEnvSource = [16]byte{0x91, 0x6e, 0xe0, 0x3d, 0x7d, 0xd6, 0x5b, 0x54, 0xaa, 0xdf, 0x45, 0x0f, 0xd2, 0x28, 0xc4, 0x7d}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSecretKeySelector = [16]byte{0x9d, 0xf8, 0xdb, 0x84, 0xc3, 0x7d, 0x2e, 0x17, 0x35, 0xef, 0x50, 0x37, 0x61, 0x9b, 0x99, 0xae}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSecretProjection = [16]byte{0x91, 0xdc, 0xee, 0x62, 0x2f, 0x2b, 0xce, 0xa8, 0x90, 0x76, 0xe9, 0x74, 0x15, 0x72, 0x50, 0xff}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSecretVolumeSource = [16]byte{0x9e, 0xa8, 0xc8, 0xd4, 0x7f, 0xde, 0x42, 0x7f, 0x8b, 0x1b, 0x9e, 0x67, 0xc9, 0x1f, 0x19, 0xa6}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSecurityContext = [16]byte{0x3e, 0xa8, 0x01, 0x08, 0xc0, 0x07, 0x81, 0x9b, 0x33, 0x47, 0x9a, 0x8b, 0x1c, 0x49, 0xe0, 0xc8}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashServiceAccountTokenProjection = [16]byte{0x53, 0x8d, 0xd8, 0xe1, 0x0a, 0xee, 0x62, 0x7a, 0xd0, 0x62, 0xc9, 0x55, 0x31, 0x8f, 0xdc, 0x68}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSleepAction = [16]byte{0x12, 0x42, 0xee, 0xf8, 0x48, 0x56, 0x11, 0x54, 0xbd, 0x29, 0xa3, 0x0c, 0x1a, 0x65, 0x68, 0xb0}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashSysctl = [16]byte{0x83, 0xf8, 0xe8, 0x16, 0x93, 0x63, 0xea, 0x15, 0x53, 0xff, 0x97, 0x93, 0x57, 0x51, 0x1b, 0xd6}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashTCPSocketAction = [16]byte{0x9e, 0xfd, 0xd7, 0x60, 0x29, 0x94, 0x96, 0xcf, 0x3c, 0x53, 0xde, 0xa7, 0xa4, 0x1b, 0xdf, 0x0e}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashTime = [16]byte{0x3e, 0xb5, 0xba, 0x68, 0xaf, 0xac, 0xad, 0xf2, 0xf9, 0x1c, 0x77, 0x3a, 0x62, 0x49, 0x22, 0xd9}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashToleration = [16]byte{0xb8, 0xdc, 0x41, 0x6b, 0x45, 0x0f, 0x5e, 0xcc, 0xeb, 0xb7, 0xb3, 0x42, 0x99, 0x05, 0x7b, 0x0e}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashTopologySpreadConstraint = [16]byte{0x5c, 0xe4, 0x94, 0x6e, 0x26, 0x9b, 0xd6, 0x6c, 0x8f, 0xcb, 0x83, 0x93, 0xdf, 0xe6, 0xf5, 0xef}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashTypeMeta = [16]byte{0x53, 0x1b, 0x37, 0xe8, 0x49, 0xe9, 0xff, 0xba, 0xbf, 0x04, 0xf5, 0x01, 0x7c, 0x2b, 0x89, 0xa3}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashTypedLocalObjectReference = [16]byte{0xbc, 0x1b, 0xa6, 0xe6, 0x9b, 0xd5, 0x3e, 0x08, 0xa1, 0x71, 0xe5, 0xae, 0x31, 0xad, 0x87, 0xda}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashTypedObjectReference = [16]byte{0xb3, 0x3c, 0x98, 0x85, 0x54, 0x69, 0x12, 0x72, 0xc6, 0xd1, 0x24, 0x8a, 0xcc, 0xf3, 0xa8, 0xf6}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashVolume = [16]byte{0x5c, 0x60, 0x41, 0x62, 0x5f, 0xe2, 0x0c, 0xd1, 0x96, 0x3d, 0x57, 0x89, 0x8c, 0x05, 0x66, 0xf2}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashVolumeDevice = [16]byte{0x74, 0xb9, 0x6d, 0xa2, 0x09, 0xca, 0x85, 0xf2, 0xba, 0x36, 0x26, 0xdb, 0xb4, 0x4f, 0x0e, 0x05}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashVolumeMount = [16]byte{0x76, 0x7a, 0xf7, 0x39, 0x41, 0x4c, 0xf1, 0x90, 0x68, 0xb6, 0xef, 0xfc, 0xa4, 0xdf, 0xe9, 0x9a}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashVolumeMountStatus = [16]byte{0xde, 0x8c, 0xde, 0x7e, 0xea, 0x9e, 0x3e, 0x70, 0x44, 0xd7, 0xf5, 0x9d, 0x90, 0x23, 0xa4, 0x7f}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashVolumeProjection = [16]byte{0x2a, 0x21, 0xfb, 0x5a, 0x44, 0x74, 0x18, 0x3e, 0xc5, 0x6c, 0x42, 0x36, 0x45, 0x66, 0x4b, 0xae}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashVolumeSource = [16]byte{0x07, 0x67, 0xa0, 0x93, 0x17, 0xb1, 0x15, 0x36, 0x38, 0x3b, 0x05, 0x37, 0x32, 0xf5, 0x15, 0xb1}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashWeightedPodAffinityTerm = [16]byte{0x10, 0x77, 0xb5, 0xd3, 0x30, 0xeb, 0x1a, 0xa5, 0xfb, 0x90, 0x47, 0x98, 0x9c, 0x8b, 0x92, 0x53}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXTypeHashWindowsSecurityContextOptions = [16]byte{0xdf, 0x4a, 0xd2, 0xf0, 0x4b, 0x32, 0x53, 0xd1, 0x99, 0x66, 0xf8, 0x32, 0xc5, 0x5b, 0xcb, 0xb9}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingAWSElasticBlockStoreVolumeSource = &mapping.Map{
    Name: "AWSElasticBlockStoreVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "VolumeId",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "FsType",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Partition",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReadOnly",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingAffinity = &mapping.Map{
    Name: "Affinity",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "NodeAffinity",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "NodeAffinity",
            
            Mapping: XXXMappingNodeAffinity,
        },
        {
            Name: "PodAffinity",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "PodAffinity",
            
            Mapping: XXXMappingPodAffinity,
        },
        {
            Name: "PodAntiAffinity",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "PodAntiAffinity",
            
            Mapping: XXXMappingPodAntiAffinity,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingAppArmorProfile = &mapping.Map{
    Name: "AppArmorProfile",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Type",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "AppArmorProfileType",
        },
        {
            Name: "LocalhostProfile",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingCSIVolumeSource = &mapping.Map{
    Name: "CSIVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Driver",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReadOnly",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "FsType",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "VolumeAttributes",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "NodePublishSecretRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
            StructName: "LocalObjectReference",
            
            Mapping: XXXMappingLocalObjectReference,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingCapabilities = &mapping.Map{
    Name: "Capabilities",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Add",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Drop",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingClusterTrustBundleProjection = &mapping.Map{
    Name: "ClusterTrustBundleProjection",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SignerName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "LabelSelector",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "LabelSelector",
            
            Mapping: XXXMappingLabelSelector,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Path",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingConfigMapEnvSource = &mapping.Map{
    Name: "ConfigMapEnvSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingConfigMapKeySelector = &mapping.Map{
    Name: "ConfigMapKeySelector",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Key",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingConfigMapProjection = &mapping.Map{
    Name: "ConfigMapProjection",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Items",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyToPath",
            
            Mapping: XXXMappingKeyToPath,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingConfigMapVolumeSource = &mapping.Map{
    Name: "ConfigMapVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Items",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyToPath",
            
            Mapping: XXXMappingKeyToPath,
        },
        {
            Name: "DefaultMode",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingContainer = &mapping.Map{
    Name: "Container",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Image",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Command",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Args",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "WorkingDir",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Ports",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerPort",
            
            Mapping: XXXMappingContainerPort,
        },
        {
            Name: "EnvFrom",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
            StructName: "EnvFromSource",
            
            Mapping: XXXMappingEnvFromSource,
        },
        {
            Name: "Env",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
            StructName: "EnvVar",
            
            Mapping: XXXMappingEnvVar,
        },
        {
            Name: "Resources",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "ResourceRequirements",
            
            Mapping: XXXMappingResourceRequirements,
        },
        {
            Name: "ResizePolicy",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerResizePolicy",
            
            Mapping: XXXMappingContainerResizePolicy,
        },
        {
            Name: "RestartPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "ContainerRestartPolicy",
        },
        {
            Name: "VolumeMounts",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
            StructName: "VolumeMount",
            
            Mapping: XXXMappingVolumeMount,
        },
        {
            Name: "VolumeDevices",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 12,
            IsEnum: false,
            IsAny: false,
            StructName: "VolumeDevice",
            
            Mapping: XXXMappingVolumeDevice,
        },
        {
            Name: "LivenessProbe",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 13,
            IsEnum: false,
            IsAny: false,
            StructName: "Probe",
            
            Mapping: XXXMappingProbe,
        },
        {
            Name: "ReadinessProbe",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 14,
            IsEnum: false,
            IsAny: false,
            StructName: "Probe",
            
            Mapping: XXXMappingProbe,
        },
        {
            Name: "StartupProbe",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 15,
            IsEnum: false,
            IsAny: false,
            StructName: "Probe",
            
            Mapping: XXXMappingProbe,
        },
        {
            Name: "Lifecycle",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 16,
            IsEnum: false,
            IsAny: false,
            StructName: "Lifecycle",
            
            Mapping: XXXMappingLifecycle,
        },
        {
            Name: "TerminationMessagePath",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 17,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "TerminationMessagePolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 18,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "TerminationMessagePolicy",
        },
        {
            Name: "ImagePullPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 19,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PullPolicy",
        },
        {
            Name: "SecurityContext",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 20,
            IsEnum: false,
            IsAny: false,
            StructName: "SecurityContext",
            
            Mapping: XXXMappingSecurityContext,
        },
        {
            Name: "Stdin",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 21,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "StdinOnce",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 22,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Tty",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 23,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingContainerPort = &mapping.Map{
    Name: "ContainerPort",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "HostPort",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ContainerPort",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Protocol",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "Protocol",
        },
        {
            Name: "HostIp",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingContainerResizePolicy = &mapping.Map{
    Name: "ContainerResizePolicy",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ResourceName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RestartPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "ResourceResizeRestartPolicy",
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingContainerState = &mapping.Map{
    Name: "ContainerState",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Waiting",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerStateWaiting",
            
            Mapping: XXXMappingContainerStateWaiting,
        },
        {
            Name: "Running",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerStateRunning",
            
            Mapping: XXXMappingContainerStateRunning,
        },
        {
            Name: "Terminated",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerStateTerminated",
            
            Mapping: XXXMappingContainerStateTerminated,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingContainerStateRunning = &mapping.Map{
    Name: "ContainerStateRunning",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "StartedAt",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingContainerStateTerminated = &mapping.Map{
    Name: "ContainerStateTerminated",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ExitCode",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Signal",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Reason",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Message",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "StartedAt",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
        {
            Name: "FinishedAt",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
        {
            Name: "ContainerId",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingContainerStateWaiting = &mapping.Map{
    Name: "ContainerStateWaiting",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Reason",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Message",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingContainerStatus = &mapping.Map{
    Name: "ContainerStatus",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "State",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerState",
            
            Mapping: XXXMappingContainerState,
        },
        {
            Name: "LastTerminationState",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerState",
            
            Mapping: XXXMappingContainerState,
        },
        {
            Name: "Ready",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RestartCount",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Image",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ImageId",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ContainerId",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Started",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "AllocatedResources",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "Resources",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: false,
            IsAny: false,
            StructName: "ResourceRequirements",
            
            Mapping: XXXMappingResourceRequirements,
        },
        {
            Name: "VolumeMounts",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
            StructName: "VolumeMountStatus",
            
            Mapping: XXXMappingVolumeMountStatus,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingDownwardAPIProjection = &mapping.Map{
    Name: "DownwardAPIProjection",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Items",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "DownwardAPIVolumeFile",
            
            Mapping: XXXMappingDownwardAPIVolumeFile,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingDownwardAPIVolumeFile = &mapping.Map{
    Name: "DownwardAPIVolumeFile",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Path",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "FieldRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "ObjectFieldSelector",
            
            Mapping: XXXMappingObjectFieldSelector,
        },
        {
            Name: "ResourceFieldRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "ResourceFieldSelector",
            
            Mapping: XXXMappingResourceFieldSelector,
        },
        {
            Name: "Mode",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingDownwardAPIVolumeSource = &mapping.Map{
    Name: "DownwardAPIVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Items",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "DownwardAPIVolumeFile",
            
            Mapping: XXXMappingDownwardAPIVolumeFile,
        },
        {
            Name: "DefaultMode",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingEmptyDirVolumeSource = &mapping.Map{
    Name: "EmptyDirVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Medium",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "StorageMedium",
        },
        {
            Name: "SizeLimit",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingEnvFromSource = &mapping.Map{
    Name: "EnvFromSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Prefix",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ConfigMapRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "ConfigMapEnvSource",
            
            Mapping: XXXMappingConfigMapEnvSource,
        },
        {
            Name: "SecretRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "SecretEnvSource",
            
            Mapping: XXXMappingSecretEnvSource,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingEnvVar = &mapping.Map{
    Name: "EnvVar",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Value",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ValueFrom",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "EnvVarSource",
            
            Mapping: XXXMappingEnvVarSource,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingEnvVarSource = &mapping.Map{
    Name: "EnvVarSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "FieldRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "ObjectFieldSelector",
            
            Mapping: XXXMappingObjectFieldSelector,
        },
        {
            Name: "ResourceFieldRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "ResourceFieldSelector",
            
            Mapping: XXXMappingResourceFieldSelector,
        },
        {
            Name: "ConfigMapKeyRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "ConfigMapKeySelector",
            
            Mapping: XXXMappingConfigMapKeySelector,
        },
        {
            Name: "SecretKeyRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "SecretKeySelector",
            
            Mapping: XXXMappingSecretKeySelector,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingEphemeralContainer = &mapping.Map{
    Name: "EphemeralContainer",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Image",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Command",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Args",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "WorkingDir",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Ports",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerPort",
            
            Mapping: XXXMappingContainerPort,
        },
        {
            Name: "EnvFrom",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
            StructName: "EnvFromSource",
            
            Mapping: XXXMappingEnvFromSource,
        },
        {
            Name: "Env",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
            StructName: "EnvVar",
            
            Mapping: XXXMappingEnvVar,
        },
        {
            Name: "Resources",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "ResourceRequirements",
            
            Mapping: XXXMappingResourceRequirements,
        },
        {
            Name: "VolumeMounts",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: false,
            IsAny: false,
            StructName: "VolumeMount",
            
            Mapping: XXXMappingVolumeMount,
        },
        {
            Name: "VolumeDevices",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: false,
            IsAny: false,
            StructName: "VolumeDevice",
            
            Mapping: XXXMappingVolumeDevice,
        },
        {
            Name: "LivenessProbe",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
            StructName: "Probe",
            
            Mapping: XXXMappingProbe,
        },
        {
            Name: "ReadinessProbe",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 12,
            IsEnum: false,
            IsAny: false,
            StructName: "Probe",
            
            Mapping: XXXMappingProbe,
        },
        {
            Name: "StartupProbe",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 13,
            IsEnum: false,
            IsAny: false,
            StructName: "Probe",
            
            Mapping: XXXMappingProbe,
        },
        {
            Name: "Lifecycle",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 14,
            IsEnum: false,
            IsAny: false,
            StructName: "Lifecycle",
            
            Mapping: XXXMappingLifecycle,
        },
        {
            Name: "TerminationMessagePath",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 15,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "TerminationMessagePolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 16,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "TerminationMessagePolicy",
        },
        {
            Name: "ImagePullPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 17,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PullPolicy",
        },
        {
            Name: "SecurityContext",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 18,
            IsEnum: false,
            IsAny: false,
            StructName: "SecurityContext",
            
            Mapping: XXXMappingSecurityContext,
        },
        {
            Name: "Stdin",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 19,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "StdinOnce",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 20,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Tty",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 21,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "TargetContainerName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 22,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingEphemeralVolumeSource = &mapping.Map{
    Name: "EphemeralVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "VolumeClaimTemplate",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "PersistentVolumeClaimTemplate",
            
            Mapping: XXXMappingPersistentVolumeClaimTemplate,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingExecAction = &mapping.Map{
    Name: "ExecAction",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Command",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingGCEPersistentDiskVolumeSource = &mapping.Map{
    Name: "GCEPersistentDiskVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "PdName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "FsType",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Partition",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReadOnly",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingGRPCAction = &mapping.Map{
    Name: "GRPCAction",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Port",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Service",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingHTTPGetAction = &mapping.Map{
    Name: "HTTPGetAction",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Path",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Port",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "IntOrString",
            
            Mapping: XXXMappingIntOrString,
        },
        {
            Name: "Host",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Scheme",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "URIScheme",
        },
        {
            Name: "HttpHeaders",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
            StructName: "HTTPHeader",
            
            Mapping: XXXMappingHTTPHeader,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingHTTPHeader = &mapping.Map{
    Name: "HTTPHeader",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Value",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingHostAlias = &mapping.Map{
    Name: "HostAlias",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Ip",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Hostnames",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingHostIP = &mapping.Map{
    Name: "HostIP",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Ip",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingHostPathVolumeSource = &mapping.Map{
    Name: "HostPathVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Path",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Type",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "HostPathType",
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingIntOrString = &mapping.Map{
    Name: "IntOrString",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "IntVal",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "StrVal",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "IsString",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingKeyToPath = &mapping.Map{
    Name: "KeyToPath",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Key",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Path",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Mode",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingKeyValue = &mapping.Map{
    Name: "KeyValue",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Key",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Value",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingLabelSelector = &mapping.Map{
    Name: "LabelSelector",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "MatchLabels",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "MatchExpressions",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "LabelSelectorRequirement",
            
            Mapping: XXXMappingLabelSelectorRequirement,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingLabelSelectorRequirement = &mapping.Map{
    Name: "LabelSelectorRequirement",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Key",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Operator",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "LabelSelectorOperator",
        },
        {
            Name: "Values",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingLifecycle = &mapping.Map{
    Name: "Lifecycle",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "PostStart",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "LifecycleHandler",
            
            Mapping: XXXMappingLifecycleHandler,
        },
        {
            Name: "PreStop",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "LifecycleHandler",
            
            Mapping: XXXMappingLifecycleHandler,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingLifecycleHandler = &mapping.Map{
    Name: "LifecycleHandler",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Exec",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "ExecAction",
            
            Mapping: XXXMappingExecAction,
        },
        {
            Name: "HttpGet",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "HTTPGetAction",
            
            Mapping: XXXMappingHTTPGetAction,
        },
        {
            Name: "TcpSocket",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "TCPSocketAction",
            
            Mapping: XXXMappingTCPSocketAction,
        },
        {
            Name: "Sleep",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "SleepAction",
            
            Mapping: XXXMappingSleepAction,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingLocalObjectReference = &mapping.Map{
    Name: "LocalObjectReference",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingManagedFieldsEntry = &mapping.Map{
    Name: "ManagedFieldsEntry",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Manager",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Operation",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ApiVersion",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Time",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
        {
            Name: "FieldsType",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "FieldsV1",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Subresource",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingNFSVolumeSource = &mapping.Map{
    Name: "NFSVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Server",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Path",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReadOnly",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingNodeAffinity = &mapping.Map{
    Name: "NodeAffinity",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "RequiredDuringSchedulingIgnoredDuringExecution",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "NodeSelector",
            
            Mapping: XXXMappingNodeSelector,
        },
        {
            Name: "PreferredDuringSchedulingIgnoredDuringExecution",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "PreferredSchedulingTerm",
            
            Mapping: XXXMappingPreferredSchedulingTerm,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingNodeSelector = &mapping.Map{
    Name: "NodeSelector",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "NodeSelectorTerms",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "NodeSelectorTerm",
            
            Mapping: XXXMappingNodeSelectorTerm,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingNodeSelectorRequirement = &mapping.Map{
    Name: "NodeSelectorRequirement",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Key",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Operator",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "NodeSelectorOperator",
        },
        {
            Name: "Values",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingNodeSelectorTerm = &mapping.Map{
    Name: "NodeSelectorTerm",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "MatchExpressions",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "NodeSelectorRequirement",
            
            Mapping: XXXMappingNodeSelectorRequirement,
        },
        {
            Name: "MatchFields",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "NodeSelectorRequirement",
            
            Mapping: XXXMappingNodeSelectorRequirement,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingObjectFieldSelector = &mapping.Map{
    Name: "ObjectFieldSelector",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ApiVersion",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "FieldPath",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingObjectMeta = &mapping.Map{
    Name: "ObjectMeta",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "GenerateName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Namespace",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SelfLink",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Uid",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ResourceVersion",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Generation",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "CreationTimestamp",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
        {
            Name: "DeletionTimestamp",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
        {
            Name: "DeletionGracePeriodSeconds",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Labels",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "Annotations",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "OwnerReferences",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 12,
            IsEnum: false,
            IsAny: false,
            StructName: "OwnerReference",
            
            Mapping: XXXMappingOwnerReference,
        },
        {
            Name: "Finalizers",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 13,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ManagedFields",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 14,
            IsEnum: false,
            IsAny: false,
            StructName: "ManagedFieldsEntry",
            
            Mapping: XXXMappingManagedFieldsEntry,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingOwnerReference = &mapping.Map{
    Name: "OwnerReference",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ApiVersion",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Kind",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Uid",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Controller",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "BlockOwnerDeletion",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPersistentVolumeClaimSpec = &mapping.Map{
    Name: "PersistentVolumeClaimSpec",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "AccessModes",
            Type: field.FTListUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PersistentVolumeAccessMode",
        },
        {
            Name: "Selector",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "LabelSelector",
            
            Mapping: XXXMappingLabelSelector,
        },
        {
            Name: "Resources",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "ResourceRequirements",
            
            Mapping: XXXMappingResourceRequirements,
        },
        {
            Name: "VolumeName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "StorageClassName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "VolumeMode",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PersistentVolumeMode",
        },
        {
            Name: "DataSource",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
            StructName: "TypedLocalObjectReference",
            
            Mapping: XXXMappingTypedLocalObjectReference,
        },
        {
            Name: "DataSourceRef",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
            StructName: "TypedObjectReference",
            
            Mapping: XXXMappingTypedObjectReference,
        },
        {
            Name: "VolumeAttributesClassName",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPersistentVolumeClaimTemplate = &mapping.Map{
    Name: "PersistentVolumeClaimTemplate",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Metadata",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "ObjectMeta",
            
            Mapping: XXXMappingObjectMeta,
        },
        {
            Name: "Spec",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "PersistentVolumeClaimSpec",
            
            Mapping: XXXMappingPersistentVolumeClaimSpec,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPersistentVolumeClaimVolumeSource = &mapping.Map{
    Name: "PersistentVolumeClaimVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ClaimName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReadOnly",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPod = &mapping.Map{
    Name: "Pod",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "TypeMeta",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "TypeMeta",
            
            Mapping: XXXMappingTypeMeta,
        },
        {
            Name: "Metadata",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "ObjectMeta",
            
            Mapping: XXXMappingObjectMeta,
        },
        {
            Name: "Spec",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "PodSpec",
            
            Mapping: XXXMappingPodSpec,
        },
        {
            Name: "Status",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "PodStatus",
            
            Mapping: XXXMappingPodStatus,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodAffinity = &mapping.Map{
    Name: "PodAffinity",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "RequiredDuringSchedulingIgnoredDuringExecution",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "PodAffinityTerm",
            
            Mapping: XXXMappingPodAffinityTerm,
        },
        {
            Name: "PreferredDuringSchedulingIgnoredDuringExecution",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "WeightedPodAffinityTerm",
            
            Mapping: XXXMappingWeightedPodAffinityTerm,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodAffinityTerm = &mapping.Map{
    Name: "PodAffinityTerm",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "LabelSelector",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "LabelSelector",
            
            Mapping: XXXMappingLabelSelector,
        },
        {
            Name: "Namespaces",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "TopologyKey",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "NamespaceSelector",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "LabelSelector",
            
            Mapping: XXXMappingLabelSelector,
        },
        {
            Name: "MatchLabelKeys",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "MismatchLabelKeys",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodAntiAffinity = &mapping.Map{
    Name: "PodAntiAffinity",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "RequiredDuringSchedulingIgnoredDuringExecution",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "PodAffinityTerm",
            
            Mapping: XXXMappingPodAffinityTerm,
        },
        {
            Name: "PreferredDuringSchedulingIgnoredDuringExecution",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "WeightedPodAffinityTerm",
            
            Mapping: XXXMappingWeightedPodAffinityTerm,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodCondition = &mapping.Map{
    Name: "PodCondition",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Type",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PodConditionType",
        },
        {
            Name: "Status",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "ConditionStatus",
        },
        {
            Name: "LastProbeTime",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
        {
            Name: "LastTransitionTime",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
        {
            Name: "Reason",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Message",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodDNSConfig = &mapping.Map{
    Name: "PodDNSConfig",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Nameservers",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Searches",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Options",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "PodDNSConfigOption",
            
            Mapping: XXXMappingPodDNSConfigOption,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodDNSConfigOption = &mapping.Map{
    Name: "PodDNSConfigOption",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Value",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodIP = &mapping.Map{
    Name: "PodIP",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Ip",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodOS = &mapping.Map{
    Name: "PodOS",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodReadinessGate = &mapping.Map{
    Name: "PodReadinessGate",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ConditionType",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PodConditionType",
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodResourceClaim = &mapping.Map{
    Name: "PodResourceClaim",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ResourceClaimName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ResourceClaimTemplateName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodResourceClaimStatus = &mapping.Map{
    Name: "PodResourceClaimStatus",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ResourceClaimName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodSchedulingGate = &mapping.Map{
    Name: "PodSchedulingGate",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodSecurityContext = &mapping.Map{
    Name: "PodSecurityContext",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "SeLinuxOptions",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "SELinuxOptions",
            
            Mapping: XXXMappingSELinuxOptions,
        },
        {
            Name: "WindowsOptions",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "WindowsSecurityContextOptions",
            
            Mapping: XXXMappingWindowsSecurityContextOptions,
        },
        {
            Name: "RunAsUser",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RunAsGroup",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RunAsNonRoot",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SupplementalGroups",
            Type: field.FTListInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SupplementalGroupsPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "SupplementalGroupsPolicy",
        },
        {
            Name: "FsGroup",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Sysctls",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "Sysctl",
            
            Mapping: XXXMappingSysctl,
        },
        {
            Name: "FsGroupChangePolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PodFSGroupChangePolicy",
        },
        {
            Name: "SeccompProfile",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: false,
            IsAny: false,
            StructName: "SeccompProfile",
            
            Mapping: XXXMappingSeccompProfile,
        },
        {
            Name: "AppArmorProfile",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
            StructName: "AppArmorProfile",
            
            Mapping: XXXMappingAppArmorProfile,
        },
        {
            Name: "SeLinuxChangePolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 12,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PodSELinuxChangePolicy",
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodSpec = &mapping.Map{
    Name: "PodSpec",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Volumes",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "Volume",
            
            Mapping: XXXMappingVolume,
        },
        {
            Name: "InitContainers",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "Container",
            
            Mapping: XXXMappingContainer,
        },
        {
            Name: "Containers",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "Container",
            
            Mapping: XXXMappingContainer,
        },
        {
            Name: "EphemeralContainers",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "EphemeralContainer",
            
            Mapping: XXXMappingEphemeralContainer,
        },
        {
            Name: "RestartPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "RestartPolicy",
        },
        {
            Name: "TerminationGracePeriodSeconds",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ActiveDeadlineSeconds",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "DnsPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "DNSPolicy",
        },
        {
            Name: "NodeSelector",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "ServiceAccountName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "AutomountServiceAccountToken",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "NodeName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "HostNetwork",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 12,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "HostPid",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 13,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "HostIpc",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 14,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ShareProcessNamespace",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 15,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SecurityContext",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 16,
            IsEnum: false,
            IsAny: false,
            StructName: "PodSecurityContext",
            
            Mapping: XXXMappingPodSecurityContext,
        },
        {
            Name: "ImagePullSecrets",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 17,
            IsEnum: false,
            IsAny: false,
            StructName: "LocalObjectReference",
            
            Mapping: XXXMappingLocalObjectReference,
        },
        {
            Name: "Hostname",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 18,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Subdomain",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 19,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Affinity",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 20,
            IsEnum: false,
            IsAny: false,
            StructName: "Affinity",
            
            Mapping: XXXMappingAffinity,
        },
        {
            Name: "SchedulerName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 21,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Tolerations",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 22,
            IsEnum: false,
            IsAny: false,
            StructName: "Toleration",
            
            Mapping: XXXMappingToleration,
        },
        {
            Name: "HostAliases",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 23,
            IsEnum: false,
            IsAny: false,
            StructName: "HostAlias",
            
            Mapping: XXXMappingHostAlias,
        },
        {
            Name: "PriorityClassName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 24,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Priority",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 25,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "DnsConfig",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 26,
            IsEnum: false,
            IsAny: false,
            StructName: "PodDNSConfig",
            
            Mapping: XXXMappingPodDNSConfig,
        },
        {
            Name: "ReadinessGates",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 27,
            IsEnum: false,
            IsAny: false,
            StructName: "PodReadinessGate",
            
            Mapping: XXXMappingPodReadinessGate,
        },
        {
            Name: "RuntimeClassName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 28,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "EnableServiceLinks",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 29,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "PreemptionPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 30,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PreemptionPolicy",
        },
        {
            Name: "Overhead",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 31,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "TopologySpreadConstraints",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 32,
            IsEnum: false,
            IsAny: false,
            StructName: "TopologySpreadConstraint",
            
            Mapping: XXXMappingTopologySpreadConstraint,
        },
        {
            Name: "SetHostnameAsFqdn",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 33,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Os",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 34,
            IsEnum: false,
            IsAny: false,
            StructName: "PodOS",
            
            Mapping: XXXMappingPodOS,
        },
        {
            Name: "HostUsers",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 35,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SchedulingGates",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 36,
            IsEnum: false,
            IsAny: false,
            StructName: "PodSchedulingGate",
            
            Mapping: XXXMappingPodSchedulingGate,
        },
        {
            Name: "ResourceClaims",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 37,
            IsEnum: false,
            IsAny: false,
            StructName: "PodResourceClaim",
            
            Mapping: XXXMappingPodResourceClaim,
        },
        {
            Name: "Resources",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 38,
            IsEnum: false,
            IsAny: false,
            StructName: "ResourceRequirements",
            
            Mapping: XXXMappingResourceRequirements,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPodStatus = &mapping.Map{
    Name: "PodStatus",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Phase",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PodPhase",
        },
        {
            Name: "Conditions",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "PodCondition",
            
            Mapping: XXXMappingPodCondition,
        },
        {
            Name: "Message",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Reason",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "NominatedNodeName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "HostIp",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "HostIps",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
            StructName: "HostIP",
            
            Mapping: XXXMappingHostIP,
        },
        {
            Name: "PodIp",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "PodIps",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "PodIP",
            
            Mapping: XXXMappingPodIP,
        },
        {
            Name: "StartTime",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: false,
            IsAny: false,
            StructName: "Time",
            
            Mapping: XXXMappingTime,
        },
        {
            Name: "InitContainerStatuses",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerStatus",
            
            Mapping: XXXMappingContainerStatus,
        },
        {
            Name: "ContainerStatuses",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerStatus",
            
            Mapping: XXXMappingContainerStatus,
        },
        {
            Name: "QosClass",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 12,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PodQOSClass",
        },
        {
            Name: "EphemeralContainerStatuses",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 13,
            IsEnum: false,
            IsAny: false,
            StructName: "ContainerStatus",
            
            Mapping: XXXMappingContainerStatus,
        },
        {
            Name: "Resize",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 14,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "PodResizeStatus",
        },
        {
            Name: "ResourceClaimStatuses",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 15,
            IsEnum: false,
            IsAny: false,
            StructName: "PodResourceClaimStatus",
            
            Mapping: XXXMappingPodResourceClaimStatus,
        },
        {
            Name: "ObservedGeneration",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 16,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingPreferredSchedulingTerm = &mapping.Map{
    Name: "PreferredSchedulingTerm",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Weight",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Preference",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "NodeSelectorTerm",
            
            Mapping: XXXMappingNodeSelectorTerm,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingProbe = &mapping.Map{
    Name: "Probe",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Handler",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "ProbeHandler",
            
            Mapping: XXXMappingProbeHandler,
        },
        {
            Name: "InitialDelaySeconds",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "TimeoutSeconds",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "PeriodSeconds",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SuccessThreshold",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "FailureThreshold",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "TerminationGracePeriodSeconds",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingProbeHandler = &mapping.Map{
    Name: "ProbeHandler",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Exec",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "ExecAction",
            
            Mapping: XXXMappingExecAction,
        },
        {
            Name: "HttpGet",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "HTTPGetAction",
            
            Mapping: XXXMappingHTTPGetAction,
        },
        {
            Name: "TcpSocket",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "TCPSocketAction",
            
            Mapping: XXXMappingTCPSocketAction,
        },
        {
            Name: "Grpc",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "GRPCAction",
            
            Mapping: XXXMappingGRPCAction,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingProjectedVolumeSource = &mapping.Map{
    Name: "ProjectedVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Sources",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "VolumeProjection",
            
            Mapping: XXXMappingVolumeProjection,
        },
        {
            Name: "DefaultMode",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingResourceClaim = &mapping.Map{
    Name: "ResourceClaim",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Request",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingResourceFieldSelector = &mapping.Map{
    Name: "ResourceFieldSelector",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ContainerName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Resource",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Divisor",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingResourceRequirements = &mapping.Map{
    Name: "ResourceRequirements",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Limits",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "Requests",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyValue",
            
            Mapping: XXXMappingKeyValue,
        },
        {
            Name: "Claims",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "ResourceClaim",
            
            Mapping: XXXMappingResourceClaim,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSELinuxOptions = &mapping.Map{
    Name: "SELinuxOptions",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "User",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Role",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Type",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Level",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSeccompProfile = &mapping.Map{
    Name: "SeccompProfile",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Type",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "SeccompProfileType",
        },
        {
            Name: "LocalhostProfile",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSecretEnvSource = &mapping.Map{
    Name: "SecretEnvSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSecretKeySelector = &mapping.Map{
    Name: "SecretKeySelector",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Key",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSecretProjection = &mapping.Map{
    Name: "SecretProjection",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Items",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyToPath",
            
            Mapping: XXXMappingKeyToPath,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSecretVolumeSource = &mapping.Map{
    Name: "SecretVolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "SecretName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Items",
            Type: field.FTListStructs,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "KeyToPath",
            
            Mapping: XXXMappingKeyToPath,
        },
        {
            Name: "DefaultMode",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Optional",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSecurityContext = &mapping.Map{
    Name: "SecurityContext",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Capabilities",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "Capabilities",
            
            Mapping: XXXMappingCapabilities,
        },
        {
            Name: "Privileged",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SeLinuxOptions",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "SELinuxOptions",
            
            Mapping: XXXMappingSELinuxOptions,
        },
        {
            Name: "WindowsOptions",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "WindowsSecurityContextOptions",
            
            Mapping: XXXMappingWindowsSecurityContextOptions,
        },
        {
            Name: "RunAsUser",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RunAsGroup",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RunAsNonRoot",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReadOnlyRootFilesystem",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "AllowPrivilegeEscalation",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ProcMount",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "ProcMountType",
        },
        {
            Name: "SeccompProfile",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: false,
            IsAny: false,
            StructName: "SeccompProfile",
            
            Mapping: XXXMappingSeccompProfile,
        },
        {
            Name: "AppArmorProfile",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
            StructName: "AppArmorProfile",
            
            Mapping: XXXMappingAppArmorProfile,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingServiceAccountTokenProjection = &mapping.Map{
    Name: "ServiceAccountTokenProjection",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Audience",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ExpirationSeconds",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Path",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSleepAction = &mapping.Map{
    Name: "SleepAction",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Seconds",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingSysctl = &mapping.Map{
    Name: "Sysctl",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Value",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingTCPSocketAction = &mapping.Map{
    Name: "TCPSocketAction",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Port",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "IntOrString",
            
            Mapping: XXXMappingIntOrString,
        },
        {
            Name: "Host",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingTime = &mapping.Map{
    Name: "Time",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Seconds",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Nanos",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingToleration = &mapping.Map{
    Name: "Toleration",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Key",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Operator",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "TolerationOperator",
        },
        {
            Name: "Value",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Effect",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "TaintEffect",
        },
        {
            Name: "TolerationSeconds",
            Type: field.FTInt64,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingTopologySpreadConstraint = &mapping.Map{
    Name: "TopologySpreadConstraint",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "MaxSkew",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "TopologyKey",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "WhenUnsatisfiable",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "UnsatisfiableConstraintAction",
        },
        {
            Name: "LabelSelector",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "LabelSelector",
            
            Mapping: XXXMappingLabelSelector,
        },
        {
            Name: "MinDomains",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "NodeAffinityPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "NodeInclusionPolicy",
        },
        {
            Name: "NodeTaintsPolicy",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "NodeInclusionPolicy",
        },
        {
            Name: "MatchLabelKeys",
            Type: field.FTListStrings,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingTypeMeta = &mapping.Map{
    Name: "TypeMeta",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Kind",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ApiVersion",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingTypedLocalObjectReference = &mapping.Map{
    Name: "TypedLocalObjectReference",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ApiGroup",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Kind",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingTypedObjectReference = &mapping.Map{
    Name: "TypedObjectReference",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "ApiGroup",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Kind",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "Namespace",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingVolume = &mapping.Map{
    Name: "Volume",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "VolumeSource",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "VolumeSource",
            
            Mapping: XXXMappingVolumeSource,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingVolumeDevice = &mapping.Map{
    Name: "VolumeDevice",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "DevicePath",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingVolumeMount = &mapping.Map{
    Name: "VolumeMount",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReadOnly",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RecursiveReadOnly",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "RecursiveReadOnlyMode",
        },
        {
            Name: "MountPath",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "SubPath",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "MountPropagation",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "MountPropagationMode",
        },
        {
            Name: "SubPathExpr",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingVolumeMountStatus = &mapping.Map{
    Name: "VolumeMountStatus",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Name",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "MountPath",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "ReadOnly",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RecursiveReadOnly",
            Type: field.FTUint8,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: true,
            IsAny: false,
            EnumGroup: "RecursiveReadOnlyMode",
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingVolumeProjection = &mapping.Map{
    Name: "VolumeProjection",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Secret",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "SecretProjection",
            
            Mapping: XXXMappingSecretProjection,
        },
        {
            Name: "DownwardApi",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "DownwardAPIProjection",
            
            Mapping: XXXMappingDownwardAPIProjection,
        },
        {
            Name: "ConfigMap",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "ConfigMapProjection",
            
            Mapping: XXXMappingConfigMapProjection,
        },
        {
            Name: "ServiceAccountToken",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "ServiceAccountTokenProjection",
            
            Mapping: XXXMappingServiceAccountTokenProjection,
        },
        {
            Name: "ClusterTrustBundle",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
            StructName: "ClusterTrustBundleProjection",
            
            Mapping: XXXMappingClusterTrustBundleProjection,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingVolumeSource = &mapping.Map{
    Name: "VolumeSource",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "HostPath",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
            StructName: "HostPathVolumeSource",
            
            Mapping: XXXMappingHostPathVolumeSource,
        },
        {
            Name: "EmptyDir",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "EmptyDirVolumeSource",
            
            Mapping: XXXMappingEmptyDirVolumeSource,
        },
        {
            Name: "GcePersistentDisk",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
            StructName: "GCEPersistentDiskVolumeSource",
            
            Mapping: XXXMappingGCEPersistentDiskVolumeSource,
        },
        {
            Name: "AwsElasticBlockStore",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
            StructName: "AWSElasticBlockStoreVolumeSource",
            
            Mapping: XXXMappingAWSElasticBlockStoreVolumeSource,
        },
        {
            Name: "Secret",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 4,
            IsEnum: false,
            IsAny: false,
            StructName: "SecretVolumeSource",
            
            Mapping: XXXMappingSecretVolumeSource,
        },
        {
            Name: "Nfs",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 5,
            IsEnum: false,
            IsAny: false,
            StructName: "NFSVolumeSource",
            
            Mapping: XXXMappingNFSVolumeSource,
        },
        {
            Name: "PersistentVolumeClaim",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 6,
            IsEnum: false,
            IsAny: false,
            StructName: "PersistentVolumeClaimVolumeSource",
            
            Mapping: XXXMappingPersistentVolumeClaimVolumeSource,
        },
        {
            Name: "DownwardApi",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 7,
            IsEnum: false,
            IsAny: false,
            StructName: "DownwardAPIVolumeSource",
            
            Mapping: XXXMappingDownwardAPIVolumeSource,
        },
        {
            Name: "ConfigMap",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 8,
            IsEnum: false,
            IsAny: false,
            StructName: "ConfigMapVolumeSource",
            
            Mapping: XXXMappingConfigMapVolumeSource,
        },
        {
            Name: "Projected",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 9,
            IsEnum: false,
            IsAny: false,
            StructName: "ProjectedVolumeSource",
            
            Mapping: XXXMappingProjectedVolumeSource,
        },
        {
            Name: "Csi",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 10,
            IsEnum: false,
            IsAny: false,
            StructName: "CSIVolumeSource",
            
            Mapping: XXXMappingCSIVolumeSource,
        },
        {
            Name: "Ephemeral",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 11,
            IsEnum: false,
            IsAny: false,
            StructName: "EphemeralVolumeSource",
            
            Mapping: XXXMappingEphemeralVolumeSource,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingWeightedPodAffinityTerm = &mapping.Map{
    Name: "WeightedPodAffinityTerm",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "Weight",
            Type: field.FTInt32,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "PodAffinityTerm",
            Type: field.FTStruct,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
            StructName: "PodAffinityTerm",
            
            Mapping: XXXMappingPodAffinityTerm,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXMappingWindowsSecurityContextOptions = &mapping.Map{
    Name: "WindowsSecurityContextOptions",
    Pkg: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    Fields: []*mapping.FieldDescr{
        {
            Name: "GmsaCredentialSpecName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 0,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "GmsaCredentialSpec",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 1,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "RunAsUserName",
            Type: field.FTString,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 2,
            IsEnum: false,
            IsAny: false,
        },
        {
            Name: "HostProcess",
            Type: field.FTBool,
            Package: "pod",
            FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
            FieldNum: 3,
            IsEnum: false,
            IsAny: false,
        },
    },
}


// init initializes all mapping function pointer tables for O(1) dispatch.
func init() {
    XXXMappingAWSElasticBlockStoreVolumeSource.Init()
    XXXMappingAffinity.Init()
    XXXMappingAppArmorProfile.Init()
    XXXMappingCSIVolumeSource.Init()
    XXXMappingCapabilities.Init()
    XXXMappingClusterTrustBundleProjection.Init()
    XXXMappingConfigMapEnvSource.Init()
    XXXMappingConfigMapKeySelector.Init()
    XXXMappingConfigMapProjection.Init()
    XXXMappingConfigMapVolumeSource.Init()
    XXXMappingContainer.Init()
    XXXMappingContainerPort.Init()
    XXXMappingContainerResizePolicy.Init()
    XXXMappingContainerState.Init()
    XXXMappingContainerStateRunning.Init()
    XXXMappingContainerStateTerminated.Init()
    XXXMappingContainerStateWaiting.Init()
    XXXMappingContainerStatus.Init()
    XXXMappingDownwardAPIProjection.Init()
    XXXMappingDownwardAPIVolumeFile.Init()
    XXXMappingDownwardAPIVolumeSource.Init()
    XXXMappingEmptyDirVolumeSource.Init()
    XXXMappingEnvFromSource.Init()
    XXXMappingEnvVar.Init()
    XXXMappingEnvVarSource.Init()
    XXXMappingEphemeralContainer.Init()
    XXXMappingEphemeralVolumeSource.Init()
    XXXMappingExecAction.Init()
    XXXMappingGCEPersistentDiskVolumeSource.Init()
    XXXMappingGRPCAction.Init()
    XXXMappingHTTPGetAction.Init()
    XXXMappingHTTPHeader.Init()
    XXXMappingHostAlias.Init()
    XXXMappingHostIP.Init()
    XXXMappingHostPathVolumeSource.Init()
    XXXMappingIntOrString.Init()
    XXXMappingKeyToPath.Init()
    XXXMappingKeyValue.Init()
    XXXMappingLabelSelector.Init()
    XXXMappingLabelSelectorRequirement.Init()
    XXXMappingLifecycle.Init()
    XXXMappingLifecycleHandler.Init()
    XXXMappingLocalObjectReference.Init()
    XXXMappingManagedFieldsEntry.Init()
    XXXMappingNFSVolumeSource.Init()
    XXXMappingNodeAffinity.Init()
    XXXMappingNodeSelector.Init()
    XXXMappingNodeSelectorRequirement.Init()
    XXXMappingNodeSelectorTerm.Init()
    XXXMappingObjectFieldSelector.Init()
    XXXMappingObjectMeta.Init()
    XXXMappingOwnerReference.Init()
    XXXMappingPersistentVolumeClaimSpec.Init()
    XXXMappingPersistentVolumeClaimTemplate.Init()
    XXXMappingPersistentVolumeClaimVolumeSource.Init()
    XXXMappingPod.Init()
    XXXMappingPodAffinity.Init()
    XXXMappingPodAffinityTerm.Init()
    XXXMappingPodAntiAffinity.Init()
    XXXMappingPodCondition.Init()
    XXXMappingPodDNSConfig.Init()
    XXXMappingPodDNSConfigOption.Init()
    XXXMappingPodIP.Init()
    XXXMappingPodOS.Init()
    XXXMappingPodReadinessGate.Init()
    XXXMappingPodResourceClaim.Init()
    XXXMappingPodResourceClaimStatus.Init()
    XXXMappingPodSchedulingGate.Init()
    XXXMappingPodSecurityContext.Init()
    XXXMappingPodSpec.Init()
    XXXMappingPodStatus.Init()
    XXXMappingPreferredSchedulingTerm.Init()
    XXXMappingProbe.Init()
    XXXMappingProbeHandler.Init()
    XXXMappingProjectedVolumeSource.Init()
    XXXMappingResourceClaim.Init()
    XXXMappingResourceFieldSelector.Init()
    XXXMappingResourceRequirements.Init()
    XXXMappingSELinuxOptions.Init()
    XXXMappingSeccompProfile.Init()
    XXXMappingSecretEnvSource.Init()
    XXXMappingSecretKeySelector.Init()
    XXXMappingSecretProjection.Init()
    XXXMappingSecretVolumeSource.Init()
    XXXMappingSecurityContext.Init()
    XXXMappingServiceAccountTokenProjection.Init()
    XXXMappingSleepAction.Init()
    XXXMappingSysctl.Init()
    XXXMappingTCPSocketAction.Init()
    XXXMappingTime.Init()
    XXXMappingToleration.Init()
    XXXMappingTopologySpreadConstraint.Init()
    XXXMappingTypeMeta.Init()
    XXXMappingTypedLocalObjectReference.Init()
    XXXMappingTypedObjectReference.Init()
    XXXMappingVolume.Init()
    XXXMappingVolumeDevice.Init()
    XXXMappingVolumeMount.Init()
    XXXMappingVolumeMountStatus.Init()
    XXXMappingVolumeProjection.Init()
    XXXMappingVolumeSource.Init()
    XXXMappingWeightedPodAffinityTerm.Init()
    XXXMappingWindowsSecurityContextOptions.Init()
}




var XXXEnumGroupAppArmorProfileType = reflect.XXXEnumGroupImpl{
    GroupName: "AppArmorProfileType",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "AppArmorProfileTypeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "AppArmorProfileTypeUnconfined",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "AppArmorProfileTypeRuntimeDefault",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "AppArmorProfileTypeLocalhost",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupConditionStatus = reflect.XXXEnumGroupImpl{
    GroupName: "ConditionStatus",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ConditionStatusUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ConditionStatusTrue",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ConditionStatusFalse",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ConditionStatusUnknown",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupContainerRestartPolicy = reflect.XXXEnumGroupImpl{
    GroupName: "ContainerRestartPolicy",
    GroupLen: 2,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ContainerRestartPolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ContainerRestartPolicyAlways",
            EnumNumber: 1,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupDNSPolicy = reflect.XXXEnumGroupImpl{
    GroupName: "DNSPolicy",
    GroupLen: 5,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "DNSPolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "DNSPolicyClusterFirstWithHostNet",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "DNSPolicyClusterFirst",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "DNSPolicyDefault",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "DNSPolicyNone",
            EnumNumber: 4,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupHostPathType = reflect.XXXEnumGroupImpl{
    GroupName: "HostPathType",
    GroupLen: 8,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "HostPathTypeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "HostPathTypeDirectoryOrCreate",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "HostPathTypeDirectory",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "HostPathTypeFileOrCreate",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "HostPathTypeFile",
            EnumNumber: 4,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "HostPathTypeSocket",
            EnumNumber: 5,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "HostPathTypeCharDevice",
            EnumNumber: 6,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "HostPathTypeBlockDevice",
            EnumNumber: 7,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupLabelSelectorOperator = reflect.XXXEnumGroupImpl{
    GroupName: "LabelSelectorOperator",
    GroupLen: 5,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "LabelSelectorOperatorUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "LabelSelectorOperatorIn",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "LabelSelectorOperatorNotIn",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "LabelSelectorOperatorExists",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "LabelSelectorOperatorDoesNotExist",
            EnumNumber: 4,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupMountPropagationMode = reflect.XXXEnumGroupImpl{
    GroupName: "MountPropagationMode",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "MountPropagationModeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "MountPropagationModeNone",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "MountPropagationModeHostToContainer",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "MountPropagationModeBidirectional",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupNodeInclusionPolicy = reflect.XXXEnumGroupImpl{
    GroupName: "NodeInclusionPolicy",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeInclusionPolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeInclusionPolicyIgnore",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeInclusionPolicyHonor",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupNodeSelectorOperator = reflect.XXXEnumGroupImpl{
    GroupName: "NodeSelectorOperator",
    GroupLen: 7,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeSelectorOperatorUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeSelectorOperatorIn",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeSelectorOperatorNotIn",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeSelectorOperatorExists",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeSelectorOperatorDoesNotExist",
            EnumNumber: 4,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeSelectorOperatorGt",
            EnumNumber: 5,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "NodeSelectorOperatorLt",
            EnumNumber: 6,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPersistentVolumeAccessMode = reflect.XXXEnumGroupImpl{
    GroupName: "PersistentVolumeAccessMode",
    GroupLen: 5,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PersistentVolumeAccessModeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PersistentVolumeAccessModeReadWriteOnce",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PersistentVolumeAccessModeReadOnlyMany",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PersistentVolumeAccessModeReadWriteMany",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PersistentVolumeAccessModeReadWriteOncePod",
            EnumNumber: 4,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPersistentVolumeMode = reflect.XXXEnumGroupImpl{
    GroupName: "PersistentVolumeMode",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PersistentVolumeModeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PersistentVolumeModeBlock",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PersistentVolumeModeFilesystem",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPodConditionType = reflect.XXXEnumGroupImpl{
    GroupName: "PodConditionType",
    GroupLen: 7,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodConditionTypeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodConditionTypeContainersReady",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodConditionTypeInitialized",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodConditionTypeReady",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodConditionTypePodScheduled",
            EnumNumber: 4,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodConditionTypeDisruptionTarget",
            EnumNumber: 5,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodConditionTypePodReadyToStartContainers",
            EnumNumber: 6,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPodFSGroupChangePolicy = reflect.XXXEnumGroupImpl{
    GroupName: "PodFSGroupChangePolicy",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodFSGroupChangePolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodFSGroupChangePolicyOnRootMismatch",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodFSGroupChangePolicyAlways",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPodPhase = reflect.XXXEnumGroupImpl{
    GroupName: "PodPhase",
    GroupLen: 6,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodPhaseUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodPhasePending",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodPhaseRunning",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodPhaseSucceeded",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodPhaseFailed",
            EnumNumber: 4,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodPhaseUnknown",
            EnumNumber: 5,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPodQOSClass = reflect.XXXEnumGroupImpl{
    GroupName: "PodQOSClass",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodQOSClassUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodQOSClassGuaranteed",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodQOSClassBurstable",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodQOSClassBestEffort",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPodResizeStatus = reflect.XXXEnumGroupImpl{
    GroupName: "PodResizeStatus",
    GroupLen: 5,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodResizeStatusUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodResizeStatusProposed",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodResizeStatusInProgress",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodResizeStatusDeferred",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodResizeStatusInfeasible",
            EnumNumber: 4,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPodSELinuxChangePolicy = reflect.XXXEnumGroupImpl{
    GroupName: "PodSELinuxChangePolicy",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodSELinuxChangePolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodSELinuxChangePolicyRecursive",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PodSELinuxChangePolicyMountOption",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPreemptionPolicy = reflect.XXXEnumGroupImpl{
    GroupName: "PreemptionPolicy",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PreemptionPolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PreemptionPolicyPreemptLowerPriority",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PreemptionPolicyNever",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupProcMountType = reflect.XXXEnumGroupImpl{
    GroupName: "ProcMountType",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ProcMountTypeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ProcMountTypeDefault",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ProcMountTypeUnmasked",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupProtocol = reflect.XXXEnumGroupImpl{
    GroupName: "Protocol",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ProtocolUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ProtocolTcp",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ProtocolUdp",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ProtocolSctp",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupPullPolicy = reflect.XXXEnumGroupImpl{
    GroupName: "PullPolicy",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PullPolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PullPolicyAlways",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PullPolicyNever",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "PullPolicyIfNotPresent",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupRecursiveReadOnlyMode = reflect.XXXEnumGroupImpl{
    GroupName: "RecursiveReadOnlyMode",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RecursiveReadOnlyModeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RecursiveReadOnlyModeDisabled",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RecursiveReadOnlyModeIfPossible",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RecursiveReadOnlyModeEnabled",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupResourceResizeRestartPolicy = reflect.XXXEnumGroupImpl{
    GroupName: "ResourceResizeRestartPolicy",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ResourceResizeRestartPolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ResourceResizeRestartPolicyNotRequired",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "ResourceResizeRestartPolicyRestartContainer",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupRestartPolicy = reflect.XXXEnumGroupImpl{
    GroupName: "RestartPolicy",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RestartPolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RestartPolicyAlways",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RestartPolicyOnFailure",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "RestartPolicyNever",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupSeccompProfileType = reflect.XXXEnumGroupImpl{
    GroupName: "SeccompProfileType",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "SeccompProfileTypeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "SeccompProfileTypeUnconfined",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "SeccompProfileTypeRuntimeDefault",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "SeccompProfileTypeLocalhost",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupStorageMedium = reflect.XXXEnumGroupImpl{
    GroupName: "StorageMedium",
    GroupLen: 6,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "StorageMediumUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "StorageMediumDefault",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "StorageMediumMemory",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "StorageMediumHugePages",
            EnumNumber: 3,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "StorageMediumHugePages2Mi",
            EnumNumber: 4,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "StorageMediumHugePages1Gi",
            EnumNumber: 5,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupSupplementalGroupsPolicy = reflect.XXXEnumGroupImpl{
    GroupName: "SupplementalGroupsPolicy",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "SupplementalGroupsPolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "SupplementalGroupsPolicyMerge",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "SupplementalGroupsPolicyStrict",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupTaintEffect = reflect.XXXEnumGroupImpl{
    GroupName: "TaintEffect",
    GroupLen: 4,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TaintEffectUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TaintEffectNoSchedule",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TaintEffectPreferNoSchedule",
            EnumNumber: 2,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TaintEffectNoExecute",
            EnumNumber: 3,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupTerminationMessagePolicy = reflect.XXXEnumGroupImpl{
    GroupName: "TerminationMessagePolicy",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TerminationMessagePolicyUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TerminationMessagePolicyFile",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TerminationMessagePolicyFallbackToLogsOnError",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupTolerationOperator = reflect.XXXEnumGroupImpl{
    GroupName: "TolerationOperator",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TolerationOperatorUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TolerationOperatorExists",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "TolerationOperatorEqual",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupURIScheme = reflect.XXXEnumGroupImpl{
    GroupName: "URIScheme",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "URISchemeUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "URISchemeHttp",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "URISchemeHttps",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

var XXXEnumGroupUnsatisfiableConstraintAction = reflect.XXXEnumGroupImpl{
    GroupName: "UnsatisfiableConstraintAction",
    GroupLen: 3,
    EnumSize: 8,
    Descrs: []reflect.EnumValueDescr{
        reflect.XXXEnumValueDescrImpl{
            EnumName: "UnsatisfiableConstraintActionUnspecified",
            EnumNumber: 0,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "UnsatisfiableConstraintActionDoNotSchedule",
            EnumNumber: 1,
            EnumSize: 8,
        },
        reflect.XXXEnumValueDescrImpl{
            EnumName: "UnsatisfiableConstraintActionScheduleAnyway",
            EnumNumber: 2,
            EnumSize: 8,
        },
    },
}

// Deprecated: Not deprecated, but shouldn't be used directly or show up in documentation.
var XXXEnumGroups reflect.EnumGroups = reflect.XXXEnumGroupsImpl{
    List:   []reflect.EnumGroup{
        XXXEnumGroupAppArmorProfileType,
        XXXEnumGroupConditionStatus,
        XXXEnumGroupContainerRestartPolicy,
        XXXEnumGroupDNSPolicy,
        XXXEnumGroupHostPathType,
        XXXEnumGroupLabelSelectorOperator,
        XXXEnumGroupMountPropagationMode,
        XXXEnumGroupNodeInclusionPolicy,
        XXXEnumGroupNodeSelectorOperator,
        XXXEnumGroupPersistentVolumeAccessMode,
        XXXEnumGroupPersistentVolumeMode,
        XXXEnumGroupPodConditionType,
        XXXEnumGroupPodFSGroupChangePolicy,
        XXXEnumGroupPodPhase,
        XXXEnumGroupPodQOSClass,
        XXXEnumGroupPodResizeStatus,
        XXXEnumGroupPodSELinuxChangePolicy,
        XXXEnumGroupPreemptionPolicy,
        XXXEnumGroupProcMountType,
        XXXEnumGroupProtocol,
        XXXEnumGroupPullPolicy,
        XXXEnumGroupRecursiveReadOnlyMode,
        XXXEnumGroupResourceResizeRestartPolicy,
        XXXEnumGroupRestartPolicy,
        XXXEnumGroupSeccompProfileType,
        XXXEnumGroupStorageMedium,
        XXXEnumGroupSupplementalGroupsPolicy,
        XXXEnumGroupTaintEffect,
        XXXEnumGroupTerminationMessagePolicy,
        XXXEnumGroupTolerationOperator,
        XXXEnumGroupURIScheme,
        XXXEnumGroupUnsatisfiableConstraintAction,
    },
    Lookup: map[string]reflect.EnumGroup{
        "AppArmorProfileType": XXXEnumGroupAppArmorProfileType,
        "ConditionStatus": XXXEnumGroupConditionStatus,
        "ContainerRestartPolicy": XXXEnumGroupContainerRestartPolicy,
        "DNSPolicy": XXXEnumGroupDNSPolicy,
        "HostPathType": XXXEnumGroupHostPathType,
        "LabelSelectorOperator": XXXEnumGroupLabelSelectorOperator,
        "MountPropagationMode": XXXEnumGroupMountPropagationMode,
        "NodeInclusionPolicy": XXXEnumGroupNodeInclusionPolicy,
        "NodeSelectorOperator": XXXEnumGroupNodeSelectorOperator,
        "PersistentVolumeAccessMode": XXXEnumGroupPersistentVolumeAccessMode,
        "PersistentVolumeMode": XXXEnumGroupPersistentVolumeMode,
        "PodConditionType": XXXEnumGroupPodConditionType,
        "PodFSGroupChangePolicy": XXXEnumGroupPodFSGroupChangePolicy,
        "PodPhase": XXXEnumGroupPodPhase,
        "PodQOSClass": XXXEnumGroupPodQOSClass,
        "PodResizeStatus": XXXEnumGroupPodResizeStatus,
        "PodSELinuxChangePolicy": XXXEnumGroupPodSELinuxChangePolicy,
        "PreemptionPolicy": XXXEnumGroupPreemptionPolicy,
        "ProcMountType": XXXEnumGroupProcMountType,
        "Protocol": XXXEnumGroupProtocol,
        "PullPolicy": XXXEnumGroupPullPolicy,
        "RecursiveReadOnlyMode": XXXEnumGroupRecursiveReadOnlyMode,
        "ResourceResizeRestartPolicy": XXXEnumGroupResourceResizeRestartPolicy,
        "RestartPolicy": XXXEnumGroupRestartPolicy,
        "SeccompProfileType": XXXEnumGroupSeccompProfileType,
        "StorageMedium": XXXEnumGroupStorageMedium,
        "SupplementalGroupsPolicy": XXXEnumGroupSupplementalGroupsPolicy,
        "TaintEffect": XXXEnumGroupTaintEffect,
        "TerminationMessagePolicy": XXXEnumGroupTerminationMessagePolicy,
        "TolerationOperator": XXXEnumGroupTolerationOperator,
        "URIScheme": XXXEnumGroupURIScheme,
        "UnsatisfiableConstraintAction": XXXEnumGroupUnsatisfiableConstraintAction,
    },
}
 


var XXXStructDescrAWSElasticBlockStoreVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "AWSElasticBlockStoreVolumeSource",
    Pkg:       XXXMappingAWSElasticBlockStoreVolumeSource.Pkg,
    Path:      XXXMappingAWSElasticBlockStoreVolumeSource.Path,
    Mapping:   XXXMappingAWSElasticBlockStoreVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAWSElasticBlockStoreVolumeSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAWSElasticBlockStoreVolumeSource.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAWSElasticBlockStoreVolumeSource.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAWSElasticBlockStoreVolumeSource.Fields[3],  
        },  
    },
}

var XXXStructDescrAffinity = &reflect.XXXStructDescrImpl{
    Name:      "Affinity",
    Pkg:       XXXMappingAffinity.Pkg,
    Path:      XXXMappingAffinity.Path,
    Mapping:   XXXMappingAffinity,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAffinity.Fields[0],
            SD: XXXStructDescrNodeAffinity,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAffinity.Fields[1],
            SD: XXXStructDescrPodAffinity,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAffinity.Fields[2],
            SD: XXXStructDescrPodAntiAffinity,  
        },  
    },
}

var XXXStructDescrAppArmorProfile = &reflect.XXXStructDescrImpl{
    Name:      "AppArmorProfile",
    Pkg:       XXXMappingAppArmorProfile.Pkg,
    Path:      XXXMappingAppArmorProfile.Path,
    Mapping:   XXXMappingAppArmorProfile,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAppArmorProfile.Fields[0],
            EG: XXXEnumGroupAppArmorProfileType, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingAppArmorProfile.Fields[1],  
        },  
    },
}

var XXXStructDescrCSIVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "CSIVolumeSource",
    Pkg:       XXXMappingCSIVolumeSource.Pkg,
    Path:      XXXMappingCSIVolumeSource.Path,
    Mapping:   XXXMappingCSIVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCSIVolumeSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCSIVolumeSource.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCSIVolumeSource.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCSIVolumeSource.Fields[3],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCSIVolumeSource.Fields[4],
            SD: XXXStructDescrLocalObjectReference,  
        },  
    },
}

var XXXStructDescrCapabilities = &reflect.XXXStructDescrImpl{
    Name:      "Capabilities",
    Pkg:       XXXMappingCapabilities.Pkg,
    Path:      XXXMappingCapabilities.Path,
    Mapping:   XXXMappingCapabilities,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCapabilities.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingCapabilities.Fields[1],  
        },  
    },
}

var XXXStructDescrClusterTrustBundleProjection = &reflect.XXXStructDescrImpl{
    Name:      "ClusterTrustBundleProjection",
    Pkg:       XXXMappingClusterTrustBundleProjection.Pkg,
    Path:      XXXMappingClusterTrustBundleProjection.Path,
    Mapping:   XXXMappingClusterTrustBundleProjection,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClusterTrustBundleProjection.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClusterTrustBundleProjection.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClusterTrustBundleProjection.Fields[2],
            SD: XXXStructDescrLabelSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClusterTrustBundleProjection.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingClusterTrustBundleProjection.Fields[4],  
        },  
    },
}

var XXXStructDescrConfigMapEnvSource = &reflect.XXXStructDescrImpl{
    Name:      "ConfigMapEnvSource",
    Pkg:       XXXMappingConfigMapEnvSource.Pkg,
    Path:      XXXMappingConfigMapEnvSource.Path,
    Mapping:   XXXMappingConfigMapEnvSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapEnvSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapEnvSource.Fields[1],  
        },  
    },
}

var XXXStructDescrConfigMapKeySelector = &reflect.XXXStructDescrImpl{
    Name:      "ConfigMapKeySelector",
    Pkg:       XXXMappingConfigMapKeySelector.Pkg,
    Path:      XXXMappingConfigMapKeySelector.Path,
    Mapping:   XXXMappingConfigMapKeySelector,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapKeySelector.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapKeySelector.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapKeySelector.Fields[2],  
        },  
    },
}

var XXXStructDescrConfigMapProjection = &reflect.XXXStructDescrImpl{
    Name:      "ConfigMapProjection",
    Pkg:       XXXMappingConfigMapProjection.Pkg,
    Path:      XXXMappingConfigMapProjection.Path,
    Mapping:   XXXMappingConfigMapProjection,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapProjection.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapProjection.Fields[1],
            SD: XXXStructDescrKeyToPath,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapProjection.Fields[2],  
        },  
    },
}

var XXXStructDescrConfigMapVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "ConfigMapVolumeSource",
    Pkg:       XXXMappingConfigMapVolumeSource.Pkg,
    Path:      XXXMappingConfigMapVolumeSource.Path,
    Mapping:   XXXMappingConfigMapVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapVolumeSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapVolumeSource.Fields[1],
            SD: XXXStructDescrKeyToPath,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapVolumeSource.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingConfigMapVolumeSource.Fields[3],  
        },  
    },
}

var XXXStructDescrContainer = &reflect.XXXStructDescrImpl{
    Name:      "Container",
    Pkg:       XXXMappingContainer.Pkg,
    Path:      XXXMappingContainer.Path,
    Mapping:   XXXMappingContainer,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[5],
            SD: XXXStructDescrContainerPort,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[6],
            SD: XXXStructDescrEnvFromSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[7],
            SD: XXXStructDescrEnvVar,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[8],
            SD: XXXStructDescrResourceRequirements,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[9],
            SD: XXXStructDescrContainerResizePolicy,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[10],
            EG: XXXEnumGroupContainerRestartPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[11],
            SD: XXXStructDescrVolumeMount,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[12],
            SD: XXXStructDescrVolumeDevice,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[13],
            SD: XXXStructDescrProbe,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[14],
            SD: XXXStructDescrProbe,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[15],
            SD: XXXStructDescrProbe,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[16],
            SD: XXXStructDescrLifecycle,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[17],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[18],
            EG: XXXEnumGroupTerminationMessagePolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[19],
            EG: XXXEnumGroupPullPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[20],
            SD: XXXStructDescrSecurityContext,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[21],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[22],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainer.Fields[23],  
        },  
    },
}

var XXXStructDescrContainerPort = &reflect.XXXStructDescrImpl{
    Name:      "ContainerPort",
    Pkg:       XXXMappingContainerPort.Pkg,
    Path:      XXXMappingContainerPort.Path,
    Mapping:   XXXMappingContainerPort,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerPort.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerPort.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerPort.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerPort.Fields[3],
            EG: XXXEnumGroupProtocol, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerPort.Fields[4],  
        },  
    },
}

var XXXStructDescrContainerResizePolicy = &reflect.XXXStructDescrImpl{
    Name:      "ContainerResizePolicy",
    Pkg:       XXXMappingContainerResizePolicy.Pkg,
    Path:      XXXMappingContainerResizePolicy.Path,
    Mapping:   XXXMappingContainerResizePolicy,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerResizePolicy.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerResizePolicy.Fields[1],
            EG: XXXEnumGroupResourceResizeRestartPolicy, 
        },  
    },
}

var XXXStructDescrContainerState = &reflect.XXXStructDescrImpl{
    Name:      "ContainerState",
    Pkg:       XXXMappingContainerState.Pkg,
    Path:      XXXMappingContainerState.Path,
    Mapping:   XXXMappingContainerState,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerState.Fields[0],
            SD: XXXStructDescrContainerStateWaiting,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerState.Fields[1],
            SD: XXXStructDescrContainerStateRunning,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerState.Fields[2],
            SD: XXXStructDescrContainerStateTerminated,  
        },  
    },
}

var XXXStructDescrContainerStateRunning = &reflect.XXXStructDescrImpl{
    Name:      "ContainerStateRunning",
    Pkg:       XXXMappingContainerStateRunning.Pkg,
    Path:      XXXMappingContainerStateRunning.Path,
    Mapping:   XXXMappingContainerStateRunning,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateRunning.Fields[0],
            SD: XXXStructDescrTime,  
        },  
    },
}

var XXXStructDescrContainerStateTerminated = &reflect.XXXStructDescrImpl{
    Name:      "ContainerStateTerminated",
    Pkg:       XXXMappingContainerStateTerminated.Pkg,
    Path:      XXXMappingContainerStateTerminated.Path,
    Mapping:   XXXMappingContainerStateTerminated,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateTerminated.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateTerminated.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateTerminated.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateTerminated.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateTerminated.Fields[4],
            SD: XXXStructDescrTime,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateTerminated.Fields[5],
            SD: XXXStructDescrTime,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateTerminated.Fields[6],  
        },  
    },
}

var XXXStructDescrContainerStateWaiting = &reflect.XXXStructDescrImpl{
    Name:      "ContainerStateWaiting",
    Pkg:       XXXMappingContainerStateWaiting.Pkg,
    Path:      XXXMappingContainerStateWaiting.Path,
    Mapping:   XXXMappingContainerStateWaiting,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateWaiting.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStateWaiting.Fields[1],  
        },  
    },
}

var XXXStructDescrContainerStatus = &reflect.XXXStructDescrImpl{
    Name:      "ContainerStatus",
    Pkg:       XXXMappingContainerStatus.Pkg,
    Path:      XXXMappingContainerStatus.Path,
    Mapping:   XXXMappingContainerStatus,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[1],
            SD: XXXStructDescrContainerState,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[2],
            SD: XXXStructDescrContainerState,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[6],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[7],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[8],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[9],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[10],
            SD: XXXStructDescrResourceRequirements,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingContainerStatus.Fields[11],
            SD: XXXStructDescrVolumeMountStatus,  
        },  
    },
}

var XXXStructDescrDownwardAPIProjection = &reflect.XXXStructDescrImpl{
    Name:      "DownwardAPIProjection",
    Pkg:       XXXMappingDownwardAPIProjection.Pkg,
    Path:      XXXMappingDownwardAPIProjection.Path,
    Mapping:   XXXMappingDownwardAPIProjection,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDownwardAPIProjection.Fields[0],
            SD: XXXStructDescrDownwardAPIVolumeFile,  
        },  
    },
}

var XXXStructDescrDownwardAPIVolumeFile = &reflect.XXXStructDescrImpl{
    Name:      "DownwardAPIVolumeFile",
    Pkg:       XXXMappingDownwardAPIVolumeFile.Pkg,
    Path:      XXXMappingDownwardAPIVolumeFile.Path,
    Mapping:   XXXMappingDownwardAPIVolumeFile,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDownwardAPIVolumeFile.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDownwardAPIVolumeFile.Fields[1],
            SD: XXXStructDescrObjectFieldSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDownwardAPIVolumeFile.Fields[2],
            SD: XXXStructDescrResourceFieldSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDownwardAPIVolumeFile.Fields[3],  
        },  
    },
}

var XXXStructDescrDownwardAPIVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "DownwardAPIVolumeSource",
    Pkg:       XXXMappingDownwardAPIVolumeSource.Pkg,
    Path:      XXXMappingDownwardAPIVolumeSource.Path,
    Mapping:   XXXMappingDownwardAPIVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDownwardAPIVolumeSource.Fields[0],
            SD: XXXStructDescrDownwardAPIVolumeFile,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingDownwardAPIVolumeSource.Fields[1],  
        },  
    },
}

var XXXStructDescrEmptyDirVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "EmptyDirVolumeSource",
    Pkg:       XXXMappingEmptyDirVolumeSource.Pkg,
    Path:      XXXMappingEmptyDirVolumeSource.Path,
    Mapping:   XXXMappingEmptyDirVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEmptyDirVolumeSource.Fields[0],
            EG: XXXEnumGroupStorageMedium, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEmptyDirVolumeSource.Fields[1],  
        },  
    },
}

var XXXStructDescrEnvFromSource = &reflect.XXXStructDescrImpl{
    Name:      "EnvFromSource",
    Pkg:       XXXMappingEnvFromSource.Pkg,
    Path:      XXXMappingEnvFromSource.Path,
    Mapping:   XXXMappingEnvFromSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvFromSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvFromSource.Fields[1],
            SD: XXXStructDescrConfigMapEnvSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvFromSource.Fields[2],
            SD: XXXStructDescrSecretEnvSource,  
        },  
    },
}

var XXXStructDescrEnvVar = &reflect.XXXStructDescrImpl{
    Name:      "EnvVar",
    Pkg:       XXXMappingEnvVar.Pkg,
    Path:      XXXMappingEnvVar.Path,
    Mapping:   XXXMappingEnvVar,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvVar.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvVar.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvVar.Fields[2],
            SD: XXXStructDescrEnvVarSource,  
        },  
    },
}

var XXXStructDescrEnvVarSource = &reflect.XXXStructDescrImpl{
    Name:      "EnvVarSource",
    Pkg:       XXXMappingEnvVarSource.Pkg,
    Path:      XXXMappingEnvVarSource.Path,
    Mapping:   XXXMappingEnvVarSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvVarSource.Fields[0],
            SD: XXXStructDescrObjectFieldSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvVarSource.Fields[1],
            SD: XXXStructDescrResourceFieldSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvVarSource.Fields[2],
            SD: XXXStructDescrConfigMapKeySelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEnvVarSource.Fields[3],
            SD: XXXStructDescrSecretKeySelector,  
        },  
    },
}

var XXXStructDescrEphemeralContainer = &reflect.XXXStructDescrImpl{
    Name:      "EphemeralContainer",
    Pkg:       XXXMappingEphemeralContainer.Pkg,
    Path:      XXXMappingEphemeralContainer.Path,
    Mapping:   XXXMappingEphemeralContainer,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[5],
            SD: XXXStructDescrContainerPort,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[6],
            SD: XXXStructDescrEnvFromSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[7],
            SD: XXXStructDescrEnvVar,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[8],
            SD: XXXStructDescrResourceRequirements,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[9],
            SD: XXXStructDescrVolumeMount,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[10],
            SD: XXXStructDescrVolumeDevice,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[11],
            SD: XXXStructDescrProbe,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[12],
            SD: XXXStructDescrProbe,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[13],
            SD: XXXStructDescrProbe,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[14],
            SD: XXXStructDescrLifecycle,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[15],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[16],
            EG: XXXEnumGroupTerminationMessagePolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[17],
            EG: XXXEnumGroupPullPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[18],
            SD: XXXStructDescrSecurityContext,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[19],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[20],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[21],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralContainer.Fields[22],  
        },  
    },
}

var XXXStructDescrEphemeralVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "EphemeralVolumeSource",
    Pkg:       XXXMappingEphemeralVolumeSource.Pkg,
    Path:      XXXMappingEphemeralVolumeSource.Path,
    Mapping:   XXXMappingEphemeralVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingEphemeralVolumeSource.Fields[0],
            SD: XXXStructDescrPersistentVolumeClaimTemplate,  
        },  
    },
}

var XXXStructDescrExecAction = &reflect.XXXStructDescrImpl{
    Name:      "ExecAction",
    Pkg:       XXXMappingExecAction.Pkg,
    Path:      XXXMappingExecAction.Path,
    Mapping:   XXXMappingExecAction,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingExecAction.Fields[0],  
        },  
    },
}

var XXXStructDescrGCEPersistentDiskVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "GCEPersistentDiskVolumeSource",
    Pkg:       XXXMappingGCEPersistentDiskVolumeSource.Pkg,
    Path:      XXXMappingGCEPersistentDiskVolumeSource.Path,
    Mapping:   XXXMappingGCEPersistentDiskVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGCEPersistentDiskVolumeSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGCEPersistentDiskVolumeSource.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGCEPersistentDiskVolumeSource.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGCEPersistentDiskVolumeSource.Fields[3],  
        },  
    },
}

var XXXStructDescrGRPCAction = &reflect.XXXStructDescrImpl{
    Name:      "GRPCAction",
    Pkg:       XXXMappingGRPCAction.Pkg,
    Path:      XXXMappingGRPCAction.Path,
    Mapping:   XXXMappingGRPCAction,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGRPCAction.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingGRPCAction.Fields[1],  
        },  
    },
}

var XXXStructDescrHTTPGetAction = &reflect.XXXStructDescrImpl{
    Name:      "HTTPGetAction",
    Pkg:       XXXMappingHTTPGetAction.Pkg,
    Path:      XXXMappingHTTPGetAction.Path,
    Mapping:   XXXMappingHTTPGetAction,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHTTPGetAction.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHTTPGetAction.Fields[1],
            SD: XXXStructDescrIntOrString,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHTTPGetAction.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHTTPGetAction.Fields[3],
            EG: XXXEnumGroupURIScheme, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHTTPGetAction.Fields[4],
            SD: XXXStructDescrHTTPHeader,  
        },  
    },
}

var XXXStructDescrHTTPHeader = &reflect.XXXStructDescrImpl{
    Name:      "HTTPHeader",
    Pkg:       XXXMappingHTTPHeader.Pkg,
    Path:      XXXMappingHTTPHeader.Path,
    Mapping:   XXXMappingHTTPHeader,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHTTPHeader.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHTTPHeader.Fields[1],  
        },  
    },
}

var XXXStructDescrHostAlias = &reflect.XXXStructDescrImpl{
    Name:      "HostAlias",
    Pkg:       XXXMappingHostAlias.Pkg,
    Path:      XXXMappingHostAlias.Path,
    Mapping:   XXXMappingHostAlias,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHostAlias.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHostAlias.Fields[1],  
        },  
    },
}

var XXXStructDescrHostIP = &reflect.XXXStructDescrImpl{
    Name:      "HostIP",
    Pkg:       XXXMappingHostIP.Pkg,
    Path:      XXXMappingHostIP.Path,
    Mapping:   XXXMappingHostIP,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHostIP.Fields[0],  
        },  
    },
}

var XXXStructDescrHostPathVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "HostPathVolumeSource",
    Pkg:       XXXMappingHostPathVolumeSource.Pkg,
    Path:      XXXMappingHostPathVolumeSource.Path,
    Mapping:   XXXMappingHostPathVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHostPathVolumeSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingHostPathVolumeSource.Fields[1],
            EG: XXXEnumGroupHostPathType, 
        },  
    },
}

var XXXStructDescrIntOrString = &reflect.XXXStructDescrImpl{
    Name:      "IntOrString",
    Pkg:       XXXMappingIntOrString.Pkg,
    Path:      XXXMappingIntOrString.Path,
    Mapping:   XXXMappingIntOrString,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingIntOrString.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingIntOrString.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingIntOrString.Fields[2],  
        },  
    },
}

var XXXStructDescrKeyToPath = &reflect.XXXStructDescrImpl{
    Name:      "KeyToPath",
    Pkg:       XXXMappingKeyToPath.Pkg,
    Path:      XXXMappingKeyToPath.Path,
    Mapping:   XXXMappingKeyToPath,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingKeyToPath.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingKeyToPath.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingKeyToPath.Fields[2],  
        },  
    },
}

var XXXStructDescrKeyValue = &reflect.XXXStructDescrImpl{
    Name:      "KeyValue",
    Pkg:       XXXMappingKeyValue.Pkg,
    Path:      XXXMappingKeyValue.Path,
    Mapping:   XXXMappingKeyValue,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingKeyValue.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingKeyValue.Fields[1],  
        },  
    },
}

var XXXStructDescrLabelSelector = &reflect.XXXStructDescrImpl{
    Name:      "LabelSelector",
    Pkg:       XXXMappingLabelSelector.Pkg,
    Path:      XXXMappingLabelSelector.Path,
    Mapping:   XXXMappingLabelSelector,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLabelSelector.Fields[0],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLabelSelector.Fields[1],
            SD: XXXStructDescrLabelSelectorRequirement,  
        },  
    },
}

var XXXStructDescrLabelSelectorRequirement = &reflect.XXXStructDescrImpl{
    Name:      "LabelSelectorRequirement",
    Pkg:       XXXMappingLabelSelectorRequirement.Pkg,
    Path:      XXXMappingLabelSelectorRequirement.Path,
    Mapping:   XXXMappingLabelSelectorRequirement,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLabelSelectorRequirement.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLabelSelectorRequirement.Fields[1],
            EG: XXXEnumGroupLabelSelectorOperator, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLabelSelectorRequirement.Fields[2],  
        },  
    },
}

var XXXStructDescrLifecycle = &reflect.XXXStructDescrImpl{
    Name:      "Lifecycle",
    Pkg:       XXXMappingLifecycle.Pkg,
    Path:      XXXMappingLifecycle.Path,
    Mapping:   XXXMappingLifecycle,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLifecycle.Fields[0],
            SD: XXXStructDescrLifecycleHandler,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLifecycle.Fields[1],
            SD: XXXStructDescrLifecycleHandler,  
        },  
    },
}

var XXXStructDescrLifecycleHandler = &reflect.XXXStructDescrImpl{
    Name:      "LifecycleHandler",
    Pkg:       XXXMappingLifecycleHandler.Pkg,
    Path:      XXXMappingLifecycleHandler.Path,
    Mapping:   XXXMappingLifecycleHandler,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLifecycleHandler.Fields[0],
            SD: XXXStructDescrExecAction,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLifecycleHandler.Fields[1],
            SD: XXXStructDescrHTTPGetAction,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLifecycleHandler.Fields[2],
            SD: XXXStructDescrTCPSocketAction,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLifecycleHandler.Fields[3],
            SD: XXXStructDescrSleepAction,  
        },  
    },
}

var XXXStructDescrLocalObjectReference = &reflect.XXXStructDescrImpl{
    Name:      "LocalObjectReference",
    Pkg:       XXXMappingLocalObjectReference.Pkg,
    Path:      XXXMappingLocalObjectReference.Path,
    Mapping:   XXXMappingLocalObjectReference,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingLocalObjectReference.Fields[0],  
        },  
    },
}

var XXXStructDescrManagedFieldsEntry = &reflect.XXXStructDescrImpl{
    Name:      "ManagedFieldsEntry",
    Pkg:       XXXMappingManagedFieldsEntry.Pkg,
    Path:      XXXMappingManagedFieldsEntry.Path,
    Mapping:   XXXMappingManagedFieldsEntry,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingManagedFieldsEntry.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingManagedFieldsEntry.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingManagedFieldsEntry.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingManagedFieldsEntry.Fields[3],
            SD: XXXStructDescrTime,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingManagedFieldsEntry.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingManagedFieldsEntry.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingManagedFieldsEntry.Fields[6],  
        },  
    },
}

var XXXStructDescrNFSVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "NFSVolumeSource",
    Pkg:       XXXMappingNFSVolumeSource.Pkg,
    Path:      XXXMappingNFSVolumeSource.Path,
    Mapping:   XXXMappingNFSVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNFSVolumeSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNFSVolumeSource.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNFSVolumeSource.Fields[2],  
        },  
    },
}

var XXXStructDescrNodeAffinity = &reflect.XXXStructDescrImpl{
    Name:      "NodeAffinity",
    Pkg:       XXXMappingNodeAffinity.Pkg,
    Path:      XXXMappingNodeAffinity.Path,
    Mapping:   XXXMappingNodeAffinity,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNodeAffinity.Fields[0],
            SD: XXXStructDescrNodeSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNodeAffinity.Fields[1],
            SD: XXXStructDescrPreferredSchedulingTerm,  
        },  
    },
}

var XXXStructDescrNodeSelector = &reflect.XXXStructDescrImpl{
    Name:      "NodeSelector",
    Pkg:       XXXMappingNodeSelector.Pkg,
    Path:      XXXMappingNodeSelector.Path,
    Mapping:   XXXMappingNodeSelector,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNodeSelector.Fields[0],
            SD: XXXStructDescrNodeSelectorTerm,  
        },  
    },
}

var XXXStructDescrNodeSelectorRequirement = &reflect.XXXStructDescrImpl{
    Name:      "NodeSelectorRequirement",
    Pkg:       XXXMappingNodeSelectorRequirement.Pkg,
    Path:      XXXMappingNodeSelectorRequirement.Path,
    Mapping:   XXXMappingNodeSelectorRequirement,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNodeSelectorRequirement.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNodeSelectorRequirement.Fields[1],
            EG: XXXEnumGroupNodeSelectorOperator, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNodeSelectorRequirement.Fields[2],  
        },  
    },
}

var XXXStructDescrNodeSelectorTerm = &reflect.XXXStructDescrImpl{
    Name:      "NodeSelectorTerm",
    Pkg:       XXXMappingNodeSelectorTerm.Pkg,
    Path:      XXXMappingNodeSelectorTerm.Path,
    Mapping:   XXXMappingNodeSelectorTerm,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNodeSelectorTerm.Fields[0],
            SD: XXXStructDescrNodeSelectorRequirement,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingNodeSelectorTerm.Fields[1],
            SD: XXXStructDescrNodeSelectorRequirement,  
        },  
    },
}

var XXXStructDescrObjectFieldSelector = &reflect.XXXStructDescrImpl{
    Name:      "ObjectFieldSelector",
    Pkg:       XXXMappingObjectFieldSelector.Pkg,
    Path:      XXXMappingObjectFieldSelector.Path,
    Mapping:   XXXMappingObjectFieldSelector,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectFieldSelector.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectFieldSelector.Fields[1],  
        },  
    },
}

var XXXStructDescrObjectMeta = &reflect.XXXStructDescrImpl{
    Name:      "ObjectMeta",
    Pkg:       XXXMappingObjectMeta.Pkg,
    Path:      XXXMappingObjectMeta.Path,
    Mapping:   XXXMappingObjectMeta,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[6],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[7],
            SD: XXXStructDescrTime,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[8],
            SD: XXXStructDescrTime,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[9],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[10],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[11],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[12],
            SD: XXXStructDescrOwnerReference,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[13],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingObjectMeta.Fields[14],
            SD: XXXStructDescrManagedFieldsEntry,  
        },  
    },
}

var XXXStructDescrOwnerReference = &reflect.XXXStructDescrImpl{
    Name:      "OwnerReference",
    Pkg:       XXXMappingOwnerReference.Pkg,
    Path:      XXXMappingOwnerReference.Path,
    Mapping:   XXXMappingOwnerReference,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOwnerReference.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOwnerReference.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOwnerReference.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOwnerReference.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOwnerReference.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingOwnerReference.Fields[5],  
        },  
    },
}

var XXXStructDescrPersistentVolumeClaimSpec = &reflect.XXXStructDescrImpl{
    Name:      "PersistentVolumeClaimSpec",
    Pkg:       XXXMappingPersistentVolumeClaimSpec.Pkg,
    Path:      XXXMappingPersistentVolumeClaimSpec.Path,
    Mapping:   XXXMappingPersistentVolumeClaimSpec,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[0],
            EG: XXXEnumGroupPersistentVolumeAccessMode, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[1],
            SD: XXXStructDescrLabelSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[2],
            SD: XXXStructDescrResourceRequirements,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[5],
            EG: XXXEnumGroupPersistentVolumeMode, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[6],
            SD: XXXStructDescrTypedLocalObjectReference,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[7],
            SD: XXXStructDescrTypedObjectReference,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimSpec.Fields[8],  
        },  
    },
}

var XXXStructDescrPersistentVolumeClaimTemplate = &reflect.XXXStructDescrImpl{
    Name:      "PersistentVolumeClaimTemplate",
    Pkg:       XXXMappingPersistentVolumeClaimTemplate.Pkg,
    Path:      XXXMappingPersistentVolumeClaimTemplate.Path,
    Mapping:   XXXMappingPersistentVolumeClaimTemplate,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimTemplate.Fields[0],
            SD: XXXStructDescrObjectMeta,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimTemplate.Fields[1],
            SD: XXXStructDescrPersistentVolumeClaimSpec,  
        },  
    },
}

var XXXStructDescrPersistentVolumeClaimVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "PersistentVolumeClaimVolumeSource",
    Pkg:       XXXMappingPersistentVolumeClaimVolumeSource.Pkg,
    Path:      XXXMappingPersistentVolumeClaimVolumeSource.Path,
    Mapping:   XXXMappingPersistentVolumeClaimVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimVolumeSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPersistentVolumeClaimVolumeSource.Fields[1],  
        },  
    },
}

var XXXStructDescrPod = &reflect.XXXStructDescrImpl{
    Name:      "Pod",
    Pkg:       XXXMappingPod.Pkg,
    Path:      XXXMappingPod.Path,
    Mapping:   XXXMappingPod,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPod.Fields[0],
            SD: XXXStructDescrTypeMeta,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPod.Fields[1],
            SD: XXXStructDescrObjectMeta,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPod.Fields[2],
            SD: XXXStructDescrPodSpec,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPod.Fields[3],
            SD: XXXStructDescrPodStatus,  
        },  
    },
}

var XXXStructDescrPodAffinity = &reflect.XXXStructDescrImpl{
    Name:      "PodAffinity",
    Pkg:       XXXMappingPodAffinity.Pkg,
    Path:      XXXMappingPodAffinity.Path,
    Mapping:   XXXMappingPodAffinity,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAffinity.Fields[0],
            SD: XXXStructDescrPodAffinityTerm,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAffinity.Fields[1],
            SD: XXXStructDescrWeightedPodAffinityTerm,  
        },  
    },
}

var XXXStructDescrPodAffinityTerm = &reflect.XXXStructDescrImpl{
    Name:      "PodAffinityTerm",
    Pkg:       XXXMappingPodAffinityTerm.Pkg,
    Path:      XXXMappingPodAffinityTerm.Path,
    Mapping:   XXXMappingPodAffinityTerm,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAffinityTerm.Fields[0],
            SD: XXXStructDescrLabelSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAffinityTerm.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAffinityTerm.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAffinityTerm.Fields[3],
            SD: XXXStructDescrLabelSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAffinityTerm.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAffinityTerm.Fields[5],  
        },  
    },
}

var XXXStructDescrPodAntiAffinity = &reflect.XXXStructDescrImpl{
    Name:      "PodAntiAffinity",
    Pkg:       XXXMappingPodAntiAffinity.Pkg,
    Path:      XXXMappingPodAntiAffinity.Path,
    Mapping:   XXXMappingPodAntiAffinity,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAntiAffinity.Fields[0],
            SD: XXXStructDescrPodAffinityTerm,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodAntiAffinity.Fields[1],
            SD: XXXStructDescrWeightedPodAffinityTerm,  
        },  
    },
}

var XXXStructDescrPodCondition = &reflect.XXXStructDescrImpl{
    Name:      "PodCondition",
    Pkg:       XXXMappingPodCondition.Pkg,
    Path:      XXXMappingPodCondition.Path,
    Mapping:   XXXMappingPodCondition,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodCondition.Fields[0],
            EG: XXXEnumGroupPodConditionType, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodCondition.Fields[1],
            EG: XXXEnumGroupConditionStatus, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodCondition.Fields[2],
            SD: XXXStructDescrTime,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodCondition.Fields[3],
            SD: XXXStructDescrTime,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodCondition.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodCondition.Fields[5],  
        },  
    },
}

var XXXStructDescrPodDNSConfig = &reflect.XXXStructDescrImpl{
    Name:      "PodDNSConfig",
    Pkg:       XXXMappingPodDNSConfig.Pkg,
    Path:      XXXMappingPodDNSConfig.Path,
    Mapping:   XXXMappingPodDNSConfig,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodDNSConfig.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodDNSConfig.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodDNSConfig.Fields[2],
            SD: XXXStructDescrPodDNSConfigOption,  
        },  
    },
}

var XXXStructDescrPodDNSConfigOption = &reflect.XXXStructDescrImpl{
    Name:      "PodDNSConfigOption",
    Pkg:       XXXMappingPodDNSConfigOption.Pkg,
    Path:      XXXMappingPodDNSConfigOption.Path,
    Mapping:   XXXMappingPodDNSConfigOption,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodDNSConfigOption.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodDNSConfigOption.Fields[1],  
        },  
    },
}

var XXXStructDescrPodIP = &reflect.XXXStructDescrImpl{
    Name:      "PodIP",
    Pkg:       XXXMappingPodIP.Pkg,
    Path:      XXXMappingPodIP.Path,
    Mapping:   XXXMappingPodIP,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodIP.Fields[0],  
        },  
    },
}

var XXXStructDescrPodOS = &reflect.XXXStructDescrImpl{
    Name:      "PodOS",
    Pkg:       XXXMappingPodOS.Pkg,
    Path:      XXXMappingPodOS.Path,
    Mapping:   XXXMappingPodOS,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodOS.Fields[0],  
        },  
    },
}

var XXXStructDescrPodReadinessGate = &reflect.XXXStructDescrImpl{
    Name:      "PodReadinessGate",
    Pkg:       XXXMappingPodReadinessGate.Pkg,
    Path:      XXXMappingPodReadinessGate.Path,
    Mapping:   XXXMappingPodReadinessGate,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodReadinessGate.Fields[0],
            EG: XXXEnumGroupPodConditionType, 
        },  
    },
}

var XXXStructDescrPodResourceClaim = &reflect.XXXStructDescrImpl{
    Name:      "PodResourceClaim",
    Pkg:       XXXMappingPodResourceClaim.Pkg,
    Path:      XXXMappingPodResourceClaim.Path,
    Mapping:   XXXMappingPodResourceClaim,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodResourceClaim.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodResourceClaim.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodResourceClaim.Fields[2],  
        },  
    },
}

var XXXStructDescrPodResourceClaimStatus = &reflect.XXXStructDescrImpl{
    Name:      "PodResourceClaimStatus",
    Pkg:       XXXMappingPodResourceClaimStatus.Pkg,
    Path:      XXXMappingPodResourceClaimStatus.Path,
    Mapping:   XXXMappingPodResourceClaimStatus,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodResourceClaimStatus.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodResourceClaimStatus.Fields[1],  
        },  
    },
}

var XXXStructDescrPodSchedulingGate = &reflect.XXXStructDescrImpl{
    Name:      "PodSchedulingGate",
    Pkg:       XXXMappingPodSchedulingGate.Pkg,
    Path:      XXXMappingPodSchedulingGate.Path,
    Mapping:   XXXMappingPodSchedulingGate,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSchedulingGate.Fields[0],  
        },  
    },
}

var XXXStructDescrPodSecurityContext = &reflect.XXXStructDescrImpl{
    Name:      "PodSecurityContext",
    Pkg:       XXXMappingPodSecurityContext.Pkg,
    Path:      XXXMappingPodSecurityContext.Path,
    Mapping:   XXXMappingPodSecurityContext,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[0],
            SD: XXXStructDescrSELinuxOptions,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[1],
            SD: XXXStructDescrWindowsSecurityContextOptions,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[6],
            EG: XXXEnumGroupSupplementalGroupsPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[7],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[8],
            SD: XXXStructDescrSysctl,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[9],
            EG: XXXEnumGroupPodFSGroupChangePolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[10],
            SD: XXXStructDescrSeccompProfile,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[11],
            SD: XXXStructDescrAppArmorProfile,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSecurityContext.Fields[12],
            EG: XXXEnumGroupPodSELinuxChangePolicy, 
        },  
    },
}

var XXXStructDescrPodSpec = &reflect.XXXStructDescrImpl{
    Name:      "PodSpec",
    Pkg:       XXXMappingPodSpec.Pkg,
    Path:      XXXMappingPodSpec.Path,
    Mapping:   XXXMappingPodSpec,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[0],
            SD: XXXStructDescrVolume,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[1],
            SD: XXXStructDescrContainer,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[2],
            SD: XXXStructDescrContainer,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[3],
            SD: XXXStructDescrEphemeralContainer,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[4],
            EG: XXXEnumGroupRestartPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[6],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[7],
            EG: XXXEnumGroupDNSPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[8],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[9],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[10],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[11],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[12],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[13],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[14],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[15],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[16],
            SD: XXXStructDescrPodSecurityContext,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[17],
            SD: XXXStructDescrLocalObjectReference,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[18],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[19],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[20],
            SD: XXXStructDescrAffinity,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[21],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[22],
            SD: XXXStructDescrToleration,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[23],
            SD: XXXStructDescrHostAlias,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[24],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[25],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[26],
            SD: XXXStructDescrPodDNSConfig,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[27],
            SD: XXXStructDescrPodReadinessGate,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[28],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[29],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[30],
            EG: XXXEnumGroupPreemptionPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[31],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[32],
            SD: XXXStructDescrTopologySpreadConstraint,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[33],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[34],
            SD: XXXStructDescrPodOS,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[35],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[36],
            SD: XXXStructDescrPodSchedulingGate,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[37],
            SD: XXXStructDescrPodResourceClaim,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodSpec.Fields[38],
            SD: XXXStructDescrResourceRequirements,  
        },  
    },
}

var XXXStructDescrPodStatus = &reflect.XXXStructDescrImpl{
    Name:      "PodStatus",
    Pkg:       XXXMappingPodStatus.Pkg,
    Path:      XXXMappingPodStatus.Path,
    Mapping:   XXXMappingPodStatus,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[0],
            EG: XXXEnumGroupPodPhase, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[1],
            SD: XXXStructDescrPodCondition,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[6],
            SD: XXXStructDescrHostIP,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[7],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[8],
            SD: XXXStructDescrPodIP,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[9],
            SD: XXXStructDescrTime,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[10],
            SD: XXXStructDescrContainerStatus,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[11],
            SD: XXXStructDescrContainerStatus,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[12],
            EG: XXXEnumGroupPodQOSClass, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[13],
            SD: XXXStructDescrContainerStatus,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[14],
            EG: XXXEnumGroupPodResizeStatus, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[15],
            SD: XXXStructDescrPodResourceClaimStatus,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPodStatus.Fields[16],  
        },  
    },
}

var XXXStructDescrPreferredSchedulingTerm = &reflect.XXXStructDescrImpl{
    Name:      "PreferredSchedulingTerm",
    Pkg:       XXXMappingPreferredSchedulingTerm.Pkg,
    Path:      XXXMappingPreferredSchedulingTerm.Path,
    Mapping:   XXXMappingPreferredSchedulingTerm,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPreferredSchedulingTerm.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingPreferredSchedulingTerm.Fields[1],
            SD: XXXStructDescrNodeSelectorTerm,  
        },  
    },
}

var XXXStructDescrProbe = &reflect.XXXStructDescrImpl{
    Name:      "Probe",
    Pkg:       XXXMappingProbe.Pkg,
    Path:      XXXMappingProbe.Path,
    Mapping:   XXXMappingProbe,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbe.Fields[0],
            SD: XXXStructDescrProbeHandler,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbe.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbe.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbe.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbe.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbe.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbe.Fields[6],  
        },  
    },
}

var XXXStructDescrProbeHandler = &reflect.XXXStructDescrImpl{
    Name:      "ProbeHandler",
    Pkg:       XXXMappingProbeHandler.Pkg,
    Path:      XXXMappingProbeHandler.Path,
    Mapping:   XXXMappingProbeHandler,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbeHandler.Fields[0],
            SD: XXXStructDescrExecAction,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbeHandler.Fields[1],
            SD: XXXStructDescrHTTPGetAction,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbeHandler.Fields[2],
            SD: XXXStructDescrTCPSocketAction,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProbeHandler.Fields[3],
            SD: XXXStructDescrGRPCAction,  
        },  
    },
}

var XXXStructDescrProjectedVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "ProjectedVolumeSource",
    Pkg:       XXXMappingProjectedVolumeSource.Pkg,
    Path:      XXXMappingProjectedVolumeSource.Path,
    Mapping:   XXXMappingProjectedVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProjectedVolumeSource.Fields[0],
            SD: XXXStructDescrVolumeProjection,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingProjectedVolumeSource.Fields[1],  
        },  
    },
}

var XXXStructDescrResourceClaim = &reflect.XXXStructDescrImpl{
    Name:      "ResourceClaim",
    Pkg:       XXXMappingResourceClaim.Pkg,
    Path:      XXXMappingResourceClaim.Path,
    Mapping:   XXXMappingResourceClaim,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingResourceClaim.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingResourceClaim.Fields[1],  
        },  
    },
}

var XXXStructDescrResourceFieldSelector = &reflect.XXXStructDescrImpl{
    Name:      "ResourceFieldSelector",
    Pkg:       XXXMappingResourceFieldSelector.Pkg,
    Path:      XXXMappingResourceFieldSelector.Path,
    Mapping:   XXXMappingResourceFieldSelector,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingResourceFieldSelector.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingResourceFieldSelector.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingResourceFieldSelector.Fields[2],  
        },  
    },
}

var XXXStructDescrResourceRequirements = &reflect.XXXStructDescrImpl{
    Name:      "ResourceRequirements",
    Pkg:       XXXMappingResourceRequirements.Pkg,
    Path:      XXXMappingResourceRequirements.Path,
    Mapping:   XXXMappingResourceRequirements,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingResourceRequirements.Fields[0],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingResourceRequirements.Fields[1],
            SD: XXXStructDescrKeyValue,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingResourceRequirements.Fields[2],
            SD: XXXStructDescrResourceClaim,  
        },  
    },
}

var XXXStructDescrSELinuxOptions = &reflect.XXXStructDescrImpl{
    Name:      "SELinuxOptions",
    Pkg:       XXXMappingSELinuxOptions.Pkg,
    Path:      XXXMappingSELinuxOptions.Path,
    Mapping:   XXXMappingSELinuxOptions,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSELinuxOptions.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSELinuxOptions.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSELinuxOptions.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSELinuxOptions.Fields[3],  
        },  
    },
}

var XXXStructDescrSeccompProfile = &reflect.XXXStructDescrImpl{
    Name:      "SeccompProfile",
    Pkg:       XXXMappingSeccompProfile.Pkg,
    Path:      XXXMappingSeccompProfile.Path,
    Mapping:   XXXMappingSeccompProfile,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSeccompProfile.Fields[0],
            EG: XXXEnumGroupSeccompProfileType, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSeccompProfile.Fields[1],  
        },  
    },
}

var XXXStructDescrSecretEnvSource = &reflect.XXXStructDescrImpl{
    Name:      "SecretEnvSource",
    Pkg:       XXXMappingSecretEnvSource.Pkg,
    Path:      XXXMappingSecretEnvSource.Path,
    Mapping:   XXXMappingSecretEnvSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretEnvSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretEnvSource.Fields[1],  
        },  
    },
}

var XXXStructDescrSecretKeySelector = &reflect.XXXStructDescrImpl{
    Name:      "SecretKeySelector",
    Pkg:       XXXMappingSecretKeySelector.Pkg,
    Path:      XXXMappingSecretKeySelector.Path,
    Mapping:   XXXMappingSecretKeySelector,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretKeySelector.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretKeySelector.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretKeySelector.Fields[2],  
        },  
    },
}

var XXXStructDescrSecretProjection = &reflect.XXXStructDescrImpl{
    Name:      "SecretProjection",
    Pkg:       XXXMappingSecretProjection.Pkg,
    Path:      XXXMappingSecretProjection.Path,
    Mapping:   XXXMappingSecretProjection,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretProjection.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretProjection.Fields[1],
            SD: XXXStructDescrKeyToPath,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretProjection.Fields[2],  
        },  
    },
}

var XXXStructDescrSecretVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "SecretVolumeSource",
    Pkg:       XXXMappingSecretVolumeSource.Pkg,
    Path:      XXXMappingSecretVolumeSource.Path,
    Mapping:   XXXMappingSecretVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretVolumeSource.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretVolumeSource.Fields[1],
            SD: XXXStructDescrKeyToPath,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretVolumeSource.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecretVolumeSource.Fields[3],  
        },  
    },
}

var XXXStructDescrSecurityContext = &reflect.XXXStructDescrImpl{
    Name:      "SecurityContext",
    Pkg:       XXXMappingSecurityContext.Pkg,
    Path:      XXXMappingSecurityContext.Path,
    Mapping:   XXXMappingSecurityContext,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[0],
            SD: XXXStructDescrCapabilities,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[2],
            SD: XXXStructDescrSELinuxOptions,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[3],
            SD: XXXStructDescrWindowsSecurityContextOptions,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[5],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[6],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[7],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[8],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[9],
            EG: XXXEnumGroupProcMountType, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[10],
            SD: XXXStructDescrSeccompProfile,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSecurityContext.Fields[11],
            SD: XXXStructDescrAppArmorProfile,  
        },  
    },
}

var XXXStructDescrServiceAccountTokenProjection = &reflect.XXXStructDescrImpl{
    Name:      "ServiceAccountTokenProjection",
    Pkg:       XXXMappingServiceAccountTokenProjection.Pkg,
    Path:      XXXMappingServiceAccountTokenProjection.Path,
    Mapping:   XXXMappingServiceAccountTokenProjection,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingServiceAccountTokenProjection.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingServiceAccountTokenProjection.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingServiceAccountTokenProjection.Fields[2],  
        },  
    },
}

var XXXStructDescrSleepAction = &reflect.XXXStructDescrImpl{
    Name:      "SleepAction",
    Pkg:       XXXMappingSleepAction.Pkg,
    Path:      XXXMappingSleepAction.Path,
    Mapping:   XXXMappingSleepAction,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSleepAction.Fields[0],  
        },  
    },
}

var XXXStructDescrSysctl = &reflect.XXXStructDescrImpl{
    Name:      "Sysctl",
    Pkg:       XXXMappingSysctl.Pkg,
    Path:      XXXMappingSysctl.Path,
    Mapping:   XXXMappingSysctl,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSysctl.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingSysctl.Fields[1],  
        },  
    },
}

var XXXStructDescrTCPSocketAction = &reflect.XXXStructDescrImpl{
    Name:      "TCPSocketAction",
    Pkg:       XXXMappingTCPSocketAction.Pkg,
    Path:      XXXMappingTCPSocketAction.Path,
    Mapping:   XXXMappingTCPSocketAction,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTCPSocketAction.Fields[0],
            SD: XXXStructDescrIntOrString,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTCPSocketAction.Fields[1],  
        },  
    },
}

var XXXStructDescrTime = &reflect.XXXStructDescrImpl{
    Name:      "Time",
    Pkg:       XXXMappingTime.Pkg,
    Path:      XXXMappingTime.Path,
    Mapping:   XXXMappingTime,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTime.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTime.Fields[1],  
        },  
    },
}

var XXXStructDescrToleration = &reflect.XXXStructDescrImpl{
    Name:      "Toleration",
    Pkg:       XXXMappingToleration.Pkg,
    Path:      XXXMappingToleration.Path,
    Mapping:   XXXMappingToleration,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingToleration.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingToleration.Fields[1],
            EG: XXXEnumGroupTolerationOperator, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingToleration.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingToleration.Fields[3],
            EG: XXXEnumGroupTaintEffect, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingToleration.Fields[4],  
        },  
    },
}

var XXXStructDescrTopologySpreadConstraint = &reflect.XXXStructDescrImpl{
    Name:      "TopologySpreadConstraint",
    Pkg:       XXXMappingTopologySpreadConstraint.Pkg,
    Path:      XXXMappingTopologySpreadConstraint.Path,
    Mapping:   XXXMappingTopologySpreadConstraint,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTopologySpreadConstraint.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTopologySpreadConstraint.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTopologySpreadConstraint.Fields[2],
            EG: XXXEnumGroupUnsatisfiableConstraintAction, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTopologySpreadConstraint.Fields[3],
            SD: XXXStructDescrLabelSelector,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTopologySpreadConstraint.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTopologySpreadConstraint.Fields[5],
            EG: XXXEnumGroupNodeInclusionPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTopologySpreadConstraint.Fields[6],
            EG: XXXEnumGroupNodeInclusionPolicy, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTopologySpreadConstraint.Fields[7],  
        },  
    },
}

var XXXStructDescrTypeMeta = &reflect.XXXStructDescrImpl{
    Name:      "TypeMeta",
    Pkg:       XXXMappingTypeMeta.Pkg,
    Path:      XXXMappingTypeMeta.Path,
    Mapping:   XXXMappingTypeMeta,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypeMeta.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypeMeta.Fields[1],  
        },  
    },
}

var XXXStructDescrTypedLocalObjectReference = &reflect.XXXStructDescrImpl{
    Name:      "TypedLocalObjectReference",
    Pkg:       XXXMappingTypedLocalObjectReference.Pkg,
    Path:      XXXMappingTypedLocalObjectReference.Path,
    Mapping:   XXXMappingTypedLocalObjectReference,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypedLocalObjectReference.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypedLocalObjectReference.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypedLocalObjectReference.Fields[2],  
        },  
    },
}

var XXXStructDescrTypedObjectReference = &reflect.XXXStructDescrImpl{
    Name:      "TypedObjectReference",
    Pkg:       XXXMappingTypedObjectReference.Pkg,
    Path:      XXXMappingTypedObjectReference.Path,
    Mapping:   XXXMappingTypedObjectReference,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypedObjectReference.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypedObjectReference.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypedObjectReference.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingTypedObjectReference.Fields[3],  
        },  
    },
}

var XXXStructDescrVolume = &reflect.XXXStructDescrImpl{
    Name:      "Volume",
    Pkg:       XXXMappingVolume.Pkg,
    Path:      XXXMappingVolume.Path,
    Mapping:   XXXMappingVolume,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolume.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolume.Fields[1],
            SD: XXXStructDescrVolumeSource,  
        },  
    },
}

var XXXStructDescrVolumeDevice = &reflect.XXXStructDescrImpl{
    Name:      "VolumeDevice",
    Pkg:       XXXMappingVolumeDevice.Pkg,
    Path:      XXXMappingVolumeDevice.Path,
    Mapping:   XXXMappingVolumeDevice,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeDevice.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeDevice.Fields[1],  
        },  
    },
}

var XXXStructDescrVolumeMount = &reflect.XXXStructDescrImpl{
    Name:      "VolumeMount",
    Pkg:       XXXMappingVolumeMount.Pkg,
    Path:      XXXMappingVolumeMount.Path,
    Mapping:   XXXMappingVolumeMount,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMount.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMount.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMount.Fields[2],
            EG: XXXEnumGroupRecursiveReadOnlyMode, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMount.Fields[3],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMount.Fields[4],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMount.Fields[5],
            EG: XXXEnumGroupMountPropagationMode, 
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMount.Fields[6],  
        },  
    },
}

var XXXStructDescrVolumeMountStatus = &reflect.XXXStructDescrImpl{
    Name:      "VolumeMountStatus",
    Pkg:       XXXMappingVolumeMountStatus.Pkg,
    Path:      XXXMappingVolumeMountStatus.Path,
    Mapping:   XXXMappingVolumeMountStatus,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMountStatus.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMountStatus.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMountStatus.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeMountStatus.Fields[3],
            EG: XXXEnumGroupRecursiveReadOnlyMode, 
        },  
    },
}

var XXXStructDescrVolumeProjection = &reflect.XXXStructDescrImpl{
    Name:      "VolumeProjection",
    Pkg:       XXXMappingVolumeProjection.Pkg,
    Path:      XXXMappingVolumeProjection.Path,
    Mapping:   XXXMappingVolumeProjection,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeProjection.Fields[0],
            SD: XXXStructDescrSecretProjection,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeProjection.Fields[1],
            SD: XXXStructDescrDownwardAPIProjection,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeProjection.Fields[2],
            SD: XXXStructDescrConfigMapProjection,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeProjection.Fields[3],
            SD: XXXStructDescrServiceAccountTokenProjection,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeProjection.Fields[4],
            SD: XXXStructDescrClusterTrustBundleProjection,  
        },  
    },
}

var XXXStructDescrVolumeSource = &reflect.XXXStructDescrImpl{
    Name:      "VolumeSource",
    Pkg:       XXXMappingVolumeSource.Pkg,
    Path:      XXXMappingVolumeSource.Path,
    Mapping:   XXXMappingVolumeSource,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[0],
            SD: XXXStructDescrHostPathVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[1],
            SD: XXXStructDescrEmptyDirVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[2],
            SD: XXXStructDescrGCEPersistentDiskVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[3],
            SD: XXXStructDescrAWSElasticBlockStoreVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[4],
            SD: XXXStructDescrSecretVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[5],
            SD: XXXStructDescrNFSVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[6],
            SD: XXXStructDescrPersistentVolumeClaimVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[7],
            SD: XXXStructDescrDownwardAPIVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[8],
            SD: XXXStructDescrConfigMapVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[9],
            SD: XXXStructDescrProjectedVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[10],
            SD: XXXStructDescrCSIVolumeSource,  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingVolumeSource.Fields[11],
            SD: XXXStructDescrEphemeralVolumeSource,  
        },  
    },
}

var XXXStructDescrWeightedPodAffinityTerm = &reflect.XXXStructDescrImpl{
    Name:      "WeightedPodAffinityTerm",
    Pkg:       XXXMappingWeightedPodAffinityTerm.Pkg,
    Path:      XXXMappingWeightedPodAffinityTerm.Path,
    Mapping:   XXXMappingWeightedPodAffinityTerm,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingWeightedPodAffinityTerm.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingWeightedPodAffinityTerm.Fields[1],
            SD: XXXStructDescrPodAffinityTerm,  
        },  
    },
}

var XXXStructDescrWindowsSecurityContextOptions = &reflect.XXXStructDescrImpl{
    Name:      "WindowsSecurityContextOptions",
    Pkg:       XXXMappingWindowsSecurityContextOptions.Pkg,
    Path:      XXXMappingWindowsSecurityContextOptions.Path,
    Mapping:   XXXMappingWindowsSecurityContextOptions,
    FieldList: []reflect.FieldDescr {
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingWindowsSecurityContextOptions.Fields[0],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingWindowsSecurityContextOptions.Fields[1],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingWindowsSecurityContextOptions.Fields[2],  
        }, 
        
        reflect.XXXFieldDescrImpl{
            FD:  XXXMappingWindowsSecurityContextOptions.Fields[3],  
        },  
    },
}

var XXXStructDescrs = map[string]*reflect.XXXStructDescrImpl{
    "AWSElasticBlockStoreVolumeSource":  XXXStructDescrAWSElasticBlockStoreVolumeSource,
    "Affinity":  XXXStructDescrAffinity,
    "AppArmorProfile":  XXXStructDescrAppArmorProfile,
    "CSIVolumeSource":  XXXStructDescrCSIVolumeSource,
    "Capabilities":  XXXStructDescrCapabilities,
    "ClusterTrustBundleProjection":  XXXStructDescrClusterTrustBundleProjection,
    "ConfigMapEnvSource":  XXXStructDescrConfigMapEnvSource,
    "ConfigMapKeySelector":  XXXStructDescrConfigMapKeySelector,
    "ConfigMapProjection":  XXXStructDescrConfigMapProjection,
    "ConfigMapVolumeSource":  XXXStructDescrConfigMapVolumeSource,
    "Container":  XXXStructDescrContainer,
    "ContainerPort":  XXXStructDescrContainerPort,
    "ContainerResizePolicy":  XXXStructDescrContainerResizePolicy,
    "ContainerState":  XXXStructDescrContainerState,
    "ContainerStateRunning":  XXXStructDescrContainerStateRunning,
    "ContainerStateTerminated":  XXXStructDescrContainerStateTerminated,
    "ContainerStateWaiting":  XXXStructDescrContainerStateWaiting,
    "ContainerStatus":  XXXStructDescrContainerStatus,
    "DownwardAPIProjection":  XXXStructDescrDownwardAPIProjection,
    "DownwardAPIVolumeFile":  XXXStructDescrDownwardAPIVolumeFile,
    "DownwardAPIVolumeSource":  XXXStructDescrDownwardAPIVolumeSource,
    "EmptyDirVolumeSource":  XXXStructDescrEmptyDirVolumeSource,
    "EnvFromSource":  XXXStructDescrEnvFromSource,
    "EnvVar":  XXXStructDescrEnvVar,
    "EnvVarSource":  XXXStructDescrEnvVarSource,
    "EphemeralContainer":  XXXStructDescrEphemeralContainer,
    "EphemeralVolumeSource":  XXXStructDescrEphemeralVolumeSource,
    "ExecAction":  XXXStructDescrExecAction,
    "GCEPersistentDiskVolumeSource":  XXXStructDescrGCEPersistentDiskVolumeSource,
    "GRPCAction":  XXXStructDescrGRPCAction,
    "HTTPGetAction":  XXXStructDescrHTTPGetAction,
    "HTTPHeader":  XXXStructDescrHTTPHeader,
    "HostAlias":  XXXStructDescrHostAlias,
    "HostIP":  XXXStructDescrHostIP,
    "HostPathVolumeSource":  XXXStructDescrHostPathVolumeSource,
    "IntOrString":  XXXStructDescrIntOrString,
    "KeyToPath":  XXXStructDescrKeyToPath,
    "KeyValue":  XXXStructDescrKeyValue,
    "LabelSelector":  XXXStructDescrLabelSelector,
    "LabelSelectorRequirement":  XXXStructDescrLabelSelectorRequirement,
    "Lifecycle":  XXXStructDescrLifecycle,
    "LifecycleHandler":  XXXStructDescrLifecycleHandler,
    "LocalObjectReference":  XXXStructDescrLocalObjectReference,
    "ManagedFieldsEntry":  XXXStructDescrManagedFieldsEntry,
    "NFSVolumeSource":  XXXStructDescrNFSVolumeSource,
    "NodeAffinity":  XXXStructDescrNodeAffinity,
    "NodeSelector":  XXXStructDescrNodeSelector,
    "NodeSelectorRequirement":  XXXStructDescrNodeSelectorRequirement,
    "NodeSelectorTerm":  XXXStructDescrNodeSelectorTerm,
    "ObjectFieldSelector":  XXXStructDescrObjectFieldSelector,
    "ObjectMeta":  XXXStructDescrObjectMeta,
    "OwnerReference":  XXXStructDescrOwnerReference,
    "PersistentVolumeClaimSpec":  XXXStructDescrPersistentVolumeClaimSpec,
    "PersistentVolumeClaimTemplate":  XXXStructDescrPersistentVolumeClaimTemplate,
    "PersistentVolumeClaimVolumeSource":  XXXStructDescrPersistentVolumeClaimVolumeSource,
    "Pod":  XXXStructDescrPod,
    "PodAffinity":  XXXStructDescrPodAffinity,
    "PodAffinityTerm":  XXXStructDescrPodAffinityTerm,
    "PodAntiAffinity":  XXXStructDescrPodAntiAffinity,
    "PodCondition":  XXXStructDescrPodCondition,
    "PodDNSConfig":  XXXStructDescrPodDNSConfig,
    "PodDNSConfigOption":  XXXStructDescrPodDNSConfigOption,
    "PodIP":  XXXStructDescrPodIP,
    "PodOS":  XXXStructDescrPodOS,
    "PodReadinessGate":  XXXStructDescrPodReadinessGate,
    "PodResourceClaim":  XXXStructDescrPodResourceClaim,
    "PodResourceClaimStatus":  XXXStructDescrPodResourceClaimStatus,
    "PodSchedulingGate":  XXXStructDescrPodSchedulingGate,
    "PodSecurityContext":  XXXStructDescrPodSecurityContext,
    "PodSpec":  XXXStructDescrPodSpec,
    "PodStatus":  XXXStructDescrPodStatus,
    "PreferredSchedulingTerm":  XXXStructDescrPreferredSchedulingTerm,
    "Probe":  XXXStructDescrProbe,
    "ProbeHandler":  XXXStructDescrProbeHandler,
    "ProjectedVolumeSource":  XXXStructDescrProjectedVolumeSource,
    "ResourceClaim":  XXXStructDescrResourceClaim,
    "ResourceFieldSelector":  XXXStructDescrResourceFieldSelector,
    "ResourceRequirements":  XXXStructDescrResourceRequirements,
    "SELinuxOptions":  XXXStructDescrSELinuxOptions,
    "SeccompProfile":  XXXStructDescrSeccompProfile,
    "SecretEnvSource":  XXXStructDescrSecretEnvSource,
    "SecretKeySelector":  XXXStructDescrSecretKeySelector,
    "SecretProjection":  XXXStructDescrSecretProjection,
    "SecretVolumeSource":  XXXStructDescrSecretVolumeSource,
    "SecurityContext":  XXXStructDescrSecurityContext,
    "ServiceAccountTokenProjection":  XXXStructDescrServiceAccountTokenProjection,
    "SleepAction":  XXXStructDescrSleepAction,
    "Sysctl":  XXXStructDescrSysctl,
    "TCPSocketAction":  XXXStructDescrTCPSocketAction,
    "Time":  XXXStructDescrTime,
    "Toleration":  XXXStructDescrToleration,
    "TopologySpreadConstraint":  XXXStructDescrTopologySpreadConstraint,
    "TypeMeta":  XXXStructDescrTypeMeta,
    "TypedLocalObjectReference":  XXXStructDescrTypedLocalObjectReference,
    "TypedObjectReference":  XXXStructDescrTypedObjectReference,
    "Volume":  XXXStructDescrVolume,
    "VolumeDevice":  XXXStructDescrVolumeDevice,
    "VolumeMount":  XXXStructDescrVolumeMount,
    "VolumeMountStatus":  XXXStructDescrVolumeMountStatus,
    "VolumeProjection":  XXXStructDescrVolumeProjection,
    "VolumeSource":  XXXStructDescrVolumeSource,
    "WeightedPodAffinityTerm":  XXXStructDescrWeightedPodAffinityTerm,
    "WindowsSecurityContextOptions":  XXXStructDescrWindowsSecurityContextOptions,
}

// Deprecated: No deprecated, but shouldn't be used directly or show up in documentation.
var XXXPackageDescr reflect.PackageDescr = &reflect.XXXPackageDescrImpl{
    Name: "pod",
    Path: "github.com/bearlytools/claw/benchmark/msgs/claw",
    EnumGroupsDescrs: XXXEnumGroups,
    StructsDescrs: reflect.XXXStructDescrsImpl{
        Descrs: []reflect.StructDescr{
            XXXStructDescrAWSElasticBlockStoreVolumeSource,
            XXXStructDescrAffinity,
            XXXStructDescrAppArmorProfile,
            XXXStructDescrCSIVolumeSource,
            XXXStructDescrCapabilities,
            XXXStructDescrClusterTrustBundleProjection,
            XXXStructDescrConfigMapEnvSource,
            XXXStructDescrConfigMapKeySelector,
            XXXStructDescrConfigMapProjection,
            XXXStructDescrConfigMapVolumeSource,
            XXXStructDescrContainer,
            XXXStructDescrContainerPort,
            XXXStructDescrContainerResizePolicy,
            XXXStructDescrContainerState,
            XXXStructDescrContainerStateRunning,
            XXXStructDescrContainerStateTerminated,
            XXXStructDescrContainerStateWaiting,
            XXXStructDescrContainerStatus,
            XXXStructDescrDownwardAPIProjection,
            XXXStructDescrDownwardAPIVolumeFile,
            XXXStructDescrDownwardAPIVolumeSource,
            XXXStructDescrEmptyDirVolumeSource,
            XXXStructDescrEnvFromSource,
            XXXStructDescrEnvVar,
            XXXStructDescrEnvVarSource,
            XXXStructDescrEphemeralContainer,
            XXXStructDescrEphemeralVolumeSource,
            XXXStructDescrExecAction,
            XXXStructDescrGCEPersistentDiskVolumeSource,
            XXXStructDescrGRPCAction,
            XXXStructDescrHTTPGetAction,
            XXXStructDescrHTTPHeader,
            XXXStructDescrHostAlias,
            XXXStructDescrHostIP,
            XXXStructDescrHostPathVolumeSource,
            XXXStructDescrIntOrString,
            XXXStructDescrKeyToPath,
            XXXStructDescrKeyValue,
            XXXStructDescrLabelSelector,
            XXXStructDescrLabelSelectorRequirement,
            XXXStructDescrLifecycle,
            XXXStructDescrLifecycleHandler,
            XXXStructDescrLocalObjectReference,
            XXXStructDescrManagedFieldsEntry,
            XXXStructDescrNFSVolumeSource,
            XXXStructDescrNodeAffinity,
            XXXStructDescrNodeSelector,
            XXXStructDescrNodeSelectorRequirement,
            XXXStructDescrNodeSelectorTerm,
            XXXStructDescrObjectFieldSelector,
            XXXStructDescrObjectMeta,
            XXXStructDescrOwnerReference,
            XXXStructDescrPersistentVolumeClaimSpec,
            XXXStructDescrPersistentVolumeClaimTemplate,
            XXXStructDescrPersistentVolumeClaimVolumeSource,
            XXXStructDescrPod,
            XXXStructDescrPodAffinity,
            XXXStructDescrPodAffinityTerm,
            XXXStructDescrPodAntiAffinity,
            XXXStructDescrPodCondition,
            XXXStructDescrPodDNSConfig,
            XXXStructDescrPodDNSConfigOption,
            XXXStructDescrPodIP,
            XXXStructDescrPodOS,
            XXXStructDescrPodReadinessGate,
            XXXStructDescrPodResourceClaim,
            XXXStructDescrPodResourceClaimStatus,
            XXXStructDescrPodSchedulingGate,
            XXXStructDescrPodSecurityContext,
            XXXStructDescrPodSpec,
            XXXStructDescrPodStatus,
            XXXStructDescrPreferredSchedulingTerm,
            XXXStructDescrProbe,
            XXXStructDescrProbeHandler,
            XXXStructDescrProjectedVolumeSource,
            XXXStructDescrResourceClaim,
            XXXStructDescrResourceFieldSelector,
            XXXStructDescrResourceRequirements,
            XXXStructDescrSELinuxOptions,
            XXXStructDescrSeccompProfile,
            XXXStructDescrSecretEnvSource,
            XXXStructDescrSecretKeySelector,
            XXXStructDescrSecretProjection,
            XXXStructDescrSecretVolumeSource,
            XXXStructDescrSecurityContext,
            XXXStructDescrServiceAccountTokenProjection,
            XXXStructDescrSleepAction,
            XXXStructDescrSysctl,
            XXXStructDescrTCPSocketAction,
            XXXStructDescrTime,
            XXXStructDescrToleration,
            XXXStructDescrTopologySpreadConstraint,
            XXXStructDescrTypeMeta,
            XXXStructDescrTypedLocalObjectReference,
            XXXStructDescrTypedObjectReference,
            XXXStructDescrVolume,
            XXXStructDescrVolumeDevice,
            XXXStructDescrVolumeMount,
            XXXStructDescrVolumeMountStatus,
            XXXStructDescrVolumeProjection,
            XXXStructDescrVolumeSource,
            XXXStructDescrWeightedPodAffinityTerm,
            XXXStructDescrWindowsSecurityContextOptions,
        },
    },
}

// PackageDescr returns a PackageDescr for this package.
func PackageDescr() reflect.PackageDescr {
    return XXXPackageDescr
}

// Registers our package description with the runtime.
func init() {
    runtime.RegisterPackage(XXXPackageDescr)

    // Register each struct type by its hash for Any field decoding.
    runtime.RegisterTypeHash(XXXTypeHashAWSElasticBlockStoreVolumeSource, runtime.TypeEntry{
        Name:     "AWSElasticBlockStoreVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewAWSElasticBlockStoreVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashAffinity, runtime.TypeEntry{
        Name:     "Affinity",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewAffinity(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashAppArmorProfile, runtime.TypeEntry{
        Name:     "AppArmorProfile",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewAppArmorProfile(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashCSIVolumeSource, runtime.TypeEntry{
        Name:     "CSIVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewCSIVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashCapabilities, runtime.TypeEntry{
        Name:     "Capabilities",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewCapabilities(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashClusterTrustBundleProjection, runtime.TypeEntry{
        Name:     "ClusterTrustBundleProjection",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewClusterTrustBundleProjection(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashConfigMapEnvSource, runtime.TypeEntry{
        Name:     "ConfigMapEnvSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewConfigMapEnvSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashConfigMapKeySelector, runtime.TypeEntry{
        Name:     "ConfigMapKeySelector",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewConfigMapKeySelector(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashConfigMapProjection, runtime.TypeEntry{
        Name:     "ConfigMapProjection",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewConfigMapProjection(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashConfigMapVolumeSource, runtime.TypeEntry{
        Name:     "ConfigMapVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewConfigMapVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashContainer, runtime.TypeEntry{
        Name:     "Container",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewContainer(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashContainerPort, runtime.TypeEntry{
        Name:     "ContainerPort",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewContainerPort(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashContainerResizePolicy, runtime.TypeEntry{
        Name:     "ContainerResizePolicy",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewContainerResizePolicy(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashContainerState, runtime.TypeEntry{
        Name:     "ContainerState",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewContainerState(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashContainerStateRunning, runtime.TypeEntry{
        Name:     "ContainerStateRunning",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewContainerStateRunning(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashContainerStateTerminated, runtime.TypeEntry{
        Name:     "ContainerStateTerminated",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewContainerStateTerminated(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashContainerStateWaiting, runtime.TypeEntry{
        Name:     "ContainerStateWaiting",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewContainerStateWaiting(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashContainerStatus, runtime.TypeEntry{
        Name:     "ContainerStatus",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewContainerStatus(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashDownwardAPIProjection, runtime.TypeEntry{
        Name:     "DownwardAPIProjection",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewDownwardAPIProjection(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashDownwardAPIVolumeFile, runtime.TypeEntry{
        Name:     "DownwardAPIVolumeFile",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewDownwardAPIVolumeFile(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashDownwardAPIVolumeSource, runtime.TypeEntry{
        Name:     "DownwardAPIVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewDownwardAPIVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashEmptyDirVolumeSource, runtime.TypeEntry{
        Name:     "EmptyDirVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewEmptyDirVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashEnvFromSource, runtime.TypeEntry{
        Name:     "EnvFromSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewEnvFromSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashEnvVar, runtime.TypeEntry{
        Name:     "EnvVar",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewEnvVar(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashEnvVarSource, runtime.TypeEntry{
        Name:     "EnvVarSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewEnvVarSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashEphemeralContainer, runtime.TypeEntry{
        Name:     "EphemeralContainer",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewEphemeralContainer(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashEphemeralVolumeSource, runtime.TypeEntry{
        Name:     "EphemeralVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewEphemeralVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashExecAction, runtime.TypeEntry{
        Name:     "ExecAction",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewExecAction(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashGCEPersistentDiskVolumeSource, runtime.TypeEntry{
        Name:     "GCEPersistentDiskVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewGCEPersistentDiskVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashGRPCAction, runtime.TypeEntry{
        Name:     "GRPCAction",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewGRPCAction(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashHTTPGetAction, runtime.TypeEntry{
        Name:     "HTTPGetAction",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewHTTPGetAction(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashHTTPHeader, runtime.TypeEntry{
        Name:     "HTTPHeader",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewHTTPHeader(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashHostAlias, runtime.TypeEntry{
        Name:     "HostAlias",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewHostAlias(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashHostIP, runtime.TypeEntry{
        Name:     "HostIP",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewHostIP(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashHostPathVolumeSource, runtime.TypeEntry{
        Name:     "HostPathVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewHostPathVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashIntOrString, runtime.TypeEntry{
        Name:     "IntOrString",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewIntOrString(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashKeyToPath, runtime.TypeEntry{
        Name:     "KeyToPath",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewKeyToPath(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashKeyValue, runtime.TypeEntry{
        Name:     "KeyValue",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewKeyValue(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashLabelSelector, runtime.TypeEntry{
        Name:     "LabelSelector",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewLabelSelector(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashLabelSelectorRequirement, runtime.TypeEntry{
        Name:     "LabelSelectorRequirement",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewLabelSelectorRequirement(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashLifecycle, runtime.TypeEntry{
        Name:     "Lifecycle",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewLifecycle(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashLifecycleHandler, runtime.TypeEntry{
        Name:     "LifecycleHandler",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewLifecycleHandler(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashLocalObjectReference, runtime.TypeEntry{
        Name:     "LocalObjectReference",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewLocalObjectReference(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashManagedFieldsEntry, runtime.TypeEntry{
        Name:     "ManagedFieldsEntry",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewManagedFieldsEntry(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashNFSVolumeSource, runtime.TypeEntry{
        Name:     "NFSVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewNFSVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashNodeAffinity, runtime.TypeEntry{
        Name:     "NodeAffinity",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewNodeAffinity(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashNodeSelector, runtime.TypeEntry{
        Name:     "NodeSelector",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewNodeSelector(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashNodeSelectorRequirement, runtime.TypeEntry{
        Name:     "NodeSelectorRequirement",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewNodeSelectorRequirement(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashNodeSelectorTerm, runtime.TypeEntry{
        Name:     "NodeSelectorTerm",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewNodeSelectorTerm(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashObjectFieldSelector, runtime.TypeEntry{
        Name:     "ObjectFieldSelector",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewObjectFieldSelector(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashObjectMeta, runtime.TypeEntry{
        Name:     "ObjectMeta",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewObjectMeta(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashOwnerReference, runtime.TypeEntry{
        Name:     "OwnerReference",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewOwnerReference(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPersistentVolumeClaimSpec, runtime.TypeEntry{
        Name:     "PersistentVolumeClaimSpec",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPersistentVolumeClaimSpec(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPersistentVolumeClaimTemplate, runtime.TypeEntry{
        Name:     "PersistentVolumeClaimTemplate",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPersistentVolumeClaimTemplate(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPersistentVolumeClaimVolumeSource, runtime.TypeEntry{
        Name:     "PersistentVolumeClaimVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPersistentVolumeClaimVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPod, runtime.TypeEntry{
        Name:     "Pod",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPod(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodAffinity, runtime.TypeEntry{
        Name:     "PodAffinity",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodAffinity(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodAffinityTerm, runtime.TypeEntry{
        Name:     "PodAffinityTerm",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodAffinityTerm(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodAntiAffinity, runtime.TypeEntry{
        Name:     "PodAntiAffinity",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodAntiAffinity(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodCondition, runtime.TypeEntry{
        Name:     "PodCondition",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodCondition(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodDNSConfig, runtime.TypeEntry{
        Name:     "PodDNSConfig",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodDNSConfig(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodDNSConfigOption, runtime.TypeEntry{
        Name:     "PodDNSConfigOption",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodDNSConfigOption(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodIP, runtime.TypeEntry{
        Name:     "PodIP",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodIP(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodOS, runtime.TypeEntry{
        Name:     "PodOS",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodOS(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodReadinessGate, runtime.TypeEntry{
        Name:     "PodReadinessGate",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodReadinessGate(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodResourceClaim, runtime.TypeEntry{
        Name:     "PodResourceClaim",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodResourceClaim(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodResourceClaimStatus, runtime.TypeEntry{
        Name:     "PodResourceClaimStatus",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodResourceClaimStatus(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodSchedulingGate, runtime.TypeEntry{
        Name:     "PodSchedulingGate",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodSchedulingGate(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodSecurityContext, runtime.TypeEntry{
        Name:     "PodSecurityContext",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodSecurityContext(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodSpec, runtime.TypeEntry{
        Name:     "PodSpec",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodSpec(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPodStatus, runtime.TypeEntry{
        Name:     "PodStatus",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPodStatus(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashPreferredSchedulingTerm, runtime.TypeEntry{
        Name:     "PreferredSchedulingTerm",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewPreferredSchedulingTerm(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashProbe, runtime.TypeEntry{
        Name:     "Probe",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewProbe(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashProbeHandler, runtime.TypeEntry{
        Name:     "ProbeHandler",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewProbeHandler(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashProjectedVolumeSource, runtime.TypeEntry{
        Name:     "ProjectedVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewProjectedVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashResourceClaim, runtime.TypeEntry{
        Name:     "ResourceClaim",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewResourceClaim(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashResourceFieldSelector, runtime.TypeEntry{
        Name:     "ResourceFieldSelector",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewResourceFieldSelector(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashResourceRequirements, runtime.TypeEntry{
        Name:     "ResourceRequirements",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewResourceRequirements(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSELinuxOptions, runtime.TypeEntry{
        Name:     "SELinuxOptions",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSELinuxOptions(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSeccompProfile, runtime.TypeEntry{
        Name:     "SeccompProfile",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSeccompProfile(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSecretEnvSource, runtime.TypeEntry{
        Name:     "SecretEnvSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSecretEnvSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSecretKeySelector, runtime.TypeEntry{
        Name:     "SecretKeySelector",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSecretKeySelector(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSecretProjection, runtime.TypeEntry{
        Name:     "SecretProjection",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSecretProjection(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSecretVolumeSource, runtime.TypeEntry{
        Name:     "SecretVolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSecretVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSecurityContext, runtime.TypeEntry{
        Name:     "SecurityContext",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSecurityContext(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashServiceAccountTokenProjection, runtime.TypeEntry{
        Name:     "ServiceAccountTokenProjection",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewServiceAccountTokenProjection(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSleepAction, runtime.TypeEntry{
        Name:     "SleepAction",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSleepAction(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashSysctl, runtime.TypeEntry{
        Name:     "Sysctl",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewSysctl(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashTCPSocketAction, runtime.TypeEntry{
        Name:     "TCPSocketAction",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewTCPSocketAction(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashTime, runtime.TypeEntry{
        Name:     "Time",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewTime(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashToleration, runtime.TypeEntry{
        Name:     "Toleration",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewToleration(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashTopologySpreadConstraint, runtime.TypeEntry{
        Name:     "TopologySpreadConstraint",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewTopologySpreadConstraint(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashTypeMeta, runtime.TypeEntry{
        Name:     "TypeMeta",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewTypeMeta(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashTypedLocalObjectReference, runtime.TypeEntry{
        Name:     "TypedLocalObjectReference",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewTypedLocalObjectReference(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashTypedObjectReference, runtime.TypeEntry{
        Name:     "TypedObjectReference",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewTypedObjectReference(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashVolume, runtime.TypeEntry{
        Name:     "Volume",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewVolume(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashVolumeDevice, runtime.TypeEntry{
        Name:     "VolumeDevice",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewVolumeDevice(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashVolumeMount, runtime.TypeEntry{
        Name:     "VolumeMount",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewVolumeMount(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashVolumeMountStatus, runtime.TypeEntry{
        Name:     "VolumeMountStatus",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewVolumeMountStatus(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashVolumeProjection, runtime.TypeEntry{
        Name:     "VolumeProjection",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewVolumeProjection(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashVolumeSource, runtime.TypeEntry{
        Name:     "VolumeSource",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewVolumeSource(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashWeightedPodAffinityTerm, runtime.TypeEntry{
        Name:     "WeightedPodAffinityTerm",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewWeightedPodAffinityTerm(ctx)
        },
    })
    runtime.RegisterTypeHash(XXXTypeHashWindowsSecurityContextOptions, runtime.TypeEntry{
        Name:     "WindowsSecurityContextOptions",
        FullPath: "github.com/bearlytools/claw/benchmark/msgs/claw",
        New: func(ctx context.Context) runtime.AnyType {
            return NewWindowsSecurityContextOptions(ctx)
        },
    })
}
